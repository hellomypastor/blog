{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/geek/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/geek/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/geek/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/geek/source/js/js.js","path":"js/js.js","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/jquery.min.js","path":"libs/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/HELP-US-OUT.txt","path":"libs/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/highlight.pack.js","path":"libs/highlight/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.css","path":"libs/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.min.css","path":"libs/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/FontAwesome.otf","path":"libs/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.eot","path":"libs/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.svg","path":"libs/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","path":"libs/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff","path":"libs/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","path":"libs/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/animated.less","path":"libs/font-awesome/less/animated.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/bordered-pulled.less","path":"libs/font-awesome/less/bordered-pulled.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/core.less","path":"libs/font-awesome/less/core.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/fixed-width.less","path":"libs/font-awesome/less/fixed-width.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/font-awesome.less","path":"libs/font-awesome/less/font-awesome.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/icons.less","path":"libs/font-awesome/less/icons.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/larger.less","path":"libs/font-awesome/less/larger.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/list.less","path":"libs/font-awesome/less/list.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/mixins.less","path":"libs/font-awesome/less/mixins.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/path.less","path":"libs/font-awesome/less/path.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/rotated-flipped.less","path":"libs/font-awesome/less/rotated-flipped.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/screen-reader.less","path":"libs/font-awesome/less/screen-reader.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/stacked.less","path":"libs/font-awesome/less/stacked.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/less/variables.less","path":"libs/font-awesome/less/variables.less","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/font-awesome/scss/font-awesome.scss","path":"libs/font-awesome/scss/font-awesome.scss","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/a11y-dark.css","path":"libs/highlight/styles/a11y-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/a11y-light.css","path":"libs/highlight/styles/a11y-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/agate.css","path":"libs/highlight/styles/agate.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/an-old-hope.css","path":"libs/highlight/styles/an-old-hope.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/androidstudio.css","path":"libs/highlight/styles/androidstudio.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/arduino-light.css","path":"libs/highlight/styles/arduino-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/arta.css","path":"libs/highlight/styles/arta.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ascetic.css","path":"libs/highlight/styles/ascetic.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-dark.css","path":"libs/highlight/styles/atelier-cave-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-light.css","path":"libs/highlight/styles/atelier-cave-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-dark.css","path":"libs/highlight/styles/atelier-dune-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-light.css","path":"libs/highlight/styles/atelier-dune-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-dark.css","path":"libs/highlight/styles/atelier-estuary-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-light.css","path":"libs/highlight/styles/atelier-estuary-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-dark.css","path":"libs/highlight/styles/atelier-forest-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-light.css","path":"libs/highlight/styles/atelier-forest-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-dark.css","path":"libs/highlight/styles/atelier-heath-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-light.css","path":"libs/highlight/styles/atelier-heath-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-dark.css","path":"libs/highlight/styles/atelier-lakeside-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-light.css","path":"libs/highlight/styles/atelier-lakeside-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-dark.css","path":"libs/highlight/styles/atelier-plateau-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-light.css","path":"libs/highlight/styles/atelier-plateau-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-dark.css","path":"libs/highlight/styles/atelier-savanna-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-light.css","path":"libs/highlight/styles/atelier-savanna-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-dark.css","path":"libs/highlight/styles/atelier-seaside-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-light.css","path":"libs/highlight/styles/atelier-seaside-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-dark.css","path":"libs/highlight/styles/atelier-sulphurpool-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-light.css","path":"libs/highlight/styles/atelier-sulphurpool-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark-reasonable.css","path":"libs/highlight/styles/atom-one-dark-reasonable.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark.css","path":"libs/highlight/styles/atom-one-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-light.css","path":"libs/highlight/styles/atom-one-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/brown-paper.css","path":"libs/highlight/styles/brown-paper.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/brown-papersq.png","path":"libs/highlight/styles/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/codepen-embed.css","path":"libs/highlight/styles/codepen-embed.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/color-brewer.css","path":"libs/highlight/styles/color-brewer.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/darcula.css","path":"libs/highlight/styles/darcula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/dark.css","path":"libs/highlight/styles/dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/darkula.css","path":"libs/highlight/styles/darkula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/default.css","path":"libs/highlight/styles/default.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/docco.css","path":"libs/highlight/styles/docco.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/dracula.css","path":"libs/highlight/styles/dracula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/far.css","path":"libs/highlight/styles/far.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/foundation.css","path":"libs/highlight/styles/foundation.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/github-gist.css","path":"libs/highlight/styles/github-gist.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/github.css","path":"libs/highlight/styles/github.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gml.css","path":"libs/highlight/styles/gml.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/googlecode.css","path":"libs/highlight/styles/googlecode.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gradient-dark.css","path":"libs/highlight/styles/gradient-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/grayscale.css","path":"libs/highlight/styles/grayscale.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-dark.css","path":"libs/highlight/styles/gruvbox-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-light.css","path":"libs/highlight/styles/gruvbox-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/hopscotch.css","path":"libs/highlight/styles/hopscotch.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/hybrid.css","path":"libs/highlight/styles/hybrid.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/idea.css","path":"libs/highlight/styles/idea.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ir-black.css","path":"libs/highlight/styles/ir-black.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-dark.css","path":"libs/highlight/styles/isbl-editor-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-light.css","path":"libs/highlight/styles/isbl-editor-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.dark.css","path":"libs/highlight/styles/kimbie.dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.light.css","path":"libs/highlight/styles/kimbie.light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/lightfair.css","path":"libs/highlight/styles/lightfair.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/magula.css","path":"libs/highlight/styles/magula.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/mono-blue.css","path":"libs/highlight/styles/mono-blue.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/monokai-sublime.css","path":"libs/highlight/styles/monokai-sublime.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/monokai.css","path":"libs/highlight/styles/monokai.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/night-owl.css","path":"libs/highlight/styles/night-owl.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/nord.css","path":"libs/highlight/styles/nord.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/obsidian.css","path":"libs/highlight/styles/obsidian.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/ocean.css","path":"libs/highlight/styles/ocean.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-dark.css","path":"libs/highlight/styles/paraiso-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-light.css","path":"libs/highlight/styles/paraiso-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.css","path":"libs/highlight/styles/pojoaque.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.jpg","path":"libs/highlight/styles/pojoaque.jpg","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/purebasic.css","path":"libs/highlight/styles/purebasic.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_dark.css","path":"libs/highlight/styles/qtcreator_dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_light.css","path":"libs/highlight/styles/qtcreator_light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/railscasts.css","path":"libs/highlight/styles/railscasts.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/rainbow.css","path":"libs/highlight/styles/rainbow.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/routeros.css","path":"libs/highlight/styles/routeros.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/school-book.css","path":"libs/highlight/styles/school-book.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/school-book.png","path":"libs/highlight/styles/school-book.png","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/shades-of-purple.css","path":"libs/highlight/styles/shades-of-purple.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/solarized-dark.css","path":"libs/highlight/styles/solarized-dark.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/solarized-light.css","path":"libs/highlight/styles/solarized-light.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/sunburst.css","path":"libs/highlight/styles/sunburst.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-blue.css","path":"libs/highlight/styles/tomorrow-night-blue.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-bright.css","path":"libs/highlight/styles/tomorrow-night-bright.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-eighties.css","path":"libs/highlight/styles/tomorrow-night-eighties.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow.css","path":"libs/highlight/styles/tomorrow.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night.css","path":"libs/highlight/styles/tomorrow-night.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/vs.css","path":"libs/highlight/styles/vs.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/vs2015.css","path":"libs/highlight/styles/vs2015.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/xcode.css","path":"libs/highlight/styles/xcode.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/xt256.css","path":"libs/highlight/styles/xt256.css","modified":0,"renderable":1},{"_id":"themes/geek/source/libs/highlight/styles/zenburn.css","path":"libs/highlight/styles/zenburn.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"1847b8316b9097d5c196713902916ecbd62d50b6","modified":1741354007251},{"_id":"source/categories/index.md","hash":"3fe09f8f28fad58b679c0717703ce672f7be557b","modified":1741354007262},{"_id":"source/about/index.md","hash":"3523329dd53571a75dfcb88f3084fa40827618a8","modified":1741354007262},{"_id":"source/tags/index.md","hash":"3c900113d3ef837d303d794a6a12fa898d3d5f26","modified":1741354007263},{"_id":"source/_posts/BUG：Restlet流式读取远端文件内容时inputstream未关闭.md","hash":"85594e1078f323a462fc188eca87864513e064e3","modified":1741354007251},{"_id":"source/_posts/BUG：无法确定T的类型参数.md","hash":"2752d75a9938f62bc2009745ae13d35a397ebb27","modified":1741354007251},{"_id":"source/_posts/Flask-SAE搭建微信后台初探.md","hash":"c345a522c248a6319b6952660a3ba6e86b1dc492","modified":1741354007252},{"_id":"source/_posts/Mac-OS安装软件时提示-“安装”已损坏，打不开-你应该推出磁盘映像的解决方法.md","hash":"3a44a5a4c0b4d72ef1341771a6da55d464e58566","modified":1741354007252},{"_id":"source/_posts/Spring-Test-Junit单元测试.md","hash":"42af7dfbfea9fc72954e424ab800031779ca2ef8","modified":1741354007252},{"_id":"source/_posts/docker命令学习（一）.md","hash":"8ef7f4234bb1d20a2d4f7281c3ae095999599187","modified":1741354007253},{"_id":"source/_posts/Java学习路线.md","hash":"af8943c9c667b899b05ea02f88d4bcaf222ffd03","modified":1741354007252},{"_id":"source/_posts/Java文件上传分析.md","hash":"ec5ff3c4b9f85bd0e4792f411221ed3b64e5d59e","modified":1741354007252},{"_id":"source/_posts/hello-world.md","hash":"7db5c0d64620a5350df8e1bc591ac66aa14c15f0","modified":1741354007253},{"_id":"source/_posts/java8-lambda.md","hash":"1846d5757d2d28e62b0b2910c9505caabb1e722d","modified":1741354007253},{"_id":"source/_posts/java8-interface.md","hash":"ddb5286f362db3a1065757a17a9dc638ddd80a66","modified":1741354007253},{"_id":"source/_posts/java8-optional.md","hash":"d4ac620ece3656b0c66ea5e29295a214a8f04e66","modified":1741354007254},{"_id":"source/_posts/java8-reference.md","hash":"b0d463f57fea58cfb589298b98ab14fa4075758a","modified":1741354007254},{"_id":"source/_posts/java8-atomic-operation.md","hash":"9b942ac6a80c0bc871fa88dd14783404ad945f1d","modified":1741354007253},{"_id":"source/_posts/java8-stream-performance.md","hash":"d6ce6c354bc50ef1677b4e8486afe80c3564678f","modified":1741354007254},{"_id":"source/_posts/java8-stream.md","hash":"be03f1a6b5bfcdbe0085c1321f4408c6845245d6","modified":1741354007254},{"_id":"source/_posts/java9-collection-factory.md","hash":"111783bb59ec6266c3a6f2c346e0008d9ecc7ff0","modified":1741354007255},{"_id":"source/_posts/java8.md","hash":"936352c43abc1c6c0f757a1b504615ada24ba744","modified":1741354007255},{"_id":"source/_posts/java8-time-date.md","hash":"aec6038ee2d28e63e638f2f6504acacc97eb56cd","modified":1741354007254},{"_id":"source/_posts/java9-diamond-operator.md","hash":"c0cb78d4eb2b7585ed9eab0f30171173bd3c7b5f","modified":1741354007255},{"_id":"source/_posts/java9-http-2-client.md","hash":"3fdbe236b896009d6b80ff150f0066dd093a3989","modified":1741354007255},{"_id":"source/_posts/java9-jdk-jre）.md","hash":"dc8c39089b7babeb2e08fd07512afc7da2a971bb","modified":1741354007255},{"_id":"source/_posts/java9-interface.md","hash":"9331109d7b3f93ce401a06086f9884b277692085","modified":1741354007255},{"_id":"source/_posts/java9-jshell.md","hash":"4d3da9c5ba33bc0fd56550b33c6da63fe37b7f19","modified":1741354007256},{"_id":"source/_posts/java9-module-jigsaw-modularity）.md","hash":"d2e49270cc0566e0230530a86257c35d7beca23e","modified":1741354007256},{"_id":"source/_posts/java9-module-analysis.md","hash":"61b0b9df88e65d19331aa58d6ac99caf9b56e25a","modified":1741354007256},{"_id":"source/_posts/java9-module-maven-starter.md","hash":"519d91dbec5c5d3e25a306f270c2c273796c00fe","modified":1741354007256},{"_id":"source/_posts/java9-stream.md","hash":"f178d77e9d908f186ad70b405fb44490a8c6cea6","modified":1741354007257},{"_id":"source/_posts/java9-string.md","hash":"a0f4fbdeed8bfcf07246603071a34a4e8870410d","modified":1741354007257},{"_id":"source/_posts/java9-try-with-resources.md","hash":"8891575593cf18abbf8d8715d5e2b8d1ac501bd6","modified":1741354007257},{"_id":"source/_posts/java9-module-spi.md","hash":"40fc22ad0075f912198811022e984b6232f0bf47","modified":1741354007256},{"_id":"source/_posts/jdk-collection.md","hash":"b0367fce9fb06d1cabbebced0eff7f2e5265f98f","modified":1741354007257},{"_id":"source/_posts/stream-peek-method-in-java-8-vs-java-9.md","hash":"ac4c616cf4435100cc62c12c337a8df5cd5d8b25","modified":1741354007258},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git入门介绍）.md","hash":"f8f9e41801e3bc1b2604a004c7f278faa2d8fc85","modified":1741354007258},{"_id":"source/_posts/java9.md","hash":"85be817b29ee194c43b1879df83c08155e3a0a64","modified":1741354007257},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git分支策略）.md","hash":"10d31c42c028839df320c1724c018fb11082f54f","modified":1741354007258},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git四大组件）.md","hash":"28c6eac76e8aa96d8840f4454c313eee67d238e8","modified":1741354007259},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git基础篇-上）.md","hash":"3f286a918e3d2551141a42af4240f6503c3cc64d","modified":1741354007259},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git基础篇-下）.md","hash":"cbacfe484768f86ab1baf8fadb7dfcc66af52ec2","modified":1741354007259},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git杂项）.md","hash":"3d6fcadf7fb20030b58531d593edf7b821f1e996","modified":1741354007259},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git高级话题）.md","hash":"dafeed3c37cf74dab7d48859dae1e465a0dfa613","modified":1741354007260},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git移交提交记录）.md","hash":"5e3a34a85f4558cce7115b4d7080933cdf2e66b0","modified":1741354007259},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（Git高级篇）.md","hash":"6af3ae055efddf7e529777ed519f26773528dcf1","modified":1741354007259},{"_id":"source/_posts/微信公众号企业付款.md","hash":"d8b25fb024284eeb0ea7c547e49d1fb72f5f72f3","modified":1741354007260},{"_id":"source/_posts/如何克服解决Git冲突的恐惧症？（序）.md","hash":"98257a86bd31c75d5e4e4b173be1a4a58ed78d2c","modified":1741354007260},{"_id":"source/_posts/微信公众号调用access-token接口频率限制解决-Java.md","hash":"3179abc16043212f6d2002cba038a64539c581b2","modified":1741354007260},{"_id":"source/_posts/微信公众号发红包实现.md","hash":"9f21036198a9871c0503933c59e045c22133fde3","modified":1741354007260},{"_id":"source/_posts/微信支付V3-x实现-Java后台.md","hash":"35c82d39dd40322f04585c10f79cc164edfac468","modified":1741354007260},{"_id":"source/_posts/阿里Java开发手册思考（一）.md","hash":"461540fc1a48aa7511d2ac3701b2e00d9e4ebde5","modified":1741354007261},{"_id":"source/_posts/阿里Java开发手册思考（二）.md","hash":"803d2c4ef66b016b18e107961103f8ca50952025","modified":1741354007261},{"_id":"source/_posts/阿里Java开发手册思考（三）.md","hash":"7494b4d78fb597a740c1c79c48b594ceb14c6401","modified":1741354007261},{"_id":"source/_posts/阿里Java开发手册思考（五）.md","hash":"bbb9c801bb8f7f0d3c81cd0835c1132f7fdbda9c","modified":1741354007261},{"_id":"source/_posts/阿里Java开发手册思考（四）.md","hash":"9213248b1498feeee101cbe0e38f576cd7169dec","modified":1741354007261},{"_id":"source/_posts/jdk-collection/jdk-collection.png","hash":"b9116bbb2d21b471bd693d79416039a4bc7c8df3","modified":1741354007258},{"_id":"themes/geek/_config.yml","hash":"8014399767b93508233348cd5b7cb5a95b5e02fd","modified":1741357600597},{"_id":"themes/geek/.gitignore","hash":"824c6bad36ef799350c37bcd0fe5a1a88295d2f8","modified":1741354211883},{"_id":"themes/geek/LICENSE","hash":"e8b834a986c4367c3b8dbee511b93f94f3145947","modified":1741354211883},{"_id":"themes/geek/README.md","hash":"95aa0a37d3639f5e1eb6bedbbb2cb9dc3bde3444","modified":1741354211883},{"_id":"themes/geek/layout/post.ejs","hash":"f5b31036768f4e7ae0577058f80e497562187a7c","modified":1741354211887},{"_id":"themes/geek/source/favicon.ico","hash":"8585da4c971c97523cc8c599110ed9a7e074241c","modified":1741354211889},{"_id":"themes/geek/layout/index.ejs","hash":"1bf40e757764d950af89a0baaf793b27946bbc92","modified":1741354211887},{"_id":"themes/geek/layout/_partial/footer.ejs","hash":"24f991fd3e4310cdd0c0a3f1cd57620596d854bf","modified":1741354211886},{"_id":"themes/geek/layout/_partial/nav.ejs","hash":"42e47f3014a43c8589adfa1f7f34355a586b1ec5","modified":1741354211887},{"_id":"themes/geek/layout/_partial/head.ejs","hash":"caa33d4a948dd9c4e8ccb116c2f1e4471842aec5","modified":1741354211886},{"_id":"themes/geek/layout/layout.ejs","hash":"710b13e895e7a9cc2341874fafbfeef1ae9b7279","modified":1741354211887},{"_id":"themes/geek/source/js/js.js","hash":"0fb795dc0d1c2da9bee007a73fe246a03c88626b","modified":1741354211890},{"_id":"themes/geek/source/css/_partial/index.styl","hash":"7750090da83d1a477d1735bed152434b2e9053ab","modified":1741354211888},{"_id":"themes/geek/source/css/style.styl","hash":"7f2970c1b1f8ff89de90739725526ebe2686e49f","modified":1741354211888},{"_id":"themes/geek/source/css/_partial/post.styl","hash":"23aba61940dd2f9719c778318bbaa92e859f6b60","modified":1741354211888},{"_id":"themes/geek/source/libs/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1741354211890},{"_id":"themes/geek/source/css/_partial/markdown.styl","hash":"ec536affb40d91a181b6fa1df22672a07188671a","modified":1741354211888},{"_id":"themes/geek/source/libs/highlight/highlight.pack.js","hash":"e5a87508b4ce2f7e00c8f792251a0837879a6311","modified":1741354211902},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1741354211891},{"_id":"themes/geek/source/libs/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1741354211891},{"_id":"themes/geek/source/libs/font-awesome/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1741354211896},{"_id":"themes/geek/source/libs/font-awesome/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1741354211896},{"_id":"themes/geek/source/libs/font-awesome/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1741354211898},{"_id":"themes/geek/source/libs/font-awesome/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1741354211898},{"_id":"themes/geek/source/libs/font-awesome/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1741354211898},{"_id":"themes/geek/source/libs/font-awesome/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1741354211898},{"_id":"themes/geek/source/libs/font-awesome/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1741354211898},{"_id":"themes/geek/source/libs/font-awesome/scss/_bordered-pulled.scss","hash":"164b6a0a2b307cd293f4a914ab0fcdf643950374","modified":1741354211899},{"_id":"themes/geek/source/libs/font-awesome/scss/_animated.scss","hash":"8daf189b2f8a404495b8424b6fd1ba630dd1c2dc","modified":1741354211899},{"_id":"themes/geek/source/libs/font-awesome/scss/_core.scss","hash":"55a14a34267edc401b82e5ee41d8bd84fbb5da3f","modified":1741354211900},{"_id":"themes/geek/source/libs/font-awesome/scss/_fixed-width.scss","hash":"224417ca266c657849afb2bbcb6dc455894ff387","modified":1741354211900},{"_id":"themes/geek/source/libs/font-awesome/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1741354211897},{"_id":"themes/geek/source/libs/font-awesome/scss/_larger.scss","hash":"940e1c5ebc690283bfaee92560cf15fabedbf6a9","modified":1741354211900},{"_id":"themes/geek/source/libs/font-awesome/scss/_list.scss","hash":"4b53ee01513df8b9ce76442b2d8f1851613a435c","modified":1741354211900},{"_id":"themes/geek/source/libs/font-awesome/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1741354211899},{"_id":"themes/geek/source/libs/font-awesome/scss/_mixins.scss","hash":"4f3881034a4c11cae8cc915f288477b498a357a2","modified":1741354211900},{"_id":"themes/geek/source/libs/font-awesome/scss/_path.scss","hash":"080158aeb1bf6df59ec98b2bbed44da61d9c9ca3","modified":1741354211901},{"_id":"themes/geek/source/libs/font-awesome/scss/_rotated-flipped.scss","hash":"ca08a0af3da63c2f2a7d3c27a8747637744cc785","modified":1741354211901},{"_id":"themes/geek/source/libs/font-awesome/scss/_screen-reader.scss","hash":"2d8563c488f68e75a28d540dd89301ee4ee08c97","modified":1741354211901},{"_id":"themes/geek/source/libs/font-awesome/scss/_stacked.scss","hash":"cf6752ee609af36eb293a7197c88d31ecacbbc74","modified":1741354211901},{"_id":"themes/geek/source/libs/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1741354211902},{"_id":"themes/geek/source/libs/highlight/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1741354211902},{"_id":"themes/geek/source/libs/highlight/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1741354211902},{"_id":"themes/geek/source/libs/highlight/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1741354211903},{"_id":"themes/geek/source/libs/highlight/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1741354211903},{"_id":"themes/geek/source/libs/highlight/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1741354211903},{"_id":"themes/geek/source/libs/font-awesome/scss/_variables.scss","hash":"0d6d70535104b42e60d7f44ae6ccf9de023a7b8b","modified":1741354211901},{"_id":"themes/geek/source/libs/font-awesome/scss/_icons.scss","hash":"830e0183337d16c07b1c63838f7593a33ee87b15","modified":1741354211900},{"_id":"themes/geek/source/libs/highlight/styles/arduino-light.css","hash":"141b53b2e2de6a321a695d816a836666c5e2c5e6","modified":1741354211903},{"_id":"themes/geek/source/libs/highlight/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1741354211904},{"_id":"themes/geek/source/libs/highlight/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1741354211904},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1741354211905},{"_id":"themes/geek/source/libs/highlight/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1741354211905},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1741354211905},{"_id":"themes/geek/source/libs/highlight/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1741354211905},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1741354211905},{"_id":"themes/geek/source/libs/highlight/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1741354211906},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1741354211907},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark-reasonable.css","hash":"90e194ba1c1fe2ca1b5f40b5eb7c29f40ab66ff4","modified":1741354211908},{"_id":"themes/geek/source/libs/highlight/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1741354211908},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1741354211908},{"_id":"themes/geek/source/libs/highlight/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1741354211908},{"_id":"themes/geek/source/libs/highlight/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1741354211908},{"_id":"themes/geek/source/libs/highlight/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/darcula.css","hash":"617241bc95a5dbbd741820bf296155b90e22d61b","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1741354211909},{"_id":"themes/geek/source/libs/highlight/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/foundation.css","hash":"29d960268ca944b5537ff2d2e70d620339dcd5d5","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/gml.css","hash":"0f3f5502247b00ce37dc2b362a6984305001dd50","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/gradient-dark.css","hash":"e49b73bab4446ec2dbc0befb860a1fdc27bf1b42","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1741354211910},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/hopscotch.css","hash":"3d258ff6f84900ad9abbe43f4ec8b8152c72e887","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/isbl-editor-light.css","hash":"41baadd11cf10bab67128dd104f704fdd149318e","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1741354211911},{"_id":"themes/geek/source/libs/highlight/styles/lightfair.css","hash":"3bdc4517354b7acc495562d8b4937c7a40a89f06","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/magula.css","hash":"8f5cfb7c23c705de7c95577563eb79beb49b68f6","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/mono-blue.css","hash":"3163f08756efa9e68e87addf20750e5650cdb8e4","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/monokai.css","hash":"99ab7678d541bc02a8d38de83a289c5e549a20ce","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/night-owl.css","hash":"d067142aeb74bfdcdec4acebb3241b3e79461bda","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1741354211912},{"_id":"themes/geek/source/libs/highlight/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/purebasic.css","hash":"e6bb7a57221bed7a601dc9d8d41d9b1425e2dea6","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1741354211913},{"_id":"themes/geek/source/libs/highlight/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/shades-of-purple.css","hash":"4d5b44a1615173d02b223ba2cce220ab70e09650","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1741354211914},{"_id":"themes/geek/source/libs/highlight/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1741354211915},{"_id":"themes/geek/source/libs/highlight/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1741354211916},{"_id":"themes/geek/source/libs/highlight/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1741354211916},{"_id":"themes/geek/source/libs/jquery.min.js","hash":"37b1db88b57438f1072a8ebc7559c909c9d3a682","modified":1741354211916},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1741354211896},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1741354211895},{"_id":"themes/geek/source/img/logo.png","hash":"f8e2caa981a79889fa58be8b8277ad6854caf447","modified":1741354211889},{"_id":"themes/geek/source/libs/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1741354211892},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1741354211893},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1741354211895},{"_id":"themes/geek/imgs/2.png","hash":"f63b6574c5f522b24e2cee18ba6b40b0676365e3","modified":1741354211886},{"_id":"themes/geek/source/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1741354211894},{"_id":"themes/geek/imgs/1.png","hash":"75038f82935c2ee04d753b76849c4ccbf3cdd222","modified":1741354211885},{"_id":"public/tags/index.html","hash":"336f521854c33d9ea996312de5bf29667df26568","modified":1741357609578},{"_id":"public/categories/index.html","hash":"1ca3363145c8895b054ccce351fed52c0c11d408","modified":1741357609578},{"_id":"public/about/index.html","hash":"5ba48439d3db8ff52cece961a3301e4a1600d491","modified":1741357609578},{"_id":"public/2018/10/17/stream-peek-method-in-java-8-vs-java-9/index.html","hash":"a50eb87608df0998b545459b71dff3433776e198","modified":1741357609578},{"_id":"public/2018/10/16/jdk-collection/index.html","hash":"4f93d32664cf236de72c20476c1d60559ee5b8b3","modified":1741357609578},{"_id":"public/2018/03/20/如何克服解决Git冲突的恐惧症？（Git高级话题）/index.html","hash":"5033b46ef71f3bc71d371f5f3ba3041ac97d3e96","modified":1741357609578},{"_id":"public/2018/03/19/如何克服解决Git冲突的恐惧症？（Git杂项）/index.html","hash":"94092006013e3a5a358e1e85bb9b8abd4adea1a8","modified":1741357609578},{"_id":"public/2018/03/18/如何克服解决Git冲突的恐惧症？（Git移交提交记录）/index.html","hash":"2ede2da335d3cae7a1e731692996d96a8cad569e","modified":1741357609578},{"_id":"public/2018/03/15/如何克服解决Git冲突的恐惧症？（Git高级篇）/index.html","hash":"d9ad3beede172863c7a2c22f4ace966ca46d0274","modified":1741357609578},{"_id":"public/2018/03/14/如何克服解决Git冲突的恐惧症？（Git四大组件）/index.html","hash":"b7b5c9ca8ff3a03d2c7e773101855ad2a862f31f","modified":1741357609578},{"_id":"public/2018/03/13/如何克服解决Git冲突的恐惧症？（Git分支策略）/index.html","hash":"72e1a8eef341e4523e7462b74f665f68de4e7893","modified":1741357609578},{"_id":"public/2018/03/11/如何克服解决Git冲突的恐惧症？（Git基础篇-下）/index.html","hash":"ec0d669f85b8f259ce4ca9f6c3f760edf09d8dcc","modified":1741357609578},{"_id":"public/2018/03/07/如何克服解决Git冲突的恐惧症？（Git基础篇-上）/index.html","hash":"760403dd0e30264b38f4e1999a719feca689f62e","modified":1741357609578},{"_id":"public/2018/03/06/如何克服解决Git冲突的恐惧症？（Git入门介绍）/index.html","hash":"b1dfbddb2191843608a6b7ce797df200d0874751","modified":1741357609578},{"_id":"public/2018/03/05/如何克服解决Git冲突的恐惧症？（序）/index.html","hash":"3db41885e76db21dd75c44bde21c6ed34859d17e","modified":1741357609578},{"_id":"public/2018/02/28/java9-http-2-client/index.html","hash":"4d4a93e4726d0064db8956d8b83c33acda61ae78","modified":1741357609578},{"_id":"public/2018/02/27/java9-stream/index.html","hash":"e1fd68685a9b3d50db0b29cdea29e0943a8da287","modified":1741357609578},{"_id":"public/2018/02/25/java9-collection-factory/index.html","hash":"0f8cf7b5c1c481d7914ccc7ecad45e91fce063eb","modified":1741357609578},{"_id":"public/2018/02/24/java9-string/index.html","hash":"90fbb9b3e924dfb7466d89b3c49750fec71f890e","modified":1741357609578},{"_id":"public/2018/02/23/java9-diamond-operator/index.html","hash":"6ea4e8cb8dc71e21b69062e5d19d6d729e236a86","modified":1741357609578},{"_id":"public/2018/02/22/java9-try-with-resources/index.html","hash":"fde1c9a0e4fa3d2e2645b1cbdfc0a74c79353622","modified":1741357609578},{"_id":"public/2018/02/21/java9-interface/index.html","hash":"21340ce52321666343de8333d25cd5c8034ee015","modified":1741357609578},{"_id":"public/2018/02/20/java9-jshell/index.html","hash":"294290064ba3ad357ba2c756ca23c85cf957ddc4","modified":1741357609578},{"_id":"public/2018/02/13/java9-module-spi/index.html","hash":"5b9e82892d2de3b1ad14f49568f24bb24938e662","modified":1741357609578},{"_id":"public/2018/02/10/java9-module-analysis/index.html","hash":"3c30b77c0a0f991187d590bc3bc4b3c2e3e040a5","modified":1741357609578},{"_id":"public/2018/01/31/java9-module-jigsaw-modularity）/index.html","hash":"2f0942c9e676cebc97ea8645d75c8fcdd65b24a3","modified":1741357609578},{"_id":"public/2018/01/30/java9-jdk-jre）/index.html","hash":"3528b9a6a35d11090069ca138141529c662e320e","modified":1741357609578},{"_id":"public/2018/01/29/java9/index.html","hash":"29947e20505c518e5b8cafec5149d560e15f133c","modified":1741357609578},{"_id":"public/2017/12/30/java8-time-date/index.html","hash":"c34d5b1dbacbd778c1daeae5a93244edcf3f07eb","modified":1741357609578},{"_id":"public/2017/12/30/java8-optional/index.html","hash":"8f381e78ab00682dcb7795f5c2320434a446eaba","modified":1741357609578},{"_id":"public/2017/12/30/java8-stream-performance/index.html","hash":"c11d4cd4c356b07cba512e21df35be743f985867","modified":1741357609578},{"_id":"public/2017/12/25/java8-reference/index.html","hash":"5b3a2f2001ab38e5597cb533bb56888561cd56a8","modified":1741357609578},{"_id":"public/2017/12/24/java8-lambda/index.html","hash":"0ec5177c2bf4d63daad968852bd695177a126e42","modified":1741357609578},{"_id":"public/2017/12/21/java8-interface/index.html","hash":"08179bd143c8b58378086e9c6ecbf24c33c20b9c","modified":1741357609578},{"_id":"public/2017/12/20/java8/index.html","hash":"48da6ffaf62846673dd7741960526cd2ad2492e2","modified":1741357609578},{"_id":"public/2017/08/14/Spring-Test-Junit单元测试/index.html","hash":"32343cdfe5a6493de46f568acdf62eadf58ee68c","modified":1741357609578},{"_id":"public/2017/08/03/Mac-OS安装软件时提示-“安装”已损坏，打不开-你应该推出磁盘映像的解决方法/index.html","hash":"4ccf6fd29e858426b7afb42730e9a0383f11f74d","modified":1741357609578},{"_id":"public/2017/07/31/BUG：无法确定T的类型参数/index.html","hash":"b4f54debe0f7850228dbefa40ab5c5f1884853d2","modified":1741357609578},{"_id":"public/2016/08/29/docker命令学习（一）/index.html","hash":"efe6de1360b10046583ecdcc8af33ed948e19f03","modified":1741357609578},{"_id":"public/2015/11/05/微信公众号企业付款/index.html","hash":"edf93236cd238c148f608a5181961398e9cf494b","modified":1741357609578},{"_id":"public/2015/11/03/微信公众号发红包实现/index.html","hash":"219fc52146bce9328693859f41b4cf344c68643d","modified":1741357609578},{"_id":"public/2015/10/31/Java学习路线/index.html","hash":"b3b6a76c626fc0251b973d6e3cff5cde968195d4","modified":1741357609578},{"_id":"public/2015/05/11/Flask-SAE搭建微信后台初探/index.html","hash":"19eccc8972cea25cf778f772de9384fe2d0c64aa","modified":1741357609578},{"_id":"public/2015/05/09/微信公众号调用access-token接口频率限制解决-Java/index.html","hash":"fc2b7a76451b57243c82f85ec3ad303a2d282a4b","modified":1741357609578},{"_id":"public/2015/05/07/hello-world/index.html","hash":"5ef673ebed7dcde4eef9eea1ceb1aa761f15fc60","modified":1741357609578},{"_id":"public/archives/2015/index.html","hash":"66aa07a3ed0fef026d6dddc986b3c2692be79d08","modified":1741357609578},{"_id":"public/archives/2015/05/index.html","hash":"06779b37cac45a82888238ee986bd99703385cda","modified":1741357609578},{"_id":"public/archives/2015/10/index.html","hash":"30a3b7489c287306498f626069800db98954f57e","modified":1741357609578},{"_id":"public/archives/2015/11/index.html","hash":"9003d08468927145fa6f8c9bf87f85796a6790d8","modified":1741357609578},{"_id":"public/archives/2016/index.html","hash":"b4e3bc7ac44852202773930b324d13c3b4151866","modified":1741357609578},{"_id":"public/archives/2016/08/index.html","hash":"b4e3bc7ac44852202773930b324d13c3b4151866","modified":1741357609578},{"_id":"public/archives/2017/index.html","hash":"5ca214796bd788822886d048386459dcef5eb8c4","modified":1741357609578},{"_id":"public/archives/2017/07/index.html","hash":"f6a4644b7d7188fda1728057cc130ed631ccfd7e","modified":1741357609578},{"_id":"public/archives/2017/08/index.html","hash":"bf5c1b21e3051701bb010d2e4c37108cc53f8c7c","modified":1741357609578},{"_id":"public/archives/2017/12/index.html","hash":"91523cdfa6e6c838ee7d7e8b9c2adeee0e66aceb","modified":1741357609578},{"_id":"public/archives/2018/index.html","hash":"0eb8f8667e0aab6727c48e225302c58aaa7e4594","modified":1741357609578},{"_id":"public/archives/2018/01/index.html","hash":"f51ecc81d9c8de1dee2c448211984fbb2a3ab378","modified":1741357609578},{"_id":"public/archives/2018/02/index.html","hash":"12715cb37c2ca5ecf047376f4a17c24bf8f64bf5","modified":1741357609578},{"_id":"public/archives/2018/03/index.html","hash":"eee9411299cdf9666759d5e8b301705bcacc3c89","modified":1741357609578},{"_id":"public/archives/2018/10/index.html","hash":"abd74d1dbaf9b9f94cda75545f8939892c1effd1","modified":1741357609578},{"_id":"public/categories/疑难杂症/index.html","hash":"e4d9e24071d61606641f3c5a0fbfb7d6125a57e0","modified":1741357609578},{"_id":"public/categories/Mac/index.html","hash":"12a1b5b96b39dbae6f10ad3957382b4eb25e6683","modified":1741357609578},{"_id":"public/categories/Java/index.html","hash":"f0792aca16226a1d4b448d2d8883e5e9ab937462","modified":1741357609578},{"_id":"public/categories/JDK集合/index.html","hash":"4d465de43897b565c2a478a85ea9aac3bc1489bb","modified":1741357609578},{"_id":"public/categories/Git/index.html","hash":"eee9411299cdf9666759d5e8b301705bcacc3c89","modified":1741357609578},{"_id":"public/tags/Flask/index.html","hash":"92691c50ddff5e140879b105865d9c3c5b1a27b6","modified":1741357609578},{"_id":"public/tags/Python/index.html","hash":"92691c50ddff5e140879b105865d9c3c5b1a27b6","modified":1741357609578},{"_id":"public/tags/微信公众平台开发/index.html","hash":"7c39f49dc8ee6ea8a9504bf0fb6255f79e0f112a","modified":1741357609578},{"_id":"public/tags/Mac/index.html","hash":"12a1b5b96b39dbae6f10ad3957382b4eb25e6683","modified":1741357609578},{"_id":"public/tags/单元测试/index.html","hash":"3ad7886f17f16200235da9418ae77b59d3d33812","modified":1741357609578},{"_id":"public/tags/心路札记/index.html","hash":"910afc99edae841f2ff1c82e9c70629f4acedba5","modified":1741357609578},{"_id":"public/tags/docker/index.html","hash":"b4e3bc7ac44852202773930b324d13c3b4151866","modified":1741357609578},{"_id":"public/tags/Java8新特性/index.html","hash":"5ddaf5c2d26ba8273a829da0e9acd86556bdbeb4","modified":1741357609578},{"_id":"public/tags/Java9新特性/index.html","hash":"d62ecf849b6bb7f55b808ae91b90fd180c7d7c61","modified":1741357609578},{"_id":"public/tags/JDK集合/index.html","hash":"4d465de43897b565c2a478a85ea9aac3bc1489bb","modified":1741357609578},{"_id":"public/tags/Git/index.html","hash":"eee9411299cdf9666759d5e8b301705bcacc3c89","modified":1741357609578},{"_id":"public/tags/SpringMVC/index.html","hash":"94422164673d859ba461f5be72a8a1486e5bf7da","modified":1741357609578},{"_id":"public/tags/阿里Java开发手册/index.html","hash":"71a10fcfe857828b2e252e11722fc1559c4b89fb","modified":1741357609578},{"_id":"public/2018/02/11/java9-module-maven-starter/index.html","hash":"7f9c431c9f015f8a56d11f6f0c271b563640478a","modified":1741357609578},{"_id":"public/2018/01/03/java8-atomic-operation/index.html","hash":"439887bb565359d052bce38fc87a07f5f55e9a63","modified":1741357609578},{"_id":"public/2017/12/28/java8-stream/index.html","hash":"c7e32bc8b7b72a414f8f81a9a73a41f48f4b38f4","modified":1741357609578},{"_id":"public/2017/12/17/阿里Java开发手册思考（五）/index.html","hash":"528724c0509d24eb3347842bd8f37dbebc2569f8","modified":1741357609578},{"_id":"public/2017/12/11/阿里Java开发手册思考（四）/index.html","hash":"e67da46acea47d728fad89c9ab5b67f35189ab7b","modified":1741357609578},{"_id":"public/2017/12/09/阿里Java开发手册思考（三）/index.html","hash":"448b6648ad253cb9b63750fdcd276cd92fa349e6","modified":1741357609578},{"_id":"public/2017/12/06/阿里Java开发手册思考（二）/index.html","hash":"7925fd64da560938057e729a297d9859f35a1137","modified":1741357609578},{"_id":"public/2017/12/04/阿里Java开发手册思考（一）/index.html","hash":"b182672b51cf160b3daf364cfdf2a2d3213833d5","modified":1741357609578},{"_id":"public/2017/08/03/Java文件上传分析/index.html","hash":"f3a4b600479376aae81e44590b74ac8539d48d22","modified":1741357609578},{"_id":"public/2017/08/01/BUG：Restlet流式读取远端文件内容时inputstream未关闭/index.html","hash":"ee10ed75ddee0327af240008998c91081f69fd1e","modified":1741357609578},{"_id":"public/2015/05/09/微信支付V3-x实现-Java后台/index.html","hash":"1621c740ab3f4aed7679d04378e9cec5b8a9f82a","modified":1741357609578},{"_id":"public/archives/index.html","hash":"c39e3469dbce719f56278b1c1b92551f58bdf183","modified":1741357609578},{"_id":"public/index.html","hash":"c39e3469dbce719f56278b1c1b92551f58bdf183","modified":1741357609578},{"_id":"public/tags/Java/index.html","hash":"db1c4fe8b01ff57c2cc84f3b740645822275b9c6","modified":1741357609578},{"_id":"public/CNAME","hash":"1847b8316b9097d5c196713902916ecbd62d50b6","modified":1741357609578},{"_id":"public/favicon.ico","hash":"8585da4c971c97523cc8c599110ed9a7e074241c","modified":1741357609578},{"_id":"public/libs/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1741357609578},{"_id":"public/libs/font-awesome/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1741357609578},{"_id":"public/libs/font-awesome/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1741357609578},{"_id":"public/libs/font-awesome/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1741357609578},{"_id":"public/libs/font-awesome/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1741357609578},{"_id":"public/libs/font-awesome/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1741357609578},{"_id":"public/libs/font-awesome/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1741357609578},{"_id":"public/libs/font-awesome/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1741357609578},{"_id":"public/libs/font-awesome/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1741357609578},{"_id":"public/libs/font-awesome/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1741357609578},{"_id":"public/libs/font-awesome/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1741357609578},{"_id":"public/libs/font-awesome/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1741357609578},{"_id":"public/libs/font-awesome/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1741357609578},{"_id":"public/libs/font-awesome/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1741357609578},{"_id":"public/libs/font-awesome/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1741357609578},{"_id":"public/libs/font-awesome/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1741357609578},{"_id":"public/libs/highlight/styles/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1741357609578},{"_id":"public/libs/highlight/styles/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1741357609578},{"_id":"public/libs/highlight/styles/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1741357609578},{"_id":"public/2018/10/16/jdk-collection/jdk-collection.png","hash":"b9116bbb2d21b471bd693d79416039a4bc7c8df3","modified":1741357609578},{"_id":"public/img/logo.png","hash":"f8e2caa981a79889fa58be8b8277ad6854caf447","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1741357609578},{"_id":"public/js/js.js","hash":"0fb795dc0d1c2da9bee007a73fe246a03c88626b","modified":1741357609578},{"_id":"public/libs/highlight/styles/a11y-dark.css","hash":"122f8c71ac1c35398e96bf209f20668195a9e144","modified":1741357609578},{"_id":"public/libs/highlight/styles/a11y-light.css","hash":"3f5cde8e2278a6d52e6e4f30509588c80a3ad5a6","modified":1741357609578},{"_id":"public/libs/highlight/styles/agate.css","hash":"8e122b0f00f5a7ec4e6dc492bf1560441eeef7f0","modified":1741357609578},{"_id":"public/libs/highlight/styles/an-old-hope.css","hash":"124d4856bbd6e2cfc164914080724f1a59b9899c","modified":1741357609578},{"_id":"public/libs/highlight/styles/androidstudio.css","hash":"958baa24814c06a625612a3b2b478d54bc1bf1b1","modified":1741357609578},{"_id":"public/libs/highlight/styles/arduino-light.css","hash":"141b53b2e2de6a321a695d816a836666c5e2c5e6","modified":1741357609578},{"_id":"public/libs/highlight/styles/ascetic.css","hash":"6358377b5c25667886aca0d605cbc497cf02405f","modified":1741357609578},{"_id":"public/libs/highlight/styles/arta.css","hash":"17b23b9fa57ef7a05a6aaeea9b5feb5442a8e584","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-cave-light.css","hash":"2933f0247ac6d84c2954dd4946e359853abbf70a","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-dune-dark.css","hash":"081d73e454db140cd41b2bb595be297cfcab25e0","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-dune-light.css","hash":"7ba074de897e6a5e27d8b97f7cd06c1746474e72","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-estuary-dark.css","hash":"a0c46a0f955e3864f5e967ea93f5e61519a17be8","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-estuary-light.css","hash":"91ae4668c15a085ffce15ca21e93da445b5ecf3a","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-forest-light.css","hash":"8a78a4eea0f32d094d1f9e316d59e990ba739d97","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-forest-dark.css","hash":"d8a4dc060b3fc719aa2f7d7b3f1019a3964b8101","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-lakeside-dark.css","hash":"fa707b252d5d5caccc0589374522bed47b7ca100","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-heath-dark.css","hash":"b93c2241ff123e62d4edb3dfc20410e4d1da3e78","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-heath-light.css","hash":"172b98f783d213a20211ec6aca9a3840ba524f55","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-lakeside-light.css","hash":"8ba595b9ba6e8be6dc029bf80caab38e85aed686","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-plateau-dark.css","hash":"240f79f4e1fd63485c13900875b64c5a0d1bd06d","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-plateau-light.css","hash":"9731db1052f23351c983210701edd3f5ceed343f","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-savanna-dark.css","hash":"09d45a218f87b8cb55b5ca7f4e9d76ea89a9404a","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-seaside-dark.css","hash":"b2800804a21f729a3d0a16b3aadc17679fd0639c","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-savanna-light.css","hash":"6bd3a62c32558476d436bd389500e5fbeb693d67","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-sulphurpool-dark.css","hash":"1f006f8bd28e2ffbb73f708769605ba766787fff","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-seaside-light.css","hash":"3e6b9e2a3a5de455490b8224401f19702df4cde9","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-sulphurpool-light.css","hash":"0319c3eea893601b79b6c57652ef49b9222cc9de","modified":1741357609578},{"_id":"public/libs/highlight/styles/atom-one-dark-reasonable.css","hash":"90e194ba1c1fe2ca1b5f40b5eb7c29f40ab66ff4","modified":1741357609578},{"_id":"public/libs/highlight/styles/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1741357609578},{"_id":"public/libs/highlight/styles/atom-one-light.css","hash":"eda63d8cce440dbf3bb823e10577a134e9941deb","modified":1741357609578},{"_id":"public/libs/highlight/styles/brown-paper.css","hash":"a6817d890e58f80ce79d87620791dae821a70fff","modified":1741357609578},{"_id":"public/libs/highlight/styles/codepen-embed.css","hash":"c4520e45d18259817b8942d17971f27c94f0fb09","modified":1741357609578},{"_id":"public/libs/highlight/styles/color-brewer.css","hash":"96332573db854e7b7411caa94ba29b238fede2d3","modified":1741357609578},{"_id":"public/libs/highlight/styles/atelier-cave-dark.css","hash":"f397d4418ce88b998841fd9135242461ba1a79b5","modified":1741357609578},{"_id":"public/libs/highlight/styles/darcula.css","hash":"617241bc95a5dbbd741820bf296155b90e22d61b","modified":1741357609578},{"_id":"public/libs/highlight/styles/darkula.css","hash":"0be948bb84acc05f93a1e5e9b48fe34cf61673a0","modified":1741357609578},{"_id":"public/libs/highlight/styles/default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1741357609578},{"_id":"public/libs/highlight/styles/docco.css","hash":"1be7be09a1b927c22c7f11451becdb335145bdd2","modified":1741357609578},{"_id":"public/libs/highlight/styles/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1741357609578},{"_id":"public/libs/highlight/styles/dark.css","hash":"fc77519d4f5d731054c5d4b7e7bbdbb510833271","modified":1741357609578},{"_id":"public/libs/highlight/styles/far.css","hash":"67e0658b2376e91e4894636a3522a30c2aec42de","modified":1741357609578},{"_id":"public/libs/highlight/styles/foundation.css","hash":"29d960268ca944b5537ff2d2e70d620339dcd5d5","modified":1741357609578},{"_id":"public/libs/highlight/styles/github.css","hash":"ee593952684a791317ee8b77ad096e729dec649e","modified":1741357609578},{"_id":"public/libs/highlight/styles/gml.css","hash":"0f3f5502247b00ce37dc2b362a6984305001dd50","modified":1741357609578},{"_id":"public/libs/highlight/styles/googlecode.css","hash":"fed3d439d0c305b337dd9c0f68dcbfa51429f445","modified":1741357609578},{"_id":"public/libs/highlight/styles/gradient-dark.css","hash":"e49b73bab4446ec2dbc0befb860a1fdc27bf1b42","modified":1741357609578},{"_id":"public/libs/highlight/styles/grayscale.css","hash":"5688658c28fc5799517e8f3c224ae3da3797ba44","modified":1741357609578},{"_id":"public/libs/highlight/styles/gruvbox-dark.css","hash":"aaf90d076e34bc44016462d70f83985e0e55c8dc","modified":1741357609578},{"_id":"public/libs/highlight/styles/gruvbox-light.css","hash":"084699ab0aa326fede86e38bf41ebe49edde3a90","modified":1741357609578},{"_id":"public/libs/highlight/styles/hopscotch.css","hash":"3d258ff6f84900ad9abbe43f4ec8b8152c72e887","modified":1741357609578},{"_id":"public/libs/highlight/styles/idea.css","hash":"164649ae1e7c891a0d88cca075521af28656e2a1","modified":1741357609578},{"_id":"public/libs/highlight/styles/hybrid.css","hash":"1e2d54598b5f948b597059909d4bd158b7df021f","modified":1741357609578},{"_id":"public/libs/highlight/styles/ir-black.css","hash":"95aad65ba77183500ce0f7ad62a7535b647ee20c","modified":1741357609578},{"_id":"public/libs/highlight/styles/isbl-editor-dark.css","hash":"73d2282192e403868998cff2e77093ace8a6e5fb","modified":1741357609578},{"_id":"public/libs/highlight/styles/isbl-editor-light.css","hash":"41baadd11cf10bab67128dd104f704fdd149318e","modified":1741357609578},{"_id":"public/libs/highlight/styles/kimbie.dark.css","hash":"58ed061c204fbc09d221ee9135d66bad976e5fc3","modified":1741357609578},{"_id":"public/libs/highlight/styles/kimbie.light.css","hash":"b7aa9b1b21a25dfefcac7649a328962f84c47913","modified":1741357609578},{"_id":"public/libs/highlight/styles/lightfair.css","hash":"3bdc4517354b7acc495562d8b4937c7a40a89f06","modified":1741357609578},{"_id":"public/libs/highlight/styles/mono-blue.css","hash":"3163f08756efa9e68e87addf20750e5650cdb8e4","modified":1741357609578},{"_id":"public/libs/highlight/styles/magula.css","hash":"8f5cfb7c23c705de7c95577563eb79beb49b68f6","modified":1741357609578},{"_id":"public/libs/highlight/styles/monokai-sublime.css","hash":"e4f3df87cbfa634c86b489e9cc43acf44d415986","modified":1741357609578},{"_id":"public/libs/highlight/styles/monokai.css","hash":"99ab7678d541bc02a8d38de83a289c5e549a20ce","modified":1741357609578},{"_id":"public/libs/highlight/styles/github-gist.css","hash":"8cfbcbf4c0491e44e6b073c95a04cc401cb11ab2","modified":1741357609578},{"_id":"public/libs/highlight/styles/night-owl.css","hash":"d067142aeb74bfdcdec4acebb3241b3e79461bda","modified":1741357609578},{"_id":"public/libs/highlight/styles/nord.css","hash":"98dfcd6eee4968fb4c634784cb048a98169b1bc8","modified":1741357609578},{"_id":"public/libs/highlight/styles/obsidian.css","hash":"6ed475813fe4886a58b236297862ff2f181e66f7","modified":1741357609578},{"_id":"public/libs/highlight/styles/ocean.css","hash":"fce6858e1c5eb9d2857cb5b5d24069c5994cfc91","modified":1741357609578},{"_id":"public/libs/highlight/styles/paraiso-dark.css","hash":"8f5445327ce3c83b62f6bf4c1a0d87fa6f036341","modified":1741357609578},{"_id":"public/libs/highlight/styles/paraiso-light.css","hash":"6eb3ab7a3337f9cad3a2e5fa6bf7dd83685228d8","modified":1741357609578},{"_id":"public/libs/highlight/styles/pojoaque.css","hash":"4e1e6a431212f5043a550474a1acda63362cdd6f","modified":1741357609578},{"_id":"public/libs/highlight/styles/purebasic.css","hash":"e6bb7a57221bed7a601dc9d8d41d9b1425e2dea6","modified":1741357609578},{"_id":"public/libs/highlight/styles/qtcreator_dark.css","hash":"213a40d203c4986cdbcb1bdf7d0b9013b29041ba","modified":1741357609578},{"_id":"public/libs/highlight/styles/qtcreator_light.css","hash":"9a2a19ac2f6e6a7d5edd7fae67b7de4a3957e878","modified":1741357609578},{"_id":"public/libs/highlight/styles/railscasts.css","hash":"a6d2043478fae5915926914cbd96fe9b706d98a6","modified":1741357609578},{"_id":"public/libs/highlight/styles/rainbow.css","hash":"1b2d98ccdda36aa926d0e6d069b673fdacd2d33e","modified":1741357609578},{"_id":"public/libs/highlight/styles/routeros.css","hash":"fc5db7c8f18d6b31ad92df21a51e7867d459af19","modified":1741357609578},{"_id":"public/libs/highlight/styles/school-book.css","hash":"6c4198b6ffde866f5e2fe9172aee094065f9774a","modified":1741357609578},{"_id":"public/libs/highlight/styles/shades-of-purple.css","hash":"4d5b44a1615173d02b223ba2cce220ab70e09650","modified":1741357609578},{"_id":"public/css/style.css","hash":"5aa83728a6eb1c08e990c43e99582a88d4ba3b17","modified":1741357609578},{"_id":"public/libs/highlight/styles/solarized-dark.css","hash":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1741357609578},{"_id":"public/libs/highlight/styles/solarized-light.css","hash":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1741357609578},{"_id":"public/libs/highlight/styles/sunburst.css","hash":"8309eab2e5b1765dbee81a626baacbdad869b76a","modified":1741357609578},{"_id":"public/libs/highlight/styles/tomorrow-night-blue.css","hash":"cd257d7d6a37cd5a09419b5f5f9d34b6b282423f","modified":1741357609578},{"_id":"public/libs/highlight/styles/tomorrow-night-bright.css","hash":"04f0af30fdda5e5d6ebdeef5a860b6b7e49cfe89","modified":1741357609578},{"_id":"public/libs/highlight/styles/tomorrow-night-eighties.css","hash":"d82b84bcda0588105dbbc0e8e8ba5e62c208a061","modified":1741357609578},{"_id":"public/libs/highlight/styles/tomorrow.css","hash":"163593ad70770d0296c5e643fa62e58e63f1b340","modified":1741357609578},{"_id":"public/libs/highlight/styles/tomorrow-night.css","hash":"86264dd861d35a8b135f9fcb8ff2675e9fa69c16","modified":1741357609578},{"_id":"public/libs/highlight/styles/vs.css","hash":"2ac5e89ceb3d5a0e0fdab1ed6d9a411ec7d221aa","modified":1741357609578},{"_id":"public/libs/highlight/styles/vs2015.css","hash":"3c7fa677de2a785d90fc6c3f7520ac1b11bfd37a","modified":1741357609578},{"_id":"public/libs/highlight/styles/xcode.css","hash":"d8a1f18e5344c2edf97921ec21a54b02745997e9","modified":1741357609578},{"_id":"public/libs/highlight/styles/xt256.css","hash":"d9e0f7d8ab5cfd627ce085c16e7a90e1ad495516","modified":1741357609578},{"_id":"public/libs/highlight/styles/zenburn.css","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1741357609578},{"_id":"public/libs/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1741357609578},{"_id":"public/libs/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1741357609578},{"_id":"public/libs/highlight/highlight.pack.js","hash":"e5a87508b4ce2f7e00c8f792251a0837879a6311","modified":1741357609578},{"_id":"public/libs/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1741357609578},{"_id":"public/libs/jquery.min.js","hash":"37b1db88b57438f1072a8ebc7559c909c9d3a682","modified":1741357609578}],"Category":[{"name":"疑难杂症","_id":"cm7yvcz230004rz5md6xfa5cd"},{"name":"Mac","_id":"cm7yvcz29000irz5mb0n82zix"},{"name":"Java","_id":"cm7yvcz2b000qrz5m2vkc82me"},{"name":"JDK集合","_id":"cm7yvcz2u002urz5m1u5jcdzc"},{"name":"Git","_id":"cm7yvcz2v0034rz5m37602y35"}],"Data":[],"Page":[{"title":"标签","date":"2017-12-10T08:53:03.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"title: 标签\ndate: 2017-12-10 16:53:03\ntype: \"tags\"\n---\n","updated":"2025-03-07T13:26:47.263Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cm7yvcz1v0000rz5m94fc6xut","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-12-10T08:59:56.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"title: 分类\ndate: 2017-12-10 16:59:56\ntype: \"categories\"\n---\n","updated":"2025-03-07T13:26:47.262Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm7yvcz200002rz5mfirh73xj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2017-07-24T16:14:33.000Z","_content":">插科打诨于前端，后端，产品工程师之间。\n在现实中分层抽象，在Bug的坟头上蹦迪。\n常于Github海岸边拾捡贝壳，沾沾自喜。\n用Java可倚天屠龙，用Shell则庖丁解牛。\n常修程序员之道，常读Man文档。\n\n简书：http://www.jianshu.com/u/f66899a37408\n邮箱：18013963220@163.com\n微信：spp696683\n微信公众号：码上论剑\n","source":"about/index.md","raw":"title: 关于\ndate: 2017-07-25 00:14:33\n---\n>插科打诨于前端，后端，产品工程师之间。\n在现实中分层抽象，在Bug的坟头上蹦迪。\n常于Github海岸边拾捡贝壳，沾沾自喜。\n用Java可倚天屠龙，用Shell则庖丁解牛。\n常修程序员之道，常读Man文档。\n\n简书：http://www.jianshu.com/u/f66899a37408\n邮箱：18013963220@163.com\n微信：spp696683\n微信公众号：码上论剑\n","updated":"2025-03-07T13:26:47.262Z","path":"about/index.html","comments":1,"layout":"page","_id":"cm7yvcz250006rz5ma1a917gv","content":"<blockquote>\n<p>插科打诨于前端，后端，产品工程师之间。<br>在现实中分层抽象，在Bug的坟头上蹦迪。<br>常于Github海岸边拾捡贝壳，沾沾自喜。<br>用Java可倚天屠龙，用Shell则庖丁解牛。<br>常修程序员之道，常读Man文档。</p>\n</blockquote>\n<p>简书：<a href=\"http://www.jianshu.com/u/f66899a37408\">http://www.jianshu.com/u/f66899a37408</a><br>邮箱：<a href=\"mailto:&#49;&#x38;&#x30;&#49;&#x33;&#57;&#54;&#x33;&#x32;&#50;&#48;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;\">&#49;&#x38;&#x30;&#49;&#x33;&#57;&#54;&#x33;&#x32;&#50;&#48;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a><br>微信：spp696683<br>微信公众号：码上论剑</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>插科打诨于前端，后端，产品工程师之间。<br>在现实中分层抽象，在Bug的坟头上蹦迪。<br>常于Github海岸边拾捡贝壳，沾沾自喜。<br>用Java可倚天屠龙，用Shell则庖丁解牛。<br>常修程序员之道，常读Man文档。</p>\n</blockquote>\n<p>简书：<a href=\"http://www.jianshu.com/u/f66899a37408\">http://www.jianshu.com/u/f66899a37408</a><br>邮箱：<a href=\"mailto:&#49;&#x38;&#x30;&#49;&#x33;&#57;&#54;&#x33;&#x32;&#50;&#48;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;\">&#49;&#x38;&#x30;&#49;&#x33;&#57;&#54;&#x33;&#x32;&#50;&#48;&#x40;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#x6d;</a><br>微信：spp696683<br>微信公众号：码上论剑</p>\n"}],"Post":[{"title":"BUG：Restlet流式读取远端文件内容时inputstream未关闭","date":"2017-07-31T16:25:10.000Z","type":"tags","_content":"利用Restlet流式读取远端文件时，如果没有手动将inputstream关闭，那么InputRepresentation会自动将inputstream关闭吗？\n<!--more-->\nRestlet 服务端接收rest请求后，读取文件，将文件转为流，代码如下：\n```java\npublic class XXResource extends ServerResource\n{\n    @Get\n    public InputRepresentation readFile() throws FileNotFoundException\n    {\n        File file = new File(\"/root/test.txt\" );\n        InputStream inputStream = new FileInputStream(file);\n        InputRepresentation inputRepresentation = new InputRepresentation(\n                inputStream);\n        return inputRepresentation;\n    }\n}\n```\n我们都知道，将文件转为流，在使用结束后需要将流关闭，否则IO资源就会被一直占着，其他方法没法使用，造成资源浪费\n进一步考虑，如果此处不需要关闭流，那么在InputRePresentation中应该会把流释放，那么有没有释放呢，我们看InputRepresentation源码：\n```java\npublic void release()\n{\n    if(this.stream != null)\n    {\n        try\n        {\n            this.stream.close();\n        } catch (IOException var2) \n        {\n            Context.getCurrentLogger().log(Level.WARNING, \"Error while releasing the representation.\", var2);\n        }\n        this.stream = null;\n    }\n    super.release();\n}\n```\n可以看到，此方法为public公用方法，没有地方调用，难道需要手动调用InputRePresentation的release()方法？\n看了下StackOverFlow上这个[问答](https://stackoverflow.com/questions/22658056/restlet-not-closing-inputrepresentation-streams)，说的是这个确实是个问题，更新了新版本之后还是没有看到在哪儿调用release()方法，结果回答的人又让手动调用release()方法，这。。\n\n看了下这篇[讨论](http://restlet-discuss.1400322.n2.nabble.com/PROBLEM-WITH-org-restlet-representation-InputRepresentation-IN-1-2-M2-td3055389.html)，明天换个新版本试试～\n\n##continue\n今天下载了restlet2.3.9的源码（Maven工程）：\n```xml\n<repositories>\n    <repository>\n        <id>maven-restlet</id>\n        <name>Public online Restlet repository</name>\n        <url>http://maven.restlet.org</url>\n    </repository>\n</repositories>\n<dependencies>\n\t<dependency>\n        <groupId>org.restlet.jee</groupId>\n        <artifactId>org.restlet</artifactId>\n        <version>2.3.9</version>\n    </dependency>\n</dependencies>\n```\n通过从InputRePresentation逐层往父类查找，在RepresentationInfo中找到release()方法的解释：\n```java\n/**\n * Releases the representation and all associated objects like streams,\n * channels or files which are used to produce its content, transient or\n * not. This method must be systematically called when the representation is\n * no longer intended to be used. The framework automatically calls back\n * this method via its connectors on the server-side when sending responses\n * with an entity and on the client-side when sending a request with an\n * entity. By default, it calls the {@link #setAvailable(boolean)} method\n * with \"false\" as a value.<br>\n * <br>\n * Note that for transient socket-bound representations, calling this method\n * after consuming the whole content shouldn't prevent the reuse of\n * underlying socket via persistent connections for example. However, if the\n * content hasn't been read, or has been partially read, the impact should\n * be to discard the remaining content and to close the underlying\n * connections.<br>\n * <br>\n * Therefore, if you are not interested in the content, or in the remaining\n * content, you should first call the {@link #exhaust()} method or if this\n * could be too costly, you should instead explicitly abort the parent\n * request and the underlying connections using the {@link Request#abort()}\n * method or a shortcut one like\n * {@link org.restlet.resource.ServerResource#abort()} or\n * {@link Response#abort()}.\n */\n public void release() {\n    setAvailable(false);\n }\n```\n查看此方法被引用的地方，其中最重要的一处为ServerCall类的sendResponse方法：\n```java\n/**\n * Sends the response back to the client. Commits the status, headers and\n * optional entity and send them over the network. The default\n * implementation only writes the response entity on the response stream or\n * channel. Subclasses will probably also copy the response headers and\n * status.\n * \n * @param response\n *            The high-level response.\n * @throws IOException\n *             if the Response could not be written to the network.\n */\n public void sendResponse(Response response) throws IOException {\n    if (response != null) {\n        // Get the connector service to callback\n        Representation responseEntity = response.getEntity();\n        ConnectorService connectorService = ConnectorHelper\n                    .getConnectorService();\n\n        if (connectorService != null) {\n            connectorService.beforeSend(responseEntity);\n        }\n        OutputStream responseEntityStream = null;\n        try {\n            writeResponseHead(response);\n            if (responseEntity != null) {\n                responseEntityStream = getResponseEntityStream();\n                writeResponseBody(responseEntity, responseEntityStream);\n            }\n        } finally {\n            if (responseEntityStream != null) {\n                try {\n                    responseEntityStream.flush();\n                    responseEntityStream.close();\n                } catch (IOException ioe) {\n                    // The stream was probably already closed by the\n                    // connector. Probably OK, low message priority.\n                    getLogger().log(Level.FINE,\n                                        \"Exception while flushing and closing the entity stream.\",\n                                        ioe);\n                }\n            }\n            if (responseEntity != null) {\n                responseEntity.release();\n            }\n            if (connectorService != null) {\n                connectorService.afterSend(responseEntity);\n            }\n        }\n    }\n }\n```\n##拨开云雾见天日 守得云开见月明\n通过分析，在服务端返回消息给客户端时，会将Representation进行release()，那么InputStream也会释放～\n\n进一步联想：无论是struts／spring或者其他框架，其实都是基于servlet，那么servlet中的流是如何关闭的呢？\n\n有人说：在Servlet中，因为filter的关系，很多时候需要把response里面的内容拿出来，进行过滤，比如编码上的问题，如果你在自己的response里面getWriter().close()掉，其他的filter会出现异常。Servlet最后会帮你关闭的，放心。如果自己用PrintWriter的话，还是得关闭。\n\n有人说：servlet生命周期，用户可以在doGet或doPost中自己关闭输出流；也可以在destory中关闭释放；如果还没有做操作，destory，后会释放servlet实例，自然释放了servlet占用的所有资源。\n\n其实，一个filter、servlet只有一个实例来处理所有请求，`最基础的知识`,`servlet实例中压根没有request、response`，destory想释放估计心有余而力不足，也不要指望在destory里关闭response，他压根不是干这个用的\n\n查看tomcat的源码可以发现，resoponse如果没有关闭，tomcat会自动关闭，org.apache.catalina.core.ApplicationDispatcher.doForward(ServletRequest request, ServletResponse response)方法，最后一段代码是：\n```java\n// Close anyway\ntry {\n    PrintWriter writer = response.getWriter();\n    writer.close();\n} catch (IllegalStateException e) {\n    try {\n        ServletOutputStream stream = response.getOutputStream();\n        stream.close();\n    } catch (IllegalStateException f) {\n        // Ignore\n    } catch (IOException f) {\n        // Ignore\n    }\n} catch (IOException e) {\n    // Ignore\n}\n```\n可以清楚看到不管你有没有关闭，tomcat都重新关闭了一次\n\n所以说，javax.servlet是一种标准，是给人实现的。\n\nresponse应该是由Connector类实现的。对外是(javax.servlet.response) response 把方法限定在javax.servlet.response范围。\n\n所以你想要看实现。\n我是看的是tomcat4.1.2(深入剖析tomcat这本书是用这个的。)\norg.apache.catalina.connector.http.HttpProcessor  response.finishResponse();\n\n好了，就到此为止了，通过此次分析颇有感触，要真正弄懂底层原理才能更好的运用自如！","source":"_posts/BUG：Restlet流式读取远端文件内容时inputstream未关闭.md","raw":"title: BUG：Restlet流式读取远端文件内容时inputstream未关闭\ndate: 2017-08-01 00:25:10\ntype: \"tags\"\ntags:\n- Java\ncategories: 疑难杂症\n---\n利用Restlet流式读取远端文件时，如果没有手动将inputstream关闭，那么InputRepresentation会自动将inputstream关闭吗？\n<!--more-->\nRestlet 服务端接收rest请求后，读取文件，将文件转为流，代码如下：\n```java\npublic class XXResource extends ServerResource\n{\n    @Get\n    public InputRepresentation readFile() throws FileNotFoundException\n    {\n        File file = new File(\"/root/test.txt\" );\n        InputStream inputStream = new FileInputStream(file);\n        InputRepresentation inputRepresentation = new InputRepresentation(\n                inputStream);\n        return inputRepresentation;\n    }\n}\n```\n我们都知道，将文件转为流，在使用结束后需要将流关闭，否则IO资源就会被一直占着，其他方法没法使用，造成资源浪费\n进一步考虑，如果此处不需要关闭流，那么在InputRePresentation中应该会把流释放，那么有没有释放呢，我们看InputRepresentation源码：\n```java\npublic void release()\n{\n    if(this.stream != null)\n    {\n        try\n        {\n            this.stream.close();\n        } catch (IOException var2) \n        {\n            Context.getCurrentLogger().log(Level.WARNING, \"Error while releasing the representation.\", var2);\n        }\n        this.stream = null;\n    }\n    super.release();\n}\n```\n可以看到，此方法为public公用方法，没有地方调用，难道需要手动调用InputRePresentation的release()方法？\n看了下StackOverFlow上这个[问答](https://stackoverflow.com/questions/22658056/restlet-not-closing-inputrepresentation-streams)，说的是这个确实是个问题，更新了新版本之后还是没有看到在哪儿调用release()方法，结果回答的人又让手动调用release()方法，这。。\n\n看了下这篇[讨论](http://restlet-discuss.1400322.n2.nabble.com/PROBLEM-WITH-org-restlet-representation-InputRepresentation-IN-1-2-M2-td3055389.html)，明天换个新版本试试～\n\n##continue\n今天下载了restlet2.3.9的源码（Maven工程）：\n```xml\n<repositories>\n    <repository>\n        <id>maven-restlet</id>\n        <name>Public online Restlet repository</name>\n        <url>http://maven.restlet.org</url>\n    </repository>\n</repositories>\n<dependencies>\n\t<dependency>\n        <groupId>org.restlet.jee</groupId>\n        <artifactId>org.restlet</artifactId>\n        <version>2.3.9</version>\n    </dependency>\n</dependencies>\n```\n通过从InputRePresentation逐层往父类查找，在RepresentationInfo中找到release()方法的解释：\n```java\n/**\n * Releases the representation and all associated objects like streams,\n * channels or files which are used to produce its content, transient or\n * not. This method must be systematically called when the representation is\n * no longer intended to be used. The framework automatically calls back\n * this method via its connectors on the server-side when sending responses\n * with an entity and on the client-side when sending a request with an\n * entity. By default, it calls the {@link #setAvailable(boolean)} method\n * with \"false\" as a value.<br>\n * <br>\n * Note that for transient socket-bound representations, calling this method\n * after consuming the whole content shouldn't prevent the reuse of\n * underlying socket via persistent connections for example. However, if the\n * content hasn't been read, or has been partially read, the impact should\n * be to discard the remaining content and to close the underlying\n * connections.<br>\n * <br>\n * Therefore, if you are not interested in the content, or in the remaining\n * content, you should first call the {@link #exhaust()} method or if this\n * could be too costly, you should instead explicitly abort the parent\n * request and the underlying connections using the {@link Request#abort()}\n * method or a shortcut one like\n * {@link org.restlet.resource.ServerResource#abort()} or\n * {@link Response#abort()}.\n */\n public void release() {\n    setAvailable(false);\n }\n```\n查看此方法被引用的地方，其中最重要的一处为ServerCall类的sendResponse方法：\n```java\n/**\n * Sends the response back to the client. Commits the status, headers and\n * optional entity and send them over the network. The default\n * implementation only writes the response entity on the response stream or\n * channel. Subclasses will probably also copy the response headers and\n * status.\n * \n * @param response\n *            The high-level response.\n * @throws IOException\n *             if the Response could not be written to the network.\n */\n public void sendResponse(Response response) throws IOException {\n    if (response != null) {\n        // Get the connector service to callback\n        Representation responseEntity = response.getEntity();\n        ConnectorService connectorService = ConnectorHelper\n                    .getConnectorService();\n\n        if (connectorService != null) {\n            connectorService.beforeSend(responseEntity);\n        }\n        OutputStream responseEntityStream = null;\n        try {\n            writeResponseHead(response);\n            if (responseEntity != null) {\n                responseEntityStream = getResponseEntityStream();\n                writeResponseBody(responseEntity, responseEntityStream);\n            }\n        } finally {\n            if (responseEntityStream != null) {\n                try {\n                    responseEntityStream.flush();\n                    responseEntityStream.close();\n                } catch (IOException ioe) {\n                    // The stream was probably already closed by the\n                    // connector. Probably OK, low message priority.\n                    getLogger().log(Level.FINE,\n                                        \"Exception while flushing and closing the entity stream.\",\n                                        ioe);\n                }\n            }\n            if (responseEntity != null) {\n                responseEntity.release();\n            }\n            if (connectorService != null) {\n                connectorService.afterSend(responseEntity);\n            }\n        }\n    }\n }\n```\n##拨开云雾见天日 守得云开见月明\n通过分析，在服务端返回消息给客户端时，会将Representation进行release()，那么InputStream也会释放～\n\n进一步联想：无论是struts／spring或者其他框架，其实都是基于servlet，那么servlet中的流是如何关闭的呢？\n\n有人说：在Servlet中，因为filter的关系，很多时候需要把response里面的内容拿出来，进行过滤，比如编码上的问题，如果你在自己的response里面getWriter().close()掉，其他的filter会出现异常。Servlet最后会帮你关闭的，放心。如果自己用PrintWriter的话，还是得关闭。\n\n有人说：servlet生命周期，用户可以在doGet或doPost中自己关闭输出流；也可以在destory中关闭释放；如果还没有做操作，destory，后会释放servlet实例，自然释放了servlet占用的所有资源。\n\n其实，一个filter、servlet只有一个实例来处理所有请求，`最基础的知识`,`servlet实例中压根没有request、response`，destory想释放估计心有余而力不足，也不要指望在destory里关闭response，他压根不是干这个用的\n\n查看tomcat的源码可以发现，resoponse如果没有关闭，tomcat会自动关闭，org.apache.catalina.core.ApplicationDispatcher.doForward(ServletRequest request, ServletResponse response)方法，最后一段代码是：\n```java\n// Close anyway\ntry {\n    PrintWriter writer = response.getWriter();\n    writer.close();\n} catch (IllegalStateException e) {\n    try {\n        ServletOutputStream stream = response.getOutputStream();\n        stream.close();\n    } catch (IllegalStateException f) {\n        // Ignore\n    } catch (IOException f) {\n        // Ignore\n    }\n} catch (IOException e) {\n    // Ignore\n}\n```\n可以清楚看到不管你有没有关闭，tomcat都重新关闭了一次\n\n所以说，javax.servlet是一种标准，是给人实现的。\n\nresponse应该是由Connector类实现的。对外是(javax.servlet.response) response 把方法限定在javax.servlet.response范围。\n\n所以你想要看实现。\n我是看的是tomcat4.1.2(深入剖析tomcat这本书是用这个的。)\norg.apache.catalina.connector.http.HttpProcessor  response.finishResponse();\n\n好了，就到此为止了，通过此次分析颇有感触，要真正弄懂底层原理才能更好的运用自如！","slug":"BUG：Restlet流式读取远端文件内容时inputstream未关闭","published":1,"updated":"2025-03-07T13:26:47.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz1x0001rz5mh8epbe6e","content":"<p>利用Restlet流式读取远端文件时，如果没有手动将inputstream关闭，那么InputRepresentation会自动将inputstream关闭吗？</p>\n<span id=\"more\"></span>\n<p>Restlet 服务端接收rest请求后，读取文件，将文件转为流，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XXResource</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServerResource</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Get</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> InputRepresentation <span class=\"title function_\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> FileNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/root/test.txt&quot;</span> );</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file);</span><br><span class=\"line\">        <span class=\"type\">InputRepresentation</span> <span class=\"variable\">inputRepresentation</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputRepresentation</span>(</span><br><span class=\"line\">                inputStream);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inputRepresentation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们都知道，将文件转为流，在使用结束后需要将流关闭，否则IO资源就会被一直占着，其他方法没法使用，造成资源浪费<br>进一步考虑，如果此处不需要关闭流，那么在InputRePresentation中应该会把流释放，那么有没有释放呢，我们看InputRepresentation源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.stream != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException var2) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Context.getCurrentLogger().log(Level.WARNING, <span class=\"string\">&quot;Error while releasing the representation.&quot;</span>, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stream = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，此方法为public公用方法，没有地方调用，难道需要手动调用InputRePresentation的release()方法？<br>看了下StackOverFlow上这个<a href=\"https://stackoverflow.com/questions/22658056/restlet-not-closing-inputrepresentation-streams\">问答</a>，说的是这个确实是个问题，更新了新版本之后还是没有看到在哪儿调用release()方法，结果回答的人又让手动调用release()方法，这。。</p>\n<p>看了下这篇<a href=\"http://restlet-discuss.1400322.n2.nabble.com/PROBLEM-WITH-org-restlet-representation-InputRepresentation-IN-1-2-M2-td3055389.html\">讨论</a>，明天换个新版本试试～</p>\n<p>##continue<br>今天下载了restlet2.3.9的源码（Maven工程）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>maven-restlet<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Public online Restlet repository<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.restlet.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.restlet.jee<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>org.restlet<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.9<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过从InputRePresentation逐层往父类查找，在RepresentationInfo中找到release()方法的解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Releases the representation and all associated objects like streams,</span></span><br><span class=\"line\"><span class=\"comment\"> * channels or files which are used to produce its content, transient or</span></span><br><span class=\"line\"><span class=\"comment\"> * not. This method must be systematically called when the representation is</span></span><br><span class=\"line\"><span class=\"comment\"> * no longer intended to be used. The framework automatically calls back</span></span><br><span class=\"line\"><span class=\"comment\"> * this method via its connectors on the server-side when sending responses</span></span><br><span class=\"line\"><span class=\"comment\"> * with an entity and on the client-side when sending a request with an</span></span><br><span class=\"line\"><span class=\"comment\"> * entity. By default, it calls the &#123;<span class=\"doctag\">@link</span> #setAvailable(boolean)&#125; method</span></span><br><span class=\"line\"><span class=\"comment\"> * with &quot;false&quot; as a value.&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that for transient socket-bound representations, calling this method</span></span><br><span class=\"line\"><span class=\"comment\"> * after consuming the whole content shouldn&#x27;t prevent the reuse of</span></span><br><span class=\"line\"><span class=\"comment\"> * underlying socket via persistent connections for example. However, if the</span></span><br><span class=\"line\"><span class=\"comment\"> * content hasn&#x27;t been read, or has been partially read, the impact should</span></span><br><span class=\"line\"><span class=\"comment\"> * be to discard the remaining content and to close the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> * connections.&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, if you are not interested in the content, or in the remaining</span></span><br><span class=\"line\"><span class=\"comment\"> * content, you should first call the &#123;<span class=\"doctag\">@link</span> #exhaust()&#125; method or if this</span></span><br><span class=\"line\"><span class=\"comment\"> * could be too costly, you should instead explicitly abort the parent</span></span><br><span class=\"line\"><span class=\"comment\"> * request and the underlying connections using the &#123;<span class=\"doctag\">@link</span> Request#abort()&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * method or a shortcut one like</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.restlet.resource.ServerResource#abort()&#125; or</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Response#abort()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    setAvailable(<span class=\"literal\">false</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>查看此方法被引用的地方，其中最重要的一处为ServerCall类的sendResponse方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sends the response back to the client. Commits the status, headers and</span></span><br><span class=\"line\"><span class=\"comment\"> * optional entity and send them over the network. The default</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation only writes the response entity on the response stream or</span></span><br><span class=\"line\"><span class=\"comment\"> * channel. Subclasses will probably also copy the response headers and</span></span><br><span class=\"line\"><span class=\"comment\"> * status.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\"> *            The high-level response.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\"> *             if the Response could not be written to the network.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendResponse</span><span class=\"params\">(Response response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Get the connector service to callback</span></span><br><span class=\"line\">        <span class=\"type\">Representation</span> <span class=\"variable\">responseEntity</span> <span class=\"operator\">=</span> response.getEntity();</span><br><span class=\"line\">        <span class=\"type\">ConnectorService</span> <span class=\"variable\">connectorService</span> <span class=\"operator\">=</span> ConnectorHelper</span><br><span class=\"line\">                    .getConnectorService();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connectorService != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            connectorService.beforeSend(responseEntity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">responseEntityStream</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            writeResponseHead(response);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntity != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                responseEntityStream = getResponseEntityStream();</span><br><span class=\"line\">                writeResponseBody(responseEntity, responseEntityStream);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntityStream != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    responseEntityStream.flush();</span><br><span class=\"line\">                    responseEntityStream.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The stream was probably already closed by the</span></span><br><span class=\"line\">                    <span class=\"comment\">// connector. Probably OK, low message priority.</span></span><br><span class=\"line\">                    getLogger().log(Level.FINE,</span><br><span class=\"line\">                                        <span class=\"string\">&quot;Exception while flushing and closing the entity stream.&quot;</span>,</span><br><span class=\"line\">                                        ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntity != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                responseEntity.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connectorService != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                connectorService.afterSend(responseEntity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>##拨开云雾见天日 守得云开见月明<br>通过分析，在服务端返回消息给客户端时，会将Representation进行release()，那么InputStream也会释放～</p>\n<p>进一步联想：无论是struts／spring或者其他框架，其实都是基于servlet，那么servlet中的流是如何关闭的呢？</p>\n<p>有人说：在Servlet中，因为filter的关系，很多时候需要把response里面的内容拿出来，进行过滤，比如编码上的问题，如果你在自己的response里面getWriter().close()掉，其他的filter会出现异常。Servlet最后会帮你关闭的，放心。如果自己用PrintWriter的话，还是得关闭。</p>\n<p>有人说：servlet生命周期，用户可以在doGet或doPost中自己关闭输出流；也可以在destory中关闭释放；如果还没有做操作，destory，后会释放servlet实例，自然释放了servlet占用的所有资源。</p>\n<p>其实，一个filter、servlet只有一个实例来处理所有请求，<code>最基础的知识</code>,<code>servlet实例中压根没有request、response</code>，destory想释放估计心有余而力不足，也不要指望在destory里关闭response，他压根不是干这个用的</p>\n<p>查看tomcat的源码可以发现，resoponse如果没有关闭，tomcat会自动关闭，org.apache.catalina.core.ApplicationDispatcher.doForward(ServletRequest request, ServletResponse response)方法，最后一段代码是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Close anyway</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">PrintWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> response.getWriter();</span><br><span class=\"line\">    writer.close();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ServletOutputStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> response.getOutputStream();</span><br><span class=\"line\">        stream.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalStateException f) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException f) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以清楚看到不管你有没有关闭，tomcat都重新关闭了一次</p>\n<p>所以说，javax.servlet是一种标准，是给人实现的。</p>\n<p>response应该是由Connector类实现的。对外是(javax.servlet.response) response 把方法限定在javax.servlet.response范围。</p>\n<p>所以你想要看实现。<br>我是看的是tomcat4.1.2(深入剖析tomcat这本书是用这个的。)<br>org.apache.catalina.connector.http.HttpProcessor  response.finishResponse();</p>\n<p>好了，就到此为止了，通过此次分析颇有感触，要真正弄懂底层原理才能更好的运用自如！</p>\n","site":{"data":{}},"excerpt":"<p>利用Restlet流式读取远端文件时，如果没有手动将inputstream关闭，那么InputRepresentation会自动将inputstream关闭吗？</p>","more":"<p>Restlet 服务端接收rest请求后，读取文件，将文件转为流，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">XXResource</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ServerResource</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Get</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> InputRepresentation <span class=\"title function_\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> FileNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/root/test.txt&quot;</span> );</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(file);</span><br><span class=\"line\">        <span class=\"type\">InputRepresentation</span> <span class=\"variable\">inputRepresentation</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputRepresentation</span>(</span><br><span class=\"line\">                inputStream);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inputRepresentation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们都知道，将文件转为流，在使用结束后需要将流关闭，否则IO资源就会被一直占着，其他方法没法使用，造成资源浪费<br>进一步考虑，如果此处不需要关闭流，那么在InputRePresentation中应该会把流释放，那么有没有释放呢，我们看InputRepresentation源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.stream != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.stream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException var2) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Context.getCurrentLogger().log(Level.WARNING, <span class=\"string\">&quot;Error while releasing the representation.&quot;</span>, var2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.stream = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，此方法为public公用方法，没有地方调用，难道需要手动调用InputRePresentation的release()方法？<br>看了下StackOverFlow上这个<a href=\"https://stackoverflow.com/questions/22658056/restlet-not-closing-inputrepresentation-streams\">问答</a>，说的是这个确实是个问题，更新了新版本之后还是没有看到在哪儿调用release()方法，结果回答的人又让手动调用release()方法，这。。</p>\n<p>看了下这篇<a href=\"http://restlet-discuss.1400322.n2.nabble.com/PROBLEM-WITH-org-restlet-representation-InputRepresentation-IN-1-2-M2-td3055389.html\">讨论</a>，明天换个新版本试试～</p>\n<p>##continue<br>今天下载了restlet2.3.9的源码（Maven工程）：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>maven-restlet<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Public online Restlet repository<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.restlet.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.restlet.jee<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>org.restlet<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.9<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>通过从InputRePresentation逐层往父类查找，在RepresentationInfo中找到release()方法的解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Releases the representation and all associated objects like streams,</span></span><br><span class=\"line\"><span class=\"comment\"> * channels or files which are used to produce its content, transient or</span></span><br><span class=\"line\"><span class=\"comment\"> * not. This method must be systematically called when the representation is</span></span><br><span class=\"line\"><span class=\"comment\"> * no longer intended to be used. The framework automatically calls back</span></span><br><span class=\"line\"><span class=\"comment\"> * this method via its connectors on the server-side when sending responses</span></span><br><span class=\"line\"><span class=\"comment\"> * with an entity and on the client-side when sending a request with an</span></span><br><span class=\"line\"><span class=\"comment\"> * entity. By default, it calls the &#123;<span class=\"doctag\">@link</span> #setAvailable(boolean)&#125; method</span></span><br><span class=\"line\"><span class=\"comment\"> * with &quot;false&quot; as a value.&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Note that for transient socket-bound representations, calling this method</span></span><br><span class=\"line\"><span class=\"comment\"> * after consuming the whole content shouldn&#x27;t prevent the reuse of</span></span><br><span class=\"line\"><span class=\"comment\"> * underlying socket via persistent connections for example. However, if the</span></span><br><span class=\"line\"><span class=\"comment\"> * content hasn&#x27;t been read, or has been partially read, the impact should</span></span><br><span class=\"line\"><span class=\"comment\"> * be to discard the remaining content and to close the underlying</span></span><br><span class=\"line\"><span class=\"comment\"> * connections.&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Therefore, if you are not interested in the content, or in the remaining</span></span><br><span class=\"line\"><span class=\"comment\"> * content, you should first call the &#123;<span class=\"doctag\">@link</span> #exhaust()&#125; method or if this</span></span><br><span class=\"line\"><span class=\"comment\"> * could be too costly, you should instead explicitly abort the parent</span></span><br><span class=\"line\"><span class=\"comment\"> * request and the underlying connections using the &#123;<span class=\"doctag\">@link</span> Request#abort()&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * method or a shortcut one like</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> org.restlet.resource.ServerResource#abort()&#125; or</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> Response#abort()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    setAvailable(<span class=\"literal\">false</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>查看此方法被引用的地方，其中最重要的一处为ServerCall类的sendResponse方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sends the response back to the client. Commits the status, headers and</span></span><br><span class=\"line\"><span class=\"comment\"> * optional entity and send them over the network. The default</span></span><br><span class=\"line\"><span class=\"comment\"> * implementation only writes the response entity on the response stream or</span></span><br><span class=\"line\"><span class=\"comment\"> * channel. Subclasses will probably also copy the response headers and</span></span><br><span class=\"line\"><span class=\"comment\"> * status.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\"> *            The high-level response.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\"> *             if the Response could not be written to the network.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sendResponse</span><span class=\"params\">(Response response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Get the connector service to callback</span></span><br><span class=\"line\">        <span class=\"type\">Representation</span> <span class=\"variable\">responseEntity</span> <span class=\"operator\">=</span> response.getEntity();</span><br><span class=\"line\">        <span class=\"type\">ConnectorService</span> <span class=\"variable\">connectorService</span> <span class=\"operator\">=</span> ConnectorHelper</span><br><span class=\"line\">                    .getConnectorService();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connectorService != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            connectorService.beforeSend(responseEntity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">responseEntityStream</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            writeResponseHead(response);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntity != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                responseEntityStream = getResponseEntityStream();</span><br><span class=\"line\">                writeResponseBody(responseEntity, responseEntityStream);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntityStream != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    responseEntityStream.flush();</span><br><span class=\"line\">                    responseEntityStream.close();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The stream was probably already closed by the</span></span><br><span class=\"line\">                    <span class=\"comment\">// connector. Probably OK, low message priority.</span></span><br><span class=\"line\">                    getLogger().log(Level.FINE,</span><br><span class=\"line\">                                        <span class=\"string\">&quot;Exception while flushing and closing the entity stream.&quot;</span>,</span><br><span class=\"line\">                                        ioe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (responseEntity != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                responseEntity.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connectorService != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                connectorService.afterSend(responseEntity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>##拨开云雾见天日 守得云开见月明<br>通过分析，在服务端返回消息给客户端时，会将Representation进行release()，那么InputStream也会释放～</p>\n<p>进一步联想：无论是struts／spring或者其他框架，其实都是基于servlet，那么servlet中的流是如何关闭的呢？</p>\n<p>有人说：在Servlet中，因为filter的关系，很多时候需要把response里面的内容拿出来，进行过滤，比如编码上的问题，如果你在自己的response里面getWriter().close()掉，其他的filter会出现异常。Servlet最后会帮你关闭的，放心。如果自己用PrintWriter的话，还是得关闭。</p>\n<p>有人说：servlet生命周期，用户可以在doGet或doPost中自己关闭输出流；也可以在destory中关闭释放；如果还没有做操作，destory，后会释放servlet实例，自然释放了servlet占用的所有资源。</p>\n<p>其实，一个filter、servlet只有一个实例来处理所有请求，<code>最基础的知识</code>,<code>servlet实例中压根没有request、response</code>，destory想释放估计心有余而力不足，也不要指望在destory里关闭response，他压根不是干这个用的</p>\n<p>查看tomcat的源码可以发现，resoponse如果没有关闭，tomcat会自动关闭，org.apache.catalina.core.ApplicationDispatcher.doForward(ServletRequest request, ServletResponse response)方法，最后一段代码是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Close anyway</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">PrintWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> response.getWriter();</span><br><span class=\"line\">    writer.close();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ServletOutputStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> response.getOutputStream();</span><br><span class=\"line\">        stream.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IllegalStateException f) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException f) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Ignore</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以清楚看到不管你有没有关闭，tomcat都重新关闭了一次</p>\n<p>所以说，javax.servlet是一种标准，是给人实现的。</p>\n<p>response应该是由Connector类实现的。对外是(javax.servlet.response) response 把方法限定在javax.servlet.response范围。</p>\n<p>所以你想要看实现。<br>我是看的是tomcat4.1.2(深入剖析tomcat这本书是用这个的。)<br>org.apache.catalina.connector.http.HttpProcessor  response.finishResponse();</p>\n<p>好了，就到此为止了，通过此次分析颇有感触，要真正弄懂底层原理才能更好的运用自如！</p>"},{"title":"BUG：无法确定T的类型参数","date":"2017-07-31T14:30:46.000Z","type":"tags","_content":"最近遇到了与jdk版本有关的问题，同样的代码在本地跑起来没有问题，一到服务器上就出问题了，问题如下：\n无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例，乍一看，类型转换出错了？\n<!--more-->\n## 废话不多说，先上代码：\n```java\nprivate MyBean bean;\npublic void test()\n{\n  WhiteBox.setIntervalState(bean, 'id', 1);\n  TestCase.assertTrue(bean.getId() == 1);\n}\n```\n## 运行时，出现如下错误：\n```js\n无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例\n```\n## 解决方法\n那么如何解决呢？不存在唯一最大实例，那么就强制类型转换好了，修改如下：\n```java\nInteger id = Integer.valueOf(bean.getId());\n```\n## 原因分析\n通过对比发现，服务器的jdk版本为`jdk1.6.0_03`，而本地的jdk版本为`jdk1.6.0_45`，通过上网搜索发现，这是jdk的一个bug，具体链接为[jdk bug 6468354](https://blogs.openjdk.java.net/browse/JDK-6468354)，这个bug已在jdk1.6.0_25修复，所以本地的运行没有问题，服务器上的运行有问题。\n\n小伙伴们，下次如果遇到同样的问题，记得看下jdk的版本号哦～","source":"_posts/BUG：无法确定T的类型参数.md","raw":"title: BUG：无法确定T的类型参数\ndate: 2017-07-31 22:30:46\ntype: \"tags\"\ntags:\n- Java\ncategories: 疑难杂症\n---\n最近遇到了与jdk版本有关的问题，同样的代码在本地跑起来没有问题，一到服务器上就出问题了，问题如下：\n无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例，乍一看，类型转换出错了？\n<!--more-->\n## 废话不多说，先上代码：\n```java\nprivate MyBean bean;\npublic void test()\n{\n  WhiteBox.setIntervalState(bean, 'id', 1);\n  TestCase.assertTrue(bean.getId() == 1);\n}\n```\n## 运行时，出现如下错误：\n```js\n无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例\n```\n## 解决方法\n那么如何解决呢？不存在唯一最大实例，那么就强制类型转换好了，修改如下：\n```java\nInteger id = Integer.valueOf(bean.getId());\n```\n## 原因分析\n通过对比发现，服务器的jdk版本为`jdk1.6.0_03`，而本地的jdk版本为`jdk1.6.0_45`，通过上网搜索发现，这是jdk的一个bug，具体链接为[jdk bug 6468354](https://blogs.openjdk.java.net/browse/JDK-6468354)，这个bug已在jdk1.6.0_25修复，所以本地的运行没有问题，服务器上的运行有问题。\n\n小伙伴们，下次如果遇到同样的问题，记得看下jdk的版本号哦～","slug":"BUG：无法确定T的类型参数","published":1,"updated":"2025-03-07T13:26:47.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz210003rz5mbkvbgevh","content":"<p>最近遇到了与jdk版本有关的问题，同样的代码在本地跑起来没有问题，一到服务器上就出问题了，问题如下：<br>无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例，乍一看，类型转换出错了？</p>\n<span id=\"more\"></span>\n<h2 id=\"废话不多说，先上代码：\"><a href=\"#废话不多说，先上代码：\" class=\"headerlink\" title=\"废话不多说，先上代码：\"></a>废话不多说，先上代码：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MyBean bean;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  WhiteBox.setIntervalState(bean, <span class=\"string\">&#x27;id&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  TestCase.assertTrue(bean.getId() == <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行时，出现如下错误：\"><a href=\"#运行时，出现如下错误：\" class=\"headerlink\" title=\"运行时，出现如下错误：\"></a>运行时，出现如下错误：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无法确定T的类型参数；对于上下限为T，java.<span class=\"property\">lang</span>.<span class=\"property\">Object</span>的类型变量下，不存在唯一最大实例</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>那么如何解决呢？不存在唯一最大实例，那么就强制类型转换好了，修改如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> Integer.valueOf(bean.getId());</span><br></pre></td></tr></table></figure>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>通过对比发现，服务器的jdk版本为<code>jdk1.6.0_03</code>，而本地的jdk版本为<code>jdk1.6.0_45</code>，通过上网搜索发现，这是jdk的一个bug，具体链接为<a href=\"https://blogs.openjdk.java.net/browse/JDK-6468354\">jdk bug 6468354</a>，这个bug已在jdk1.6.0_25修复，所以本地的运行没有问题，服务器上的运行有问题。</p>\n<p>小伙伴们，下次如果遇到同样的问题，记得看下jdk的版本号哦～</p>\n","site":{"data":{}},"excerpt":"<p>最近遇到了与jdk版本有关的问题，同样的代码在本地跑起来没有问题，一到服务器上就出问题了，问题如下：<br>无法确定T的类型参数；对于上下限为T，java.lang.Object的类型变量下，不存在唯一最大实例，乍一看，类型转换出错了？</p>","more":"<h2 id=\"废话不多说，先上代码：\"><a href=\"#废话不多说，先上代码：\" class=\"headerlink\" title=\"废话不多说，先上代码：\"></a>废话不多说，先上代码：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MyBean bean;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  WhiteBox.setIntervalState(bean, <span class=\"string\">&#x27;id&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  TestCase.assertTrue(bean.getId() == <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行时，出现如下错误：\"><a href=\"#运行时，出现如下错误：\" class=\"headerlink\" title=\"运行时，出现如下错误：\"></a>运行时，出现如下错误：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无法确定T的类型参数；对于上下限为T，java.<span class=\"property\">lang</span>.<span class=\"property\">Object</span>的类型变量下，不存在唯一最大实例</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>那么如何解决呢？不存在唯一最大实例，那么就强制类型转换好了，修改如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> Integer.valueOf(bean.getId());</span><br></pre></td></tr></table></figure>\n<h2 id=\"原因分析\"><a href=\"#原因分析\" class=\"headerlink\" title=\"原因分析\"></a>原因分析</h2><p>通过对比发现，服务器的jdk版本为<code>jdk1.6.0_03</code>，而本地的jdk版本为<code>jdk1.6.0_45</code>，通过上网搜索发现，这是jdk的一个bug，具体链接为<a href=\"https://blogs.openjdk.java.net/browse/JDK-6468354\">jdk bug 6468354</a>，这个bug已在jdk1.6.0_25修复，所以本地的运行没有问题，服务器上的运行有问题。</p>\n<p>小伙伴们，下次如果遇到同样的问题，记得看下jdk的版本号哦～</p>"},{"title":"Flask+SAE搭建微信后台初探","date":"2015-05-11T15:54:24.000Z","type":"tags","_content":"Flask+SAE搭建微信后台初探\n<!--more-->\n## 申请微信公众号\n申请通过之后，将模式改为`开发者模式`，并填入自己服务器的`url`及`token`（令牌）。\n## 在SAE上新建Python项目\n- 通过SVN管理版本\n- Flask框架\n具体见[SAE入门指南](http://sae.sina.com.cn/doc/python/tutorial.html)\n\n## 微信公众号与SAE应用的对接和验证\n处理流程为：\n- 用户发送请求到微信服务器\n- 微信服务器发送请求到SAE\n- SAE返回消息给微信服务器\n- 微信服务器返回消息给用户\n\nSAE上处理Http请求，验证之后返回，代码如下：\n```python\n# -*- coding:utf8 -*-\nimport time\nfrom flask import Flask, g, request, make_response\nimport hashlib\n\n@app.route('/', methods = ['GET', 'POST'] )\ndef wechat_auth():\n  if request.method == 'GET':\n    token = 'xxxxxxxxxxx' # your token\n    query = request.args  # GET 方法附上的参数\n    signature = query.get('signature', '')\n    timestamp = query.get('timestamp', '')\n    nonce = query.get('nonce', '')\n    echostr = query.get('echostr', '')\n    s = [timestamp, nonce, token]\n    s.sort()\n    s = ''.join(s)\n    if ( hashlib.sha1(s).hexdigest() == signature ):\n      return make_response(echostr)\n```\n按照SAE中Python及Flask规范将代码提交到SVN中，将应用地址和token填入微信公众平台进行验证，如果设置成功，即完成验证。\n### 处理用户消息（以文本消息为例）\n当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上，文本消息格式如下：\n```\n<xml>\n <ToUserName><![CDATA[toUser]]></ToUserName>\n <FromUserName><![CDATA[fromUser]]></FromUserName> \n <CreateTime>1348831860</CreateTime>\n <MsgType><![CDATA[text]]></MsgType>\n <Content><![CDATA[this is a test]]></Content>\n <MsgId>1234567890123456</MsgId>\n</xml>\n```\n我们将此消息解析出来，然后再构造xml返回给用户，`ToUserName和FromUserName`需对换，代码如下：\n```python\n# Get the infomations from the recv_xml.  \nxml_recv = ET.fromstring(request.data)\nToUserName = xml_recv.find(\"ToUserName\").text\nFromUserName = xml_recv.find(\"FromUserName\").text\nContent = xml_recv.find(\"Content\").text \n# 此处可处理Content\nreply = \"<xml><ToUserName><![CDATA[%s]]></ToUserName><FromUserName><![CDATA[%s]]></FromUserName><CreateTime>%s</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[%s]]></Content><FuncFlag>0</FuncFlag></xml>\"\nresponse = make_response( reply % (FromUserName, ToUserName, str(int(time.time())), Content ) )\nresponse.content_type = 'application/xml'\nreturn response \n```\n到此，在微信公众号里回复消息，应该就会有消息回复啦~\n\n参考\n[SAE入门指南之Python](http://sae.sina.com.cn/doc/python/tutorial.html)\n[微信接入指南](http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html)\n","source":"_posts/Flask-SAE搭建微信后台初探.md","raw":"title: \"Flask+SAE搭建微信后台初探\"\ndate: 2015-05-11 23:54:24\ntype: \"tags\"\ntags:\n- Flask\n- Python\n- 微信公众平台开发\n---\nFlask+SAE搭建微信后台初探\n<!--more-->\n## 申请微信公众号\n申请通过之后，将模式改为`开发者模式`，并填入自己服务器的`url`及`token`（令牌）。\n## 在SAE上新建Python项目\n- 通过SVN管理版本\n- Flask框架\n具体见[SAE入门指南](http://sae.sina.com.cn/doc/python/tutorial.html)\n\n## 微信公众号与SAE应用的对接和验证\n处理流程为：\n- 用户发送请求到微信服务器\n- 微信服务器发送请求到SAE\n- SAE返回消息给微信服务器\n- 微信服务器返回消息给用户\n\nSAE上处理Http请求，验证之后返回，代码如下：\n```python\n# -*- coding:utf8 -*-\nimport time\nfrom flask import Flask, g, request, make_response\nimport hashlib\n\n@app.route('/', methods = ['GET', 'POST'] )\ndef wechat_auth():\n  if request.method == 'GET':\n    token = 'xxxxxxxxxxx' # your token\n    query = request.args  # GET 方法附上的参数\n    signature = query.get('signature', '')\n    timestamp = query.get('timestamp', '')\n    nonce = query.get('nonce', '')\n    echostr = query.get('echostr', '')\n    s = [timestamp, nonce, token]\n    s.sort()\n    s = ''.join(s)\n    if ( hashlib.sha1(s).hexdigest() == signature ):\n      return make_response(echostr)\n```\n按照SAE中Python及Flask规范将代码提交到SVN中，将应用地址和token填入微信公众平台进行验证，如果设置成功，即完成验证。\n### 处理用户消息（以文本消息为例）\n当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上，文本消息格式如下：\n```\n<xml>\n <ToUserName><![CDATA[toUser]]></ToUserName>\n <FromUserName><![CDATA[fromUser]]></FromUserName> \n <CreateTime>1348831860</CreateTime>\n <MsgType><![CDATA[text]]></MsgType>\n <Content><![CDATA[this is a test]]></Content>\n <MsgId>1234567890123456</MsgId>\n</xml>\n```\n我们将此消息解析出来，然后再构造xml返回给用户，`ToUserName和FromUserName`需对换，代码如下：\n```python\n# Get the infomations from the recv_xml.  \nxml_recv = ET.fromstring(request.data)\nToUserName = xml_recv.find(\"ToUserName\").text\nFromUserName = xml_recv.find(\"FromUserName\").text\nContent = xml_recv.find(\"Content\").text \n# 此处可处理Content\nreply = \"<xml><ToUserName><![CDATA[%s]]></ToUserName><FromUserName><![CDATA[%s]]></FromUserName><CreateTime>%s</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[%s]]></Content><FuncFlag>0</FuncFlag></xml>\"\nresponse = make_response( reply % (FromUserName, ToUserName, str(int(time.time())), Content ) )\nresponse.content_type = 'application/xml'\nreturn response \n```\n到此，在微信公众号里回复消息，应该就会有消息回复啦~\n\n参考\n[SAE入门指南之Python](http://sae.sina.com.cn/doc/python/tutorial.html)\n[微信接入指南](http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html)\n","slug":"Flask-SAE搭建微信后台初探","published":1,"updated":"2025-03-07T13:26:47.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz250007rz5m1wd5bnqj","content":"<p>Flask+SAE搭建微信后台初探</p>\n<span id=\"more\"></span>\n<h2 id=\"申请微信公众号\"><a href=\"#申请微信公众号\" class=\"headerlink\" title=\"申请微信公众号\"></a>申请微信公众号</h2><p>申请通过之后，将模式改为<code>开发者模式</code>，并填入自己服务器的<code>url</code>及<code>token</code>（令牌）。</p>\n<h2 id=\"在SAE上新建Python项目\"><a href=\"#在SAE上新建Python项目\" class=\"headerlink\" title=\"在SAE上新建Python项目\"></a>在SAE上新建Python项目</h2><ul>\n<li>通过SVN管理版本</li>\n<li>Flask框架<br>具体见<a href=\"http://sae.sina.com.cn/doc/python/tutorial.html\">SAE入门指南</a></li>\n</ul>\n<h2 id=\"微信公众号与SAE应用的对接和验证\"><a href=\"#微信公众号与SAE应用的对接和验证\" class=\"headerlink\" title=\"微信公众号与SAE应用的对接和验证\"></a>微信公众号与SAE应用的对接和验证</h2><p>处理流程为：</p>\n<ul>\n<li>用户发送请求到微信服务器</li>\n<li>微信服务器发送请求到SAE</li>\n<li>SAE返回消息给微信服务器</li>\n<li>微信服务器返回消息给用户</li>\n</ul>\n<p>SAE上处理Http请求，验证之后返回，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding:utf8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, g, request, make_response</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span>, methods = [<span class=\"string\">&#x27;GET&#x27;</span>, <span class=\"string\">&#x27;POST&#x27;</span>] </span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">wechat_auth</span>():</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request.method == <span class=\"string\">&#x27;GET&#x27;</span>:</span><br><span class=\"line\">    token = <span class=\"string\">&#x27;xxxxxxxxxxx&#x27;</span> <span class=\"comment\"># your token</span></span><br><span class=\"line\">    query = request.args  <span class=\"comment\"># GET 方法附上的参数</span></span><br><span class=\"line\">    signature = query.get(<span class=\"string\">&#x27;signature&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    timestamp = query.get(<span class=\"string\">&#x27;timestamp&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    nonce = query.get(<span class=\"string\">&#x27;nonce&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    echostr = query.get(<span class=\"string\">&#x27;echostr&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    s = [timestamp, nonce, token]</span><br><span class=\"line\">    s.sort()</span><br><span class=\"line\">    s = <span class=\"string\">&#x27;&#x27;</span>.join(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( hashlib.sha1(s).hexdigest() == signature ):</span><br><span class=\"line\">      <span class=\"keyword\">return</span> make_response(echostr)</span><br></pre></td></tr></table></figure>\n<p>按照SAE中Python及Flask规范将代码提交到SVN中，将应用地址和token填入微信公众平台进行验证，如果设置成功，即完成验证。</p>\n<h3 id=\"处理用户消息（以文本消息为例）\"><a href=\"#处理用户消息（以文本消息为例）\" class=\"headerlink\" title=\"处理用户消息（以文本消息为例）\"></a>处理用户消息（以文本消息为例）</h3><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上，文本消息格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;xml&gt;</span><br><span class=\"line\"> &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;</span><br><span class=\"line\"> &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; </span><br><span class=\"line\"> &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;</span><br><span class=\"line\"> &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span><br><span class=\"line\"> &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;</span><br><span class=\"line\"> &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;</span><br><span class=\"line\">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>\n<p>我们将此消息解析出来，然后再构造xml返回给用户，<code>ToUserName和FromUserName</code>需对换，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Get the infomations from the recv_xml.  </span></span><br><span class=\"line\">xml_recv = ET.fromstring(request.data)</span><br><span class=\"line\">ToUserName = xml_recv.find(<span class=\"string\">&quot;ToUserName&quot;</span>).text</span><br><span class=\"line\">FromUserName = xml_recv.find(<span class=\"string\">&quot;FromUserName&quot;</span>).text</span><br><span class=\"line\">Content = xml_recv.find(<span class=\"string\">&quot;Content&quot;</span>).text </span><br><span class=\"line\"><span class=\"comment\"># 此处可处理Content</span></span><br><span class=\"line\">reply = <span class=\"string\">&quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;&lt;/xml&gt;&quot;</span></span><br><span class=\"line\">response = make_response( reply % (FromUserName, ToUserName, <span class=\"built_in\">str</span>(<span class=\"built_in\">int</span>(time.time())), Content ) )</span><br><span class=\"line\">response.content_type = <span class=\"string\">&#x27;application/xml&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> response </span><br></pre></td></tr></table></figure>\n<p>到此，在微信公众号里回复消息，应该就会有消息回复啦~</p>\n<p>参考<br><a href=\"http://sae.sina.com.cn/doc/python/tutorial.html\">SAE入门指南之Python</a><br><a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\">微信接入指南</a></p>\n","site":{"data":{}},"excerpt":"<p>Flask+SAE搭建微信后台初探</p>","more":"<h2 id=\"申请微信公众号\"><a href=\"#申请微信公众号\" class=\"headerlink\" title=\"申请微信公众号\"></a>申请微信公众号</h2><p>申请通过之后，将模式改为<code>开发者模式</code>，并填入自己服务器的<code>url</code>及<code>token</code>（令牌）。</p>\n<h2 id=\"在SAE上新建Python项目\"><a href=\"#在SAE上新建Python项目\" class=\"headerlink\" title=\"在SAE上新建Python项目\"></a>在SAE上新建Python项目</h2><ul>\n<li>通过SVN管理版本</li>\n<li>Flask框架<br>具体见<a href=\"http://sae.sina.com.cn/doc/python/tutorial.html\">SAE入门指南</a></li>\n</ul>\n<h2 id=\"微信公众号与SAE应用的对接和验证\"><a href=\"#微信公众号与SAE应用的对接和验证\" class=\"headerlink\" title=\"微信公众号与SAE应用的对接和验证\"></a>微信公众号与SAE应用的对接和验证</h2><p>处理流程为：</p>\n<ul>\n<li>用户发送请求到微信服务器</li>\n<li>微信服务器发送请求到SAE</li>\n<li>SAE返回消息给微信服务器</li>\n<li>微信服务器返回消息给用户</li>\n</ul>\n<p>SAE上处理Http请求，验证之后返回，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding:utf8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, g, request, make_response</span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span>, methods = [<span class=\"string\">&#x27;GET&#x27;</span>, <span class=\"string\">&#x27;POST&#x27;</span>] </span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">wechat_auth</span>():</span><br><span class=\"line\">  <span class=\"keyword\">if</span> request.method == <span class=\"string\">&#x27;GET&#x27;</span>:</span><br><span class=\"line\">    token = <span class=\"string\">&#x27;xxxxxxxxxxx&#x27;</span> <span class=\"comment\"># your token</span></span><br><span class=\"line\">    query = request.args  <span class=\"comment\"># GET 方法附上的参数</span></span><br><span class=\"line\">    signature = query.get(<span class=\"string\">&#x27;signature&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    timestamp = query.get(<span class=\"string\">&#x27;timestamp&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    nonce = query.get(<span class=\"string\">&#x27;nonce&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    echostr = query.get(<span class=\"string\">&#x27;echostr&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    s = [timestamp, nonce, token]</span><br><span class=\"line\">    s.sort()</span><br><span class=\"line\">    s = <span class=\"string\">&#x27;&#x27;</span>.join(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( hashlib.sha1(s).hexdigest() == signature ):</span><br><span class=\"line\">      <span class=\"keyword\">return</span> make_response(echostr)</span><br></pre></td></tr></table></figure>\n<p>按照SAE中Python及Flask规范将代码提交到SVN中，将应用地址和token填入微信公众平台进行验证，如果设置成功，即完成验证。</p>\n<h3 id=\"处理用户消息（以文本消息为例）\"><a href=\"#处理用户消息（以文本消息为例）\" class=\"headerlink\" title=\"处理用户消息（以文本消息为例）\"></a>处理用户消息（以文本消息为例）</h3><p>当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到开发者填写的URL上，文本消息格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;xml&gt;</span><br><span class=\"line\"> &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;</span><br><span class=\"line\"> &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt; </span><br><span class=\"line\"> &lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;</span><br><span class=\"line\"> &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span><br><span class=\"line\"> &lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;</span><br><span class=\"line\"> &lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;</span><br><span class=\"line\">&lt;/xml&gt;</span><br></pre></td></tr></table></figure>\n<p>我们将此消息解析出来，然后再构造xml返回给用户，<code>ToUserName和FromUserName</code>需对换，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Get the infomations from the recv_xml.  </span></span><br><span class=\"line\">xml_recv = ET.fromstring(request.data)</span><br><span class=\"line\">ToUserName = xml_recv.find(<span class=\"string\">&quot;ToUserName&quot;</span>).text</span><br><span class=\"line\">FromUserName = xml_recv.find(<span class=\"string\">&quot;FromUserName&quot;</span>).text</span><br><span class=\"line\">Content = xml_recv.find(<span class=\"string\">&quot;Content&quot;</span>).text </span><br><span class=\"line\"><span class=\"comment\"># 此处可处理Content</span></span><br><span class=\"line\">reply = <span class=\"string\">&quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;&lt;/xml&gt;&quot;</span></span><br><span class=\"line\">response = make_response( reply % (FromUserName, ToUserName, <span class=\"built_in\">str</span>(<span class=\"built_in\">int</span>(time.time())), Content ) )</span><br><span class=\"line\">response.content_type = <span class=\"string\">&#x27;application/xml&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> response </span><br></pre></td></tr></table></figure>\n<p>到此，在微信公众号里回复消息，应该就会有消息回复啦~</p>\n<p>参考<br><a href=\"http://sae.sina.com.cn/doc/python/tutorial.html\">SAE入门指南之Python</a><br><a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\">微信接入指南</a></p>"},{"title":"Java学习路线","date":"2015-10-31T05:40:06.000Z","type":"tags","_content":"Java学习路线\n<!--more-->\n## 背景\n怎么学习Java，这是很多新手经常遇到的问题，现在我简单描述下一个Java初学者到就业要学到的一些东西： \n首先要明白Java体系设计到得三个方面：`J2SE`,`J2EE`,`J2ME（KJAVA）`。\nJ2SE，Java 2 Platform Standard Edition，我们经常说到的JDK，就主要指的这个，它是三者的基础，属于桌面级应用开发，这部分如果学得好很容易拓展J2EE和J2ME。\nJ2EE，Java 2 Platform，Enterprise Edition，就是所谓的企业级Java，适合企业的大型应用开发。\nJ2ME，The Micro Edition of the Java 2 Platform。主要用于嵌入式Java，如手机，PDA等等。\n\n## J2SE\n新手最初学习的时候先要从J2SE开始学起，所包含的内容主要分为：面向对象概念的理解、Java基本语法的学习，Java桌面图形界面应用程序的开发，掌握常用的Java API等（关键是要学会怎样查阅）。 \n- 重点：Java基本语法（循环结构，数据类型，数组，运算符等）、Swing，awt，事件机制、文件输入输出流处理等\n- 难点：面向对象思想的理解（接口、类等）、线程、socket网络编程等\n\n## J2EE \n在学习了J2SE之后，你可以尝试着慢慢过渡到J2EE，当然，学习J2EE海需要很多非JAVA技术的支撑，比如数据库技术，网页编程技术等等，待会我会详细介绍这两方面的内容。J2EE有三个必学的框架，如果你说你学了J2EE，但又不会这三个框架的话，那会让人笑掉大牙，这三个框架分别是Struts、Spring和Hibernate，虽然这三个框架应用很广，但不代表这三个框架就代表了J2EE，J2EE还有很多其他的东西，比如EJB，作为一款重量级（此重量级不是指重量级选手那个意思，此重量级非彼重量级）框架，虽然这个应用慢慢的再被其他框架所取代，但EJB3.0的出现也给它带回一些生机，作为一个分布式应用的框架，也是大家要去学习和了解的知识。 \n当然，刚才说到J2EE包含的范围很广，即使我把我所了解的所有技术说出来，也并不能代表J2EE，这是一个很深很广的学问，需要大家以后再工作的时候慢慢去发现了。我所了解的还包括： \n- JDBC:Java数据库连接对象，基础中的基础，Hibernate也只是对它的封装而已 \n- JNDI: Java 命名与目录接口，J2EE重要规范之一 \n- EJBS: 上面已经提到过了 \n- RMI: 提供远程调用方法的支持，主要用于程序分布式开发 \n- JMS: Java消息服务，中间件技术 \n- JAVA IDL: 提供J2EE平台与CORBA交互能力和互联能力的技术 \n- JTS: 组件事务监视器 \n- JTA: 事务划分的一个技术 \n- JAVAMAIL: Java中的邮件技术 \n- JAF: Java启动框架,没研究过 \n- Log4j，一款日志处理的框架应用 \n- Junit：单元测试的好帮手 \n- freemarker、velocity：两款不错的模板引擎 \n- 与Flash的交互Flex：目前很多的SNS应用就是使用到了这个技术 \n- Web services:想知道我们论坛天气预报的效果是怎么做的吗？请关注这个技术 \n- SOA:面向服务架构，未来技术发展的趋势之一 \n…… \n不过前面介绍到得这些都不是J2EE的基础,是属于框架应用级别的.要真正把上面说到的知识掌握好,还是的学习J2EE最核心的东西:JDBC、JSP、servlet和JavaBean,后面三个也是学习SSH的基础(Struts/Spring/Hibernate的简称).鉴于J2EE的内容太过复杂,建议大家最初只学习: JSP, servlet和JavaBean，等这个基础掌握好再把SSH学习了，再对其他J2EE技术有个大致的了解就可以出去找工作了。当然，找工作的前提除了把Java学习好，还会有一些其他的技术也是必须要掌握的。\n\n-_- 我很简单,Java却要求我学这么多复杂的东西。除了这些技术的东西，在这阶段，大家更多的是会接触到比如设计模式的东西，比如工厂模式、桥梁模式、单例模式等等，还要学习建模思想（比如UML建模等等）和软件生命周期等等。这些是升华大家编程思想的手段和途径。\n\n## J2ME \n如果你在学习了以上技术还不过瘾，可以再学习手机程序的开发，就我个人看来，开发手机程序技术其实蛮简单的，难点在于优化，比如怎么让你写的程序尽量的节约手机资源，“代码诚可贵，手机价更高“，所以不得不比PC机多考虑很多成本和实用性问题。J2ME的学习的话，切忌不要单纯的再模拟器上测试，一定要找真机测试，真机和模拟器的效果之间差别是很大的。","source":"_posts/Java学习路线.md","raw":"title: \"Java学习路线\"\ndate: 2015-10-31 13:40:06\ntype: \"tags\"\ntags:\n- Java\n---\nJava学习路线\n<!--more-->\n## 背景\n怎么学习Java，这是很多新手经常遇到的问题，现在我简单描述下一个Java初学者到就业要学到的一些东西： \n首先要明白Java体系设计到得三个方面：`J2SE`,`J2EE`,`J2ME（KJAVA）`。\nJ2SE，Java 2 Platform Standard Edition，我们经常说到的JDK，就主要指的这个，它是三者的基础，属于桌面级应用开发，这部分如果学得好很容易拓展J2EE和J2ME。\nJ2EE，Java 2 Platform，Enterprise Edition，就是所谓的企业级Java，适合企业的大型应用开发。\nJ2ME，The Micro Edition of the Java 2 Platform。主要用于嵌入式Java，如手机，PDA等等。\n\n## J2SE\n新手最初学习的时候先要从J2SE开始学起，所包含的内容主要分为：面向对象概念的理解、Java基本语法的学习，Java桌面图形界面应用程序的开发，掌握常用的Java API等（关键是要学会怎样查阅）。 \n- 重点：Java基本语法（循环结构，数据类型，数组，运算符等）、Swing，awt，事件机制、文件输入输出流处理等\n- 难点：面向对象思想的理解（接口、类等）、线程、socket网络编程等\n\n## J2EE \n在学习了J2SE之后，你可以尝试着慢慢过渡到J2EE，当然，学习J2EE海需要很多非JAVA技术的支撑，比如数据库技术，网页编程技术等等，待会我会详细介绍这两方面的内容。J2EE有三个必学的框架，如果你说你学了J2EE，但又不会这三个框架的话，那会让人笑掉大牙，这三个框架分别是Struts、Spring和Hibernate，虽然这三个框架应用很广，但不代表这三个框架就代表了J2EE，J2EE还有很多其他的东西，比如EJB，作为一款重量级（此重量级不是指重量级选手那个意思，此重量级非彼重量级）框架，虽然这个应用慢慢的再被其他框架所取代，但EJB3.0的出现也给它带回一些生机，作为一个分布式应用的框架，也是大家要去学习和了解的知识。 \n当然，刚才说到J2EE包含的范围很广，即使我把我所了解的所有技术说出来，也并不能代表J2EE，这是一个很深很广的学问，需要大家以后再工作的时候慢慢去发现了。我所了解的还包括： \n- JDBC:Java数据库连接对象，基础中的基础，Hibernate也只是对它的封装而已 \n- JNDI: Java 命名与目录接口，J2EE重要规范之一 \n- EJBS: 上面已经提到过了 \n- RMI: 提供远程调用方法的支持，主要用于程序分布式开发 \n- JMS: Java消息服务，中间件技术 \n- JAVA IDL: 提供J2EE平台与CORBA交互能力和互联能力的技术 \n- JTS: 组件事务监视器 \n- JTA: 事务划分的一个技术 \n- JAVAMAIL: Java中的邮件技术 \n- JAF: Java启动框架,没研究过 \n- Log4j，一款日志处理的框架应用 \n- Junit：单元测试的好帮手 \n- freemarker、velocity：两款不错的模板引擎 \n- 与Flash的交互Flex：目前很多的SNS应用就是使用到了这个技术 \n- Web services:想知道我们论坛天气预报的效果是怎么做的吗？请关注这个技术 \n- SOA:面向服务架构，未来技术发展的趋势之一 \n…… \n不过前面介绍到得这些都不是J2EE的基础,是属于框架应用级别的.要真正把上面说到的知识掌握好,还是的学习J2EE最核心的东西:JDBC、JSP、servlet和JavaBean,后面三个也是学习SSH的基础(Struts/Spring/Hibernate的简称).鉴于J2EE的内容太过复杂,建议大家最初只学习: JSP, servlet和JavaBean，等这个基础掌握好再把SSH学习了，再对其他J2EE技术有个大致的了解就可以出去找工作了。当然，找工作的前提除了把Java学习好，还会有一些其他的技术也是必须要掌握的。\n\n-_- 我很简单,Java却要求我学这么多复杂的东西。除了这些技术的东西，在这阶段，大家更多的是会接触到比如设计模式的东西，比如工厂模式、桥梁模式、单例模式等等，还要学习建模思想（比如UML建模等等）和软件生命周期等等。这些是升华大家编程思想的手段和途径。\n\n## J2ME \n如果你在学习了以上技术还不过瘾，可以再学习手机程序的开发，就我个人看来，开发手机程序技术其实蛮简单的，难点在于优化，比如怎么让你写的程序尽量的节约手机资源，“代码诚可贵，手机价更高“，所以不得不比PC机多考虑很多成本和实用性问题。J2ME的学习的话，切忌不要单纯的再模拟器上测试，一定要找真机测试，真机和模拟器的效果之间差别是很大的。","slug":"Java学习路线","published":1,"updated":"2025-03-07T13:26:47.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz260008rz5m16dv64ho","content":"<p>Java学习路线</p>\n<span id=\"more\"></span>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>怎么学习Java，这是很多新手经常遇到的问题，现在我简单描述下一个Java初学者到就业要学到的一些东西：<br>首先要明白Java体系设计到得三个方面：<code>J2SE</code>,<code>J2EE</code>,<code>J2ME（KJAVA）</code>。<br>J2SE，Java 2 Platform Standard Edition，我们经常说到的JDK，就主要指的这个，它是三者的基础，属于桌面级应用开发，这部分如果学得好很容易拓展J2EE和J2ME。<br>J2EE，Java 2 Platform，Enterprise Edition，就是所谓的企业级Java，适合企业的大型应用开发。<br>J2ME，The Micro Edition of the Java 2 Platform。主要用于嵌入式Java，如手机，PDA等等。</p>\n<h2 id=\"J2SE\"><a href=\"#J2SE\" class=\"headerlink\" title=\"J2SE\"></a>J2SE</h2><p>新手最初学习的时候先要从J2SE开始学起，所包含的内容主要分为：面向对象概念的理解、Java基本语法的学习，Java桌面图形界面应用程序的开发，掌握常用的Java API等（关键是要学会怎样查阅）。 </p>\n<ul>\n<li>重点：Java基本语法（循环结构，数据类型，数组，运算符等）、Swing，awt，事件机制、文件输入输出流处理等</li>\n<li>难点：面向对象思想的理解（接口、类等）、线程、socket网络编程等</li>\n</ul>\n<h2 id=\"J2EE\"><a href=\"#J2EE\" class=\"headerlink\" title=\"J2EE\"></a>J2EE</h2><p>在学习了J2SE之后，你可以尝试着慢慢过渡到J2EE，当然，学习J2EE海需要很多非JAVA技术的支撑，比如数据库技术，网页编程技术等等，待会我会详细介绍这两方面的内容。J2EE有三个必学的框架，如果你说你学了J2EE，但又不会这三个框架的话，那会让人笑掉大牙，这三个框架分别是Struts、Spring和Hibernate，虽然这三个框架应用很广，但不代表这三个框架就代表了J2EE，J2EE还有很多其他的东西，比如EJB，作为一款重量级（此重量级不是指重量级选手那个意思，此重量级非彼重量级）框架，虽然这个应用慢慢的再被其他框架所取代，但EJB3.0的出现也给它带回一些生机，作为一个分布式应用的框架，也是大家要去学习和了解的知识。<br>当然，刚才说到J2EE包含的范围很广，即使我把我所了解的所有技术说出来，也并不能代表J2EE，这是一个很深很广的学问，需要大家以后再工作的时候慢慢去发现了。我所了解的还包括： </p>\n<ul>\n<li>JDBC:Java数据库连接对象，基础中的基础，Hibernate也只是对它的封装而已 </li>\n<li>JNDI: Java 命名与目录接口，J2EE重要规范之一 </li>\n<li>EJBS: 上面已经提到过了 </li>\n<li>RMI: 提供远程调用方法的支持，主要用于程序分布式开发 </li>\n<li>JMS: Java消息服务，中间件技术 </li>\n<li>JAVA IDL: 提供J2EE平台与CORBA交互能力和互联能力的技术 </li>\n<li>JTS: 组件事务监视器 </li>\n<li>JTA: 事务划分的一个技术 </li>\n<li>JAVAMAIL: Java中的邮件技术 </li>\n<li>JAF: Java启动框架,没研究过 </li>\n<li>Log4j，一款日志处理的框架应用 </li>\n<li>Junit：单元测试的好帮手 </li>\n<li>freemarker、velocity：两款不错的模板引擎 </li>\n<li>与Flash的交互Flex：目前很多的SNS应用就是使用到了这个技术 </li>\n<li>Web services:想知道我们论坛天气预报的效果是怎么做的吗？请关注这个技术 </li>\n<li>SOA:面向服务架构，未来技术发展的趋势之一<br>……<br>不过前面介绍到得这些都不是J2EE的基础,是属于框架应用级别的.要真正把上面说到的知识掌握好,还是的学习J2EE最核心的东西:JDBC、JSP、servlet和JavaBean,后面三个也是学习SSH的基础(Struts&#x2F;Spring&#x2F;Hibernate的简称).鉴于J2EE的内容太过复杂,建议大家最初只学习: JSP, servlet和JavaBean，等这个基础掌握好再把SSH学习了，再对其他J2EE技术有个大致的了解就可以出去找工作了。当然，找工作的前提除了把Java学习好，还会有一些其他的技术也是必须要掌握的。</li>\n</ul>\n<p>-_- 我很简单,Java却要求我学这么多复杂的东西。除了这些技术的东西，在这阶段，大家更多的是会接触到比如设计模式的东西，比如工厂模式、桥梁模式、单例模式等等，还要学习建模思想（比如UML建模等等）和软件生命周期等等。这些是升华大家编程思想的手段和途径。</p>\n<h2 id=\"J2ME\"><a href=\"#J2ME\" class=\"headerlink\" title=\"J2ME\"></a>J2ME</h2><p>如果你在学习了以上技术还不过瘾，可以再学习手机程序的开发，就我个人看来，开发手机程序技术其实蛮简单的，难点在于优化，比如怎么让你写的程序尽量的节约手机资源，“代码诚可贵，手机价更高“，所以不得不比PC机多考虑很多成本和实用性问题。J2ME的学习的话，切忌不要单纯的再模拟器上测试，一定要找真机测试，真机和模拟器的效果之间差别是很大的。</p>\n","site":{"data":{}},"excerpt":"<p>Java学习路线</p>","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>怎么学习Java，这是很多新手经常遇到的问题，现在我简单描述下一个Java初学者到就业要学到的一些东西：<br>首先要明白Java体系设计到得三个方面：<code>J2SE</code>,<code>J2EE</code>,<code>J2ME（KJAVA）</code>。<br>J2SE，Java 2 Platform Standard Edition，我们经常说到的JDK，就主要指的这个，它是三者的基础，属于桌面级应用开发，这部分如果学得好很容易拓展J2EE和J2ME。<br>J2EE，Java 2 Platform，Enterprise Edition，就是所谓的企业级Java，适合企业的大型应用开发。<br>J2ME，The Micro Edition of the Java 2 Platform。主要用于嵌入式Java，如手机，PDA等等。</p>\n<h2 id=\"J2SE\"><a href=\"#J2SE\" class=\"headerlink\" title=\"J2SE\"></a>J2SE</h2><p>新手最初学习的时候先要从J2SE开始学起，所包含的内容主要分为：面向对象概念的理解、Java基本语法的学习，Java桌面图形界面应用程序的开发，掌握常用的Java API等（关键是要学会怎样查阅）。 </p>\n<ul>\n<li>重点：Java基本语法（循环结构，数据类型，数组，运算符等）、Swing，awt，事件机制、文件输入输出流处理等</li>\n<li>难点：面向对象思想的理解（接口、类等）、线程、socket网络编程等</li>\n</ul>\n<h2 id=\"J2EE\"><a href=\"#J2EE\" class=\"headerlink\" title=\"J2EE\"></a>J2EE</h2><p>在学习了J2SE之后，你可以尝试着慢慢过渡到J2EE，当然，学习J2EE海需要很多非JAVA技术的支撑，比如数据库技术，网页编程技术等等，待会我会详细介绍这两方面的内容。J2EE有三个必学的框架，如果你说你学了J2EE，但又不会这三个框架的话，那会让人笑掉大牙，这三个框架分别是Struts、Spring和Hibernate，虽然这三个框架应用很广，但不代表这三个框架就代表了J2EE，J2EE还有很多其他的东西，比如EJB，作为一款重量级（此重量级不是指重量级选手那个意思，此重量级非彼重量级）框架，虽然这个应用慢慢的再被其他框架所取代，但EJB3.0的出现也给它带回一些生机，作为一个分布式应用的框架，也是大家要去学习和了解的知识。<br>当然，刚才说到J2EE包含的范围很广，即使我把我所了解的所有技术说出来，也并不能代表J2EE，这是一个很深很广的学问，需要大家以后再工作的时候慢慢去发现了。我所了解的还包括： </p>\n<ul>\n<li>JDBC:Java数据库连接对象，基础中的基础，Hibernate也只是对它的封装而已 </li>\n<li>JNDI: Java 命名与目录接口，J2EE重要规范之一 </li>\n<li>EJBS: 上面已经提到过了 </li>\n<li>RMI: 提供远程调用方法的支持，主要用于程序分布式开发 </li>\n<li>JMS: Java消息服务，中间件技术 </li>\n<li>JAVA IDL: 提供J2EE平台与CORBA交互能力和互联能力的技术 </li>\n<li>JTS: 组件事务监视器 </li>\n<li>JTA: 事务划分的一个技术 </li>\n<li>JAVAMAIL: Java中的邮件技术 </li>\n<li>JAF: Java启动框架,没研究过 </li>\n<li>Log4j，一款日志处理的框架应用 </li>\n<li>Junit：单元测试的好帮手 </li>\n<li>freemarker、velocity：两款不错的模板引擎 </li>\n<li>与Flash的交互Flex：目前很多的SNS应用就是使用到了这个技术 </li>\n<li>Web services:想知道我们论坛天气预报的效果是怎么做的吗？请关注这个技术 </li>\n<li>SOA:面向服务架构，未来技术发展的趋势之一<br>……<br>不过前面介绍到得这些都不是J2EE的基础,是属于框架应用级别的.要真正把上面说到的知识掌握好,还是的学习J2EE最核心的东西:JDBC、JSP、servlet和JavaBean,后面三个也是学习SSH的基础(Struts&#x2F;Spring&#x2F;Hibernate的简称).鉴于J2EE的内容太过复杂,建议大家最初只学习: JSP, servlet和JavaBean，等这个基础掌握好再把SSH学习了，再对其他J2EE技术有个大致的了解就可以出去找工作了。当然，找工作的前提除了把Java学习好，还会有一些其他的技术也是必须要掌握的。</li>\n</ul>\n<p>-_- 我很简单,Java却要求我学这么多复杂的东西。除了这些技术的东西，在这阶段，大家更多的是会接触到比如设计模式的东西，比如工厂模式、桥梁模式、单例模式等等，还要学习建模思想（比如UML建模等等）和软件生命周期等等。这些是升华大家编程思想的手段和途径。</p>\n<h2 id=\"J2ME\"><a href=\"#J2ME\" class=\"headerlink\" title=\"J2ME\"></a>J2ME</h2><p>如果你在学习了以上技术还不过瘾，可以再学习手机程序的开发，就我个人看来，开发手机程序技术其实蛮简单的，难点在于优化，比如怎么让你写的程序尽量的节约手机资源，“代码诚可贵，手机价更高“，所以不得不比PC机多考虑很多成本和实用性问题。J2ME的学习的话，切忌不要单纯的再模拟器上测试，一定要找真机测试，真机和模拟器的效果之间差别是很大的。</p>"},{"title":"Java文件上传分析","date":"2017-08-03T15:55:04.000Z","type":"tags","_content":"只要做过java web的人一定都接触过文件上传，但是中间或多或者肯定遇到过问题，那么下面就来分析下文件上传中遇到的各种坑～\n<!--more-->\n##struts2表单上传文件\nstruts是通过默认拦截器实现的：\n```xml\n<interceptor name=\"fileUpload\" class=\"org.apache.struts2.interceptor.FileUploadInterceptor\"/>\n```\nstruts上传文件大小默认最大为2M（default.properties）：\n```properties\nstruts.multipart.maxSize=2097152\n```\n当然我们也可以自定义设置（struts.properties）：\n```properties\nstruts.multipart.maxSize=209715200\n```\n也可以在xml进行配置：\n```xml\n<constant name=\"struts.multipart.maxSize\" value=\"209715200\">\n</constant>\n```\n前端实现：\n```html\n<form action=\"xxx\" enctype=\"multipart/form-data\" method=\"post\">\n...\n</form>\n```\n后台action实现：\n```java\nprivate File file;\nprivate String fileFileName;\nprivate String fileContentType\n```\n后台通过这样的写法，struts框架会自动赋值给这三个属性\n##spring  mvc表单上传文件\n前端同上\n后台实现：\n```java\nprivate MultiFile file;\n```\n上述两种都是通过form表单提交的，那么如何通过ajax直接上传文件呢？\n##spring mvc+ajax上传文件\n后台实现同上，但是如果不另加配置，则直接报415错误，需要加如下配置：\n```xml\n<bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n    <property name=\"messageConverters\">\n        <list>\n            <ref bean=\"byteArrayConverter\" />\n        </list>\n    </property>\n</bean>\n<bean id=\"byteArrayConverter\" class=\"org.springframework.http.converter.ByteArrayHttpMessageConverter\">\n</bean>\n```\n进一步联想，上传文件是不是只能是`post`方法呢？\n我们知道，浏览器是不支持RESTful风格中put和delete的\n通过测试，使用put提交，直接报415错误，通过源码（org.springframework.web.filter.HiddenHttpMethodFilter）可以看到：\n```java\n@Override\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n    HttpServletRequest requestToUse = request;\n    if (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t   String paramValue = request.getParameter(this.methodParam);\n\t   if (StringUtils.hasLength(paramValue)) {\n\t       requestToUse = new HttpMethodRequestWrapper(request, paramValue);\n\t   }\n    }\n    filterChain.doFilter(requestToUse, response);\n}\n```\n从源码可以看出，filter中限制了只能用POST方法提交，那么如果一定要用PUT方法进行上传文件呢？\n看了下HiddenHttpMethodFilter注释：\n```java\n/**\n * {@link javax.servlet.Filter} that converts posted method parameters into HTTP methods,\n * retrievable via {@link HttpServletRequest#getMethod()}. Since browsers currently only\n * support GET and POST, a common technique - used by the Prototype library, for instance -\n * is to use a normal POST with an additional hidden form field ({@code _method})\n * to pass the \"real\" HTTP method along. This filter reads that parameter and changes\n * the {@link HttpServletRequestWrapper#getMethod()} return value accordingly.\n *\n * <p>The name of the request parameter defaults to {@code _method}, but can be\n * adapted via the {@link #setMethodParam(String) methodParam} property.\n *\n * <p><b>NOTE: This filter needs to run after multipart processing in case of a multipart\n * POST request, due to its inherent need for checking a POST body parameter.</b>\n * So typically, put a Spring {@link org.springframework.web.multipart.support.MultipartFilter}\n * <i>before</i> this HiddenHttpMethodFilter in your {@code web.xml} filter chain.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n */\n```\nMultipartFileter：\n```java\n/**\n* Set the bean name of the MultipartResolver to fetch from Spring's\n* root application context. Default is \"filterMultipartResolver\".\n*/\npublic void setMultipartResolverBeanName(String multipartResolverBeanName) {\n    this.multipartResolverBeanName = multipartResolverBeanName;\n}\n```\n也就是说，我们可以通过在web.xml中注册一个MultipartFilter，一定要在HiddenHttpMethodFilter之前启动，这样的话就能实现\n```xml\n<filter>\n    <filter-name>MultipartFilter</filter-name>\n    <filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>MultipartFilter</filter-name>\n    <servlet-name>dispatcher</servlet-name>\n</filter-mapping>\n\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n```\n同时配置：\n```xml\n<bean id=\"filterMultipartResolver\"\nclass=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n    <property name=\"maxUploadSize\" value=\"209715200\"/>\n    <property name=\"defaultEncoding\" value=\"UTF-8\"/>\n    <property name=\"resolveLazily\" value=\"true\"/>\n</bean>\n```\n前端：\n```javascript\nfunction upload() {\n    var form = new FormData(document.getElementById(\"xx\"));\n    form.append(\"_method\", 'put');\n    $.ajax({\n        url: url,\n        type: 'post',\n        data: form,\n        processData: false,\n        contentType: false,\n        success: function (data) {\n            ...\n        },\n        error: function (e) {\n            ...\n        }\n    });\n    ...\n}\n```\n通过java文件上传分析，可以得出，框架为我们做了很多默认配置，为我们省去了很多工作，当然，也有限制，如果我们想挣脱限制，就要找准入口～\n\n参考：\n[SpringMVC实现RESTful带有文件上传的put](http://www.cnblogs.com/morethink/p/6378015.html)\n","source":"_posts/Java文件上传分析.md","raw":"title: Java文件上传分析\ndate: 2017-08-03 23:55:04\ntype: \"tags\"\ntags:\n- Java\n---\n只要做过java web的人一定都接触过文件上传，但是中间或多或者肯定遇到过问题，那么下面就来分析下文件上传中遇到的各种坑～\n<!--more-->\n##struts2表单上传文件\nstruts是通过默认拦截器实现的：\n```xml\n<interceptor name=\"fileUpload\" class=\"org.apache.struts2.interceptor.FileUploadInterceptor\"/>\n```\nstruts上传文件大小默认最大为2M（default.properties）：\n```properties\nstruts.multipart.maxSize=2097152\n```\n当然我们也可以自定义设置（struts.properties）：\n```properties\nstruts.multipart.maxSize=209715200\n```\n也可以在xml进行配置：\n```xml\n<constant name=\"struts.multipart.maxSize\" value=\"209715200\">\n</constant>\n```\n前端实现：\n```html\n<form action=\"xxx\" enctype=\"multipart/form-data\" method=\"post\">\n...\n</form>\n```\n后台action实现：\n```java\nprivate File file;\nprivate String fileFileName;\nprivate String fileContentType\n```\n后台通过这样的写法，struts框架会自动赋值给这三个属性\n##spring  mvc表单上传文件\n前端同上\n后台实现：\n```java\nprivate MultiFile file;\n```\n上述两种都是通过form表单提交的，那么如何通过ajax直接上传文件呢？\n##spring mvc+ajax上传文件\n后台实现同上，但是如果不另加配置，则直接报415错误，需要加如下配置：\n```xml\n<bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\">\n    <property name=\"messageConverters\">\n        <list>\n            <ref bean=\"byteArrayConverter\" />\n        </list>\n    </property>\n</bean>\n<bean id=\"byteArrayConverter\" class=\"org.springframework.http.converter.ByteArrayHttpMessageConverter\">\n</bean>\n```\n进一步联想，上传文件是不是只能是`post`方法呢？\n我们知道，浏览器是不支持RESTful风格中put和delete的\n通过测试，使用put提交，直接报415错误，通过源码（org.springframework.web.filter.HiddenHttpMethodFilter）可以看到：\n```java\n@Override\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n    HttpServletRequest requestToUse = request;\n    if (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n\t   String paramValue = request.getParameter(this.methodParam);\n\t   if (StringUtils.hasLength(paramValue)) {\n\t       requestToUse = new HttpMethodRequestWrapper(request, paramValue);\n\t   }\n    }\n    filterChain.doFilter(requestToUse, response);\n}\n```\n从源码可以看出，filter中限制了只能用POST方法提交，那么如果一定要用PUT方法进行上传文件呢？\n看了下HiddenHttpMethodFilter注释：\n```java\n/**\n * {@link javax.servlet.Filter} that converts posted method parameters into HTTP methods,\n * retrievable via {@link HttpServletRequest#getMethod()}. Since browsers currently only\n * support GET and POST, a common technique - used by the Prototype library, for instance -\n * is to use a normal POST with an additional hidden form field ({@code _method})\n * to pass the \"real\" HTTP method along. This filter reads that parameter and changes\n * the {@link HttpServletRequestWrapper#getMethod()} return value accordingly.\n *\n * <p>The name of the request parameter defaults to {@code _method}, but can be\n * adapted via the {@link #setMethodParam(String) methodParam} property.\n *\n * <p><b>NOTE: This filter needs to run after multipart processing in case of a multipart\n * POST request, due to its inherent need for checking a POST body parameter.</b>\n * So typically, put a Spring {@link org.springframework.web.multipart.support.MultipartFilter}\n * <i>before</i> this HiddenHttpMethodFilter in your {@code web.xml} filter chain.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n */\n```\nMultipartFileter：\n```java\n/**\n* Set the bean name of the MultipartResolver to fetch from Spring's\n* root application context. Default is \"filterMultipartResolver\".\n*/\npublic void setMultipartResolverBeanName(String multipartResolverBeanName) {\n    this.multipartResolverBeanName = multipartResolverBeanName;\n}\n```\n也就是说，我们可以通过在web.xml中注册一个MultipartFilter，一定要在HiddenHttpMethodFilter之前启动，这样的话就能实现\n```xml\n<filter>\n    <filter-name>MultipartFilter</filter-name>\n    <filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>MultipartFilter</filter-name>\n    <servlet-name>dispatcher</servlet-name>\n</filter-mapping>\n\n<filter>\n    <filter-name>HiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n```\n同时配置：\n```xml\n<bean id=\"filterMultipartResolver\"\nclass=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n    <property name=\"maxUploadSize\" value=\"209715200\"/>\n    <property name=\"defaultEncoding\" value=\"UTF-8\"/>\n    <property name=\"resolveLazily\" value=\"true\"/>\n</bean>\n```\n前端：\n```javascript\nfunction upload() {\n    var form = new FormData(document.getElementById(\"xx\"));\n    form.append(\"_method\", 'put');\n    $.ajax({\n        url: url,\n        type: 'post',\n        data: form,\n        processData: false,\n        contentType: false,\n        success: function (data) {\n            ...\n        },\n        error: function (e) {\n            ...\n        }\n    });\n    ...\n}\n```\n通过java文件上传分析，可以得出，框架为我们做了很多默认配置，为我们省去了很多工作，当然，也有限制，如果我们想挣脱限制，就要找准入口～\n\n参考：\n[SpringMVC实现RESTful带有文件上传的put](http://www.cnblogs.com/morethink/p/6378015.html)\n","slug":"Java文件上传分析","published":1,"updated":"2025-03-07T13:26:47.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz270009rz5m6ztfdrcp","content":"<p>只要做过java web的人一定都接触过文件上传，但是中间或多或者肯定遇到过问题，那么下面就来分析下文件上传中遇到的各种坑～</p>\n<span id=\"more\"></span>\n<p>##struts2表单上传文件<br>struts是通过默认拦截器实现的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">interceptor</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fileUpload&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.struts2.interceptor.FileUploadInterceptor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>struts上传文件大小默认最大为2M（default.properties）：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">struts.multipart.maxSize</span>=<span class=\"string\">2097152</span></span><br></pre></td></tr></table></figure>\n<p>当然我们也可以自定义设置（struts.properties）：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">struts.multipart.maxSize</span>=<span class=\"string\">209715200</span></span><br></pre></td></tr></table></figure>\n<p>也可以在xml进行配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;struts.multipart.maxSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;209715200&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">constant</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>前端实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;xxx&quot;</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&quot;multipart/form-data&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>后台action实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> File file;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String fileFileName;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String fileContentType</span><br></pre></td></tr></table></figure>\n<p>后台通过这样的写法，struts框架会自动赋值给这三个属性<br>##spring  mvc表单上传文件<br>前端同上<br>后台实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MultiFile file;</span><br></pre></td></tr></table></figure>\n<p>上述两种都是通过form表单提交的，那么如何通过ajax直接上传文件呢？<br>##spring mvc+ajax上传文件<br>后台实现同上，但是如果不另加配置，则直接报415错误，需要加如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;byteArrayConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;byteArrayConverter&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进一步联想，上传文件是不是只能是<code>post</code>方法呢？<br>我们知道，浏览器是不支持RESTful风格中put和delete的<br>通过测试，使用put提交，直接报415错误，通过源码（org.springframework.web.filter.HiddenHttpMethodFilter）可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFilterInternal</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">requestToUse</span> <span class=\"operator\">=</span> request;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t   <span class=\"type\">String</span> <span class=\"variable\">paramValue</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"built_in\">this</span>.methodParam);</span><br><span class=\"line\">\t   <span class=\"keyword\">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class=\"line\">\t       requestToUse = <span class=\"keyword\">new</span> <span class=\"title class_\">HttpMethodRequestWrapper</span>(request, paramValue);</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    filterChain.doFilter(requestToUse, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，filter中限制了只能用POST方法提交，那么如果一定要用PUT方法进行上传文件呢？<br>看了下HiddenHttpMethodFilter注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> javax.servlet.Filter&#125; that converts posted method parameters into HTTP methods,</span></span><br><span class=\"line\"><span class=\"comment\"> * retrievable via &#123;<span class=\"doctag\">@link</span> HttpServletRequest#getMethod()&#125;. Since browsers currently only</span></span><br><span class=\"line\"><span class=\"comment\"> * support GET and POST, a common technique - used by the Prototype library, for instance -</span></span><br><span class=\"line\"><span class=\"comment\"> * is to use a normal POST with an additional hidden form field (&#123;<span class=\"doctag\">@code</span> _method&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"> * to pass the &quot;real&quot; HTTP method along. This filter reads that parameter and changes</span></span><br><span class=\"line\"><span class=\"comment\"> * the &#123;<span class=\"doctag\">@link</span> HttpServletRequestWrapper#getMethod()&#125; return value accordingly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;The name of the request parameter defaults to &#123;<span class=\"doctag\">@code</span> _method&#125;, but can be</span></span><br><span class=\"line\"><span class=\"comment\"> * adapted via the &#123;<span class=\"doctag\">@link</span> #setMethodParam(String) methodParam&#125; property.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;&lt;b&gt;<span class=\"doctag\">NOTE:</span> This filter needs to run after multipart processing in case of a multipart</span></span><br><span class=\"line\"><span class=\"comment\"> * POST request, due to its inherent need for checking a POST body parameter.&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * So typically, put a Spring &#123;<span class=\"doctag\">@link</span> org.springframework.web.multipart.support.MultipartFilter&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;i&gt;before&lt;/i&gt; this HiddenHttpMethodFilter in your &#123;<span class=\"doctag\">@code</span> web.xml&#125; filter chain.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Arjen Poutsma</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 3.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>MultipartFileter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the bean name of the MultipartResolver to fetch from Spring&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\">* root application context. Default is &quot;filterMultipartResolver&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMultipartResolverBeanName</span><span class=\"params\">(String multipartResolverBeanName)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.multipartResolverBeanName = multipartResolverBeanName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，我们可以通过在web.xml中注册一个MultipartFilter，一定要在HiddenHttpMethodFilter之前启动，这样的话就能实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.multipart.support.MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>同时配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;filterMultipartResolver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxUploadSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;209715200&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;defaultEncoding&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;resolveLazily&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>前端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">upload</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;xx&quot;</span>));</span><br><span class=\"line\">    form.<span class=\"title function_\">append</span>(<span class=\"string\">&quot;_method&quot;</span>, <span class=\"string\">&#x27;put&#x27;</span>);</span><br><span class=\"line\">    $.<span class=\"title function_\">ajax</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">url</span>: url,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;post&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">data</span>: form,</span><br><span class=\"line\">        <span class=\"attr\">processData</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">contentType</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过java文件上传分析，可以得出，框架为我们做了很多默认配置，为我们省去了很多工作，当然，也有限制，如果我们想挣脱限制，就要找准入口～</p>\n<p>参考：<br><a href=\"http://www.cnblogs.com/morethink/p/6378015.html\">SpringMVC实现RESTful带有文件上传的put</a></p>\n","site":{"data":{}},"excerpt":"<p>只要做过java web的人一定都接触过文件上传，但是中间或多或者肯定遇到过问题，那么下面就来分析下文件上传中遇到的各种坑～</p>","more":"<p>##struts2表单上传文件<br>struts是通过默认拦截器实现的：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">interceptor</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fileUpload&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.struts2.interceptor.FileUploadInterceptor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>struts上传文件大小默认最大为2M（default.properties）：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">struts.multipart.maxSize</span>=<span class=\"string\">2097152</span></span><br></pre></td></tr></table></figure>\n<p>当然我们也可以自定义设置（struts.properties）：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">struts.multipart.maxSize</span>=<span class=\"string\">209715200</span></span><br></pre></td></tr></table></figure>\n<p>也可以在xml进行配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">constant</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;struts.multipart.maxSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;209715200&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">constant</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>前端实现：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;xxx&quot;</span> <span class=\"attr\">enctype</span>=<span class=\"string\">&quot;multipart/form-data&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>后台action实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> File file;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String fileFileName;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String fileContentType</span><br></pre></td></tr></table></figure>\n<p>后台通过这样的写法，struts框架会自动赋值给这三个属性<br>##spring  mvc表单上传文件<br>前端同上<br>后台实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> MultiFile file;</span><br></pre></td></tr></table></figure>\n<p>上述两种都是通过form表单提交的，那么如何通过ajax直接上传文件呢？<br>##spring mvc+ajax上传文件<br>后台实现同上，但是如果不另加配置，则直接报415错误，需要加如下配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;byteArrayConverter&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;byteArrayConverter&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.http.converter.ByteArrayHttpMessageConverter&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进一步联想，上传文件是不是只能是<code>post</code>方法呢？<br>我们知道，浏览器是不支持RESTful风格中put和delete的<br>通过测试，使用put提交，直接报415错误，通过源码（org.springframework.web.filter.HiddenHttpMethodFilter）可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doFilterInternal</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">HttpServletRequest</span> <span class=\"variable\">requestToUse</span> <span class=\"operator\">=</span> request;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t   <span class=\"type\">String</span> <span class=\"variable\">paramValue</span> <span class=\"operator\">=</span> request.getParameter(<span class=\"built_in\">this</span>.methodParam);</span><br><span class=\"line\">\t   <span class=\"keyword\">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class=\"line\">\t       requestToUse = <span class=\"keyword\">new</span> <span class=\"title class_\">HttpMethodRequestWrapper</span>(request, paramValue);</span><br><span class=\"line\">\t   &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    filterChain.doFilter(requestToUse, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码可以看出，filter中限制了只能用POST方法提交，那么如果一定要用PUT方法进行上传文件呢？<br>看了下HiddenHttpMethodFilter注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> javax.servlet.Filter&#125; that converts posted method parameters into HTTP methods,</span></span><br><span class=\"line\"><span class=\"comment\"> * retrievable via &#123;<span class=\"doctag\">@link</span> HttpServletRequest#getMethod()&#125;. Since browsers currently only</span></span><br><span class=\"line\"><span class=\"comment\"> * support GET and POST, a common technique - used by the Prototype library, for instance -</span></span><br><span class=\"line\"><span class=\"comment\"> * is to use a normal POST with an additional hidden form field (&#123;<span class=\"doctag\">@code</span> _method&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"> * to pass the &quot;real&quot; HTTP method along. This filter reads that parameter and changes</span></span><br><span class=\"line\"><span class=\"comment\"> * the &#123;<span class=\"doctag\">@link</span> HttpServletRequestWrapper#getMethod()&#125; return value accordingly.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;The name of the request parameter defaults to &#123;<span class=\"doctag\">@code</span> _method&#125;, but can be</span></span><br><span class=\"line\"><span class=\"comment\"> * adapted via the &#123;<span class=\"doctag\">@link</span> #setMethodParam(String) methodParam&#125; property.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;&lt;b&gt;<span class=\"doctag\">NOTE:</span> This filter needs to run after multipart processing in case of a multipart</span></span><br><span class=\"line\"><span class=\"comment\"> * POST request, due to its inherent need for checking a POST body parameter.&lt;/b&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * So typically, put a Spring &#123;<span class=\"doctag\">@link</span> org.springframework.web.multipart.support.MultipartFilter&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;i&gt;before&lt;/i&gt; this HiddenHttpMethodFilter in your &#123;<span class=\"doctag\">@code</span> web.xml&#125; filter chain.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Arjen Poutsma</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 3.0</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<p>MultipartFileter：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Set the bean name of the MultipartResolver to fetch from Spring&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\">* root application context. Default is &quot;filterMultipartResolver&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMultipartResolverBeanName</span><span class=\"params\">(String multipartResolverBeanName)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.multipartResolverBeanName = multipartResolverBeanName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，我们可以通过在web.xml中注册一个MultipartFilter，一定要在HiddenHttpMethodFilter之前启动，这样的话就能实现</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.multipart.support.MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>MultipartFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>同时配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;filterMultipartResolver&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxUploadSize&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;209715200&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;defaultEncoding&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;resolveLazily&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>前端：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">upload</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;xx&quot;</span>));</span><br><span class=\"line\">    form.<span class=\"title function_\">append</span>(<span class=\"string\">&quot;_method&quot;</span>, <span class=\"string\">&#x27;put&#x27;</span>);</span><br><span class=\"line\">    $.<span class=\"title function_\">ajax</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">url</span>: url,</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&#x27;post&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">data</span>: form,</span><br><span class=\"line\">        <span class=\"attr\">processData</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">contentType</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">error</span>: <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过java文件上传分析，可以得出，框架为我们做了很多默认配置，为我们省去了很多工作，当然，也有限制，如果我们想挣脱限制，就要找准入口～</p>\n<p>参考：<br><a href=\"http://www.cnblogs.com/morethink/p/6378015.html\">SpringMVC实现RESTful带有文件上传的put</a></p>"},{"title":"Mac OS安装软件时提示 “安装”已损坏，打不开 你应该推出磁盘映像的解决方法","date":"2017-08-02T17:03:38.000Z","type":"categories","_content":"Mac OS安装软件时提示：“安装”已损坏，打不开。你应该推出磁盘映像。\n<!--more-->\n相信很多朋友都有遇到过软件安装时提示，安装已损坏的情况。\n\n其实，并不是安装包（.dmg）损坏，其实是系统不信任未知来源的软件，之前低版本的系统中，设置->安全性与隐私->允许从以下位置下载的应用选项中，有三项，分别是App Store/App Store和被认可的开发者／任何来源，但是最新的系统中默认是没有这个选项的，那么：\n\nmacOS Sierra要先将隐藏的任意来源功能找出来，首先打开终端(找不到哪里打开终端?试试command+空格 搜索 “终端” 程序就会打开了，然后输入下面这串代码：\n```shell\nsudo spctl --master-disable\n```\n然后输入管理员密码，输入正确后，那么任何来源的选项就会出现了，选择任何来源，再次安装软件，就不会报错啦～","source":"_posts/Mac-OS安装软件时提示-“安装”已损坏，打不开-你应该推出磁盘映像的解决方法.md","raw":"title: Mac OS安装软件时提示 “安装”已损坏，打不开 你应该推出磁盘映像的解决方法\ndate: 2017-08-03 01:03:38\ntype: \"categories\"\ncategories: Mac\ntags:\n- Mac\n---\nMac OS安装软件时提示：“安装”已损坏，打不开。你应该推出磁盘映像。\n<!--more-->\n相信很多朋友都有遇到过软件安装时提示，安装已损坏的情况。\n\n其实，并不是安装包（.dmg）损坏，其实是系统不信任未知来源的软件，之前低版本的系统中，设置->安全性与隐私->允许从以下位置下载的应用选项中，有三项，分别是App Store/App Store和被认可的开发者／任何来源，但是最新的系统中默认是没有这个选项的，那么：\n\nmacOS Sierra要先将隐藏的任意来源功能找出来，首先打开终端(找不到哪里打开终端?试试command+空格 搜索 “终端” 程序就会打开了，然后输入下面这串代码：\n```shell\nsudo spctl --master-disable\n```\n然后输入管理员密码，输入正确后，那么任何来源的选项就会出现了，选择任何来源，再次安装软件，就不会报错啦～","slug":"Mac-OS安装软件时提示-“安装”已损坏，打不开-你应该推出磁盘映像的解决方法","published":1,"updated":"2025-03-07T13:26:47.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz28000drz5mez43cfjq","content":"<p>Mac OS安装软件时提示：“安装”已损坏，打不开。你应该推出磁盘映像。</p>\n<span id=\"more\"></span>\n<p>相信很多朋友都有遇到过软件安装时提示，安装已损坏的情况。</p>\n<p>其实，并不是安装包（.dmg）损坏，其实是系统不信任未知来源的软件，之前低版本的系统中，设置-&gt;安全性与隐私-&gt;允许从以下位置下载的应用选项中，有三项，分别是App Store&#x2F;App Store和被认可的开发者／任何来源，但是最新的系统中默认是没有这个选项的，那么：</p>\n<p>macOS Sierra要先将隐藏的任意来源功能找出来，首先打开终端(找不到哪里打开终端?试试command+空格 搜索 “终端” 程序就会打开了，然后输入下面这串代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>\n<p>然后输入管理员密码，输入正确后，那么任何来源的选项就会出现了，选择任何来源，再次安装软件，就不会报错啦～</p>\n","site":{"data":{}},"excerpt":"<p>Mac OS安装软件时提示：“安装”已损坏，打不开。你应该推出磁盘映像。</p>","more":"<p>相信很多朋友都有遇到过软件安装时提示，安装已损坏的情况。</p>\n<p>其实，并不是安装包（.dmg）损坏，其实是系统不信任未知来源的软件，之前低版本的系统中，设置-&gt;安全性与隐私-&gt;允许从以下位置下载的应用选项中，有三项，分别是App Store&#x2F;App Store和被认可的开发者／任何来源，但是最新的系统中默认是没有这个选项的，那么：</p>\n<p>macOS Sierra要先将隐藏的任意来源功能找出来，首先打开终端(找不到哪里打开终端?试试command+空格 搜索 “终端” 程序就会打开了，然后输入下面这串代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>\n<p>然后输入管理员密码，输入正确后，那么任何来源的选项就会出现了，选择任何来源，再次安装软件，就不会报错啦～</p>"},{"title":"Spring Test & Junit单元测试","date":"2017-08-14T15:12:36.000Z","_content":"只要做过java web的人一定都接触过单元测试，单元测试是代码写完之后的第一道工序，是提高代码质量必不可少的途径～\n大多数java web项目都是基于Spring框架来做的，必然涉及到持久化，如数据库操作，那么对于有数据库操作的单元测试应该如何写呢？\n<!--more-->\n第一个我们想到的就是`Mockito`，就是说模拟数据库操作，模拟输入模拟输出，这样能将精力放在业务逻辑（service）层的测试上，与之相关的还有`PowerMockito`以及`MockMVC`，那么如果想对数据库操作进行单元测试呢？\n首先，我们要初始化`ApplicationContext`，在before方法中去初始化ApplicationContext，可能会导致初始化多次，这显然不妥～\n初始化之后，dao层对数据库进行操作时，会对数据库进行操作，可能会影响数据库的数据，对数据造成破坏，违背了对数据库现场不破坏的原则，那么针对这两个问题，我们应该如何解决呢？请看如下代码：\n首先定义一个单元测试基类，所有的单元测试类需继承此类\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({ \"classpath*:app*.xml\" })\npublic class BaseJunit4Test {\n  //\n}\n```\n`@RunWith(SpringJUnit4ClassRunner.class)`表示使用junit4进行测试\n`@ContextConfiguration({ \"classpath*:app*.xml\" })`表示加载配置文件\n\n单元测试类如下：\n```java\npublic class ServiceTest extends BaseJunit4Test {\n  @Resource\n  private CityService cityService;\n  @Test\n  @Transactional\n  @Rollback(true)\n  public void doTest() {\n    cityService.delete(1);\n  }\n}\n```\n`@Transactional`表示使用事务\n`@Rollback`表示是否回滚\n\n运行后，成功，但是delete方法执行后并没有删除数据库中的数据，符合我们的预期\n\n通过这样的方法，Sping Test+Junit，我们就能方便的对dao层进行单元测试，而不影响数据库现场","source":"_posts/Spring-Test-Junit单元测试.md","raw":"title: Spring Test & Junit单元测试\ndate: 2017-08-14 23:12:36\ncategories: Java\ntags: [Java,单元测试]\n---\n只要做过java web的人一定都接触过单元测试，单元测试是代码写完之后的第一道工序，是提高代码质量必不可少的途径～\n大多数java web项目都是基于Spring框架来做的，必然涉及到持久化，如数据库操作，那么对于有数据库操作的单元测试应该如何写呢？\n<!--more-->\n第一个我们想到的就是`Mockito`，就是说模拟数据库操作，模拟输入模拟输出，这样能将精力放在业务逻辑（service）层的测试上，与之相关的还有`PowerMockito`以及`MockMVC`，那么如果想对数据库操作进行单元测试呢？\n首先，我们要初始化`ApplicationContext`，在before方法中去初始化ApplicationContext，可能会导致初始化多次，这显然不妥～\n初始化之后，dao层对数据库进行操作时，会对数据库进行操作，可能会影响数据库的数据，对数据造成破坏，违背了对数据库现场不破坏的原则，那么针对这两个问题，我们应该如何解决呢？请看如下代码：\n首先定义一个单元测试基类，所有的单元测试类需继承此类\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({ \"classpath*:app*.xml\" })\npublic class BaseJunit4Test {\n  //\n}\n```\n`@RunWith(SpringJUnit4ClassRunner.class)`表示使用junit4进行测试\n`@ContextConfiguration({ \"classpath*:app*.xml\" })`表示加载配置文件\n\n单元测试类如下：\n```java\npublic class ServiceTest extends BaseJunit4Test {\n  @Resource\n  private CityService cityService;\n  @Test\n  @Transactional\n  @Rollback(true)\n  public void doTest() {\n    cityService.delete(1);\n  }\n}\n```\n`@Transactional`表示使用事务\n`@Rollback`表示是否回滚\n\n运行后，成功，但是delete方法执行后并没有删除数据库中的数据，符合我们的预期\n\n通过这样的方法，Sping Test+Junit，我们就能方便的对dao层进行单元测试，而不影响数据库现场","slug":"Spring-Test-Junit单元测试","published":1,"updated":"2025-03-07T13:26:47.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz29000frz5m1s5f0db9","content":"<p>只要做过java web的人一定都接触过单元测试，单元测试是代码写完之后的第一道工序，是提高代码质量必不可少的途径～<br>大多数java web项目都是基于Spring框架来做的，必然涉及到持久化，如数据库操作，那么对于有数据库操作的单元测试应该如何写呢？</p>\n<span id=\"more\"></span>\n<p>第一个我们想到的就是<code>Mockito</code>，就是说模拟数据库操作，模拟输入模拟输出，这样能将精力放在业务逻辑（service）层的测试上，与之相关的还有<code>PowerMockito</code>以及<code>MockMVC</code>，那么如果想对数据库操作进行单元测试呢？<br>首先，我们要初始化<code>ApplicationContext</code>，在before方法中去初始化ApplicationContext，可能会导致初始化多次，这显然不妥～<br>初始化之后，dao层对数据库进行操作时，会对数据库进行操作，可能会影响数据库的数据，对数据造成破坏，违背了对数据库现场不破坏的原则，那么针对这两个问题，我们应该如何解决呢？请看如下代码：<br>首先定义一个单元测试基类，所有的单元测试类需继承此类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(&#123; &quot;classpath*:app*.xml&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseJunit4Test</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@RunWith(SpringJUnit4ClassRunner.class)</code>表示使用junit4进行测试<br><code>@ContextConfiguration(&#123; &quot;classpath*:app*.xml&quot; &#125;)</code>表示加载配置文件</p>\n<p>单元测试类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseJunit4Test</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Resource</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> CityService cityService;</span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"meta\">@Rollback(true)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    cityService.delete(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Transactional</code>表示使用事务<br><code>@Rollback</code>表示是否回滚</p>\n<p>运行后，成功，但是delete方法执行后并没有删除数据库中的数据，符合我们的预期</p>\n<p>通过这样的方法，Sping Test+Junit，我们就能方便的对dao层进行单元测试，而不影响数据库现场</p>\n","site":{"data":{}},"excerpt":"<p>只要做过java web的人一定都接触过单元测试，单元测试是代码写完之后的第一道工序，是提高代码质量必不可少的途径～<br>大多数java web项目都是基于Spring框架来做的，必然涉及到持久化，如数据库操作，那么对于有数据库操作的单元测试应该如何写呢？</p>","more":"<p>第一个我们想到的就是<code>Mockito</code>，就是说模拟数据库操作，模拟输入模拟输出，这样能将精力放在业务逻辑（service）层的测试上，与之相关的还有<code>PowerMockito</code>以及<code>MockMVC</code>，那么如果想对数据库操作进行单元测试呢？<br>首先，我们要初始化<code>ApplicationContext</code>，在before方法中去初始化ApplicationContext，可能会导致初始化多次，这显然不妥～<br>初始化之后，dao层对数据库进行操作时，会对数据库进行操作，可能会影响数据库的数据，对数据造成破坏，违背了对数据库现场不破坏的原则，那么针对这两个问题，我们应该如何解决呢？请看如下代码：<br>首先定义一个单元测试基类，所有的单元测试类需继承此类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration(&#123; &quot;classpath*:app*.xml&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseJunit4Test</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@RunWith(SpringJUnit4ClassRunner.class)</code>表示使用junit4进行测试<br><code>@ContextConfiguration(&#123; &quot;classpath*:app*.xml&quot; &#125;)</code>表示加载配置文件</p>\n<p>单元测试类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServiceTest</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseJunit4Test</span> &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Resource</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> CityService cityService;</span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"meta\">@Rollback(true)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doTest</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    cityService.delete(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>@Transactional</code>表示使用事务<br><code>@Rollback</code>表示是否回滚</p>\n<p>运行后，成功，但是delete方法执行后并没有删除数据库中的数据，符合我们的预期</p>\n<p>通过这样的方法，Sping Test+Junit，我们就能方便的对dao层进行单元测试，而不影响数据库现场</p>"},{"title":"Hello World","date":"2015-05-07T13:28:51.000Z","type":"tags","_content":"一直想搭建一个属于自己的博客，本来想基于`Python`搭建的，但无奈云服务器太贵，所以只能放弃，后来看到了这篇文章[通过Hexo在Github上搭建博客教程](http://andrewliu.in/2014/11/21/%E9%80%9A%E8%BF%87Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)，顿时眼前一亮，这个博客终于搭建起来了。\n折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。\n一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。\n感谢[Hexo](http://hexo.io/)框架，感谢[Litten](http://litten.github.io/)提供的[Yilia](https://github.com/litten/hexo-theme-yilia)主题，我很喜欢这种色调。\n<!--more-->\n\n## 附上搭建过程中遇到的问题\n\n### 环境搭建\n\n``` \n#第一次使用执行前需执行 npm install\nhexo generate  #自动根据当前目录下的文件，生成静态网页\n```\n\n### 部署到Github(`_config.yml`)\n\n``` \n#执行\nhexo deploy\n#出现如下错误\nerror deployer not found:github\n#要将_config.yml中github改成git\ndeploy:\n  type: git    #部署类型, 本文使用Git\n#并在执行hexo deploy前先执行\nnpm install hexo-deployer-git --save\n```\n\nMore info: [搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误](http://www.v2ex.com/t/175940)\n\n### 绑定域名(新建`CNAME`文件)\n\n```\n#在自己的域名管理界面添加CNAME域名解析\n#在public目录下新建CNAME文件\nhellomypastor.net\n```\n\n","source":"_posts/hello-world.md","raw":"title: Hello World\ndate: 2015-05-07 21:28:51\ntype: \"tags\"\ntags:\n- 心路札记\n---\n一直想搭建一个属于自己的博客，本来想基于`Python`搭建的，但无奈云服务器太贵，所以只能放弃，后来看到了这篇文章[通过Hexo在Github上搭建博客教程](http://andrewliu.in/2014/11/21/%E9%80%9A%E8%BF%87Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)，顿时眼前一亮，这个博客终于搭建起来了。\n折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。\n一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。\n感谢[Hexo](http://hexo.io/)框架，感谢[Litten](http://litten.github.io/)提供的[Yilia](https://github.com/litten/hexo-theme-yilia)主题，我很喜欢这种色调。\n<!--more-->\n\n## 附上搭建过程中遇到的问题\n\n### 环境搭建\n\n``` \n#第一次使用执行前需执行 npm install\nhexo generate  #自动根据当前目录下的文件，生成静态网页\n```\n\n### 部署到Github(`_config.yml`)\n\n``` \n#执行\nhexo deploy\n#出现如下错误\nerror deployer not found:github\n#要将_config.yml中github改成git\ndeploy:\n  type: git    #部署类型, 本文使用Git\n#并在执行hexo deploy前先执行\nnpm install hexo-deployer-git --save\n```\n\nMore info: [搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误](http://www.v2ex.com/t/175940)\n\n### 绑定域名(新建`CNAME`文件)\n\n```\n#在自己的域名管理界面添加CNAME域名解析\n#在public目录下新建CNAME文件\nhellomypastor.net\n```\n\n","slug":"hello-world","published":1,"updated":"2025-03-07T13:26:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2a000krz5m7pei4l1l","content":"<p>一直想搭建一个属于自己的博客，本来想基于<code>Python</code>搭建的，但无奈云服务器太贵，所以只能放弃，后来看到了这篇文章<a href=\"http://andrewliu.in/2014/11/21/%E9%80%9A%E8%BF%87Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/\">通过Hexo在Github上搭建博客教程</a>，顿时眼前一亮，这个博客终于搭建起来了。<br>折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。<br>一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。<br>感谢<a href=\"http://hexo.io/\">Hexo</a>框架，感谢<a href=\"http://litten.github.io/\">Litten</a>提供的<a href=\"https://github.com/litten/hexo-theme-yilia\">Yilia</a>主题，我很喜欢这种色调。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"附上搭建过程中遇到的问题\"><a href=\"#附上搭建过程中遇到的问题\" class=\"headerlink\" title=\"附上搭建过程中遇到的问题\"></a>附上搭建过程中遇到的问题</h2><h3 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一次使用执行前需执行 npm install</span><br><span class=\"line\">hexo generate  #自动根据当前目录下的文件，生成静态网页</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到Github-config-yml\"><a href=\"#部署到Github-config-yml\" class=\"headerlink\" title=\"部署到Github(_config.yml)\"></a>部署到Github(<code>_config.yml</code>)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#执行</span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\">#出现如下错误</span><br><span class=\"line\">error deployer not found:github</span><br><span class=\"line\">#要将_config.yml中github改成git</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git    #部署类型, 本文使用Git</span><br><span class=\"line\">#并在执行hexo deploy前先执行</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"http://www.v2ex.com/t/175940\">搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误</a></p>\n<h3 id=\"绑定域名-新建CNAME文件\"><a href=\"#绑定域名-新建CNAME文件\" class=\"headerlink\" title=\"绑定域名(新建CNAME文件)\"></a>绑定域名(新建<code>CNAME</code>文件)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在自己的域名管理界面添加CNAME域名解析</span><br><span class=\"line\">#在public目录下新建CNAME文件</span><br><span class=\"line\">hellomypastor.net</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>一直想搭建一个属于自己的博客，本来想基于<code>Python</code>搭建的，但无奈云服务器太贵，所以只能放弃，后来看到了这篇文章<a href=\"http://andrewliu.in/2014/11/21/%E9%80%9A%E8%BF%87Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/\">通过Hexo在Github上搭建博客教程</a>，顿时眼前一亮，这个博客终于搭建起来了。<br>折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。<br>一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。<br>感谢<a href=\"http://hexo.io/\">Hexo</a>框架，感谢<a href=\"http://litten.github.io/\">Litten</a>提供的<a href=\"https://github.com/litten/hexo-theme-yilia\">Yilia</a>主题，我很喜欢这种色调。</p>","more":"<h2 id=\"附上搭建过程中遇到的问题\"><a href=\"#附上搭建过程中遇到的问题\" class=\"headerlink\" title=\"附上搭建过程中遇到的问题\"></a>附上搭建过程中遇到的问题</h2><h3 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#第一次使用执行前需执行 npm install</span><br><span class=\"line\">hexo generate  #自动根据当前目录下的文件，生成静态网页</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署到Github-config-yml\"><a href=\"#部署到Github-config-yml\" class=\"headerlink\" title=\"部署到Github(_config.yml)\"></a>部署到Github(<code>_config.yml</code>)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#执行</span><br><span class=\"line\">hexo deploy</span><br><span class=\"line\">#出现如下错误</span><br><span class=\"line\">error deployer not found:github</span><br><span class=\"line\">#要将_config.yml中github改成git</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git    #部署类型, 本文使用Git</span><br><span class=\"line\">#并在执行hexo deploy前先执行</span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"http://www.v2ex.com/t/175940\">搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误</a></p>\n<h3 id=\"绑定域名-新建CNAME文件\"><a href=\"#绑定域名-新建CNAME文件\" class=\"headerlink\" title=\"绑定域名(新建CNAME文件)\"></a>绑定域名(新建<code>CNAME</code>文件)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在自己的域名管理界面添加CNAME域名解析</span><br><span class=\"line\">#在public目录下新建CNAME文件</span><br><span class=\"line\">hellomypastor.net</span><br></pre></td></tr></table></figure>"},{"title":"docker命令学习（一）","date":"2016-08-29T13:34:35.000Z","type":"tags","_content":"最近项目中涉及到了`Docker`，Docker作为一种新兴的虚拟化方式，有着众多的优势，如更快的交付和部署，更高效的虚拟化，更轻松的迁移和扩展，更简单的管理登，现将Docker命令学习记录下来。\n<!--more-->\n## 镜像方面\n`获取镜像`\n- 获取镜像\n```docker\ndocker pull\n```\n- 提交镜像","source":"_posts/docker命令学习（一）.md","raw":"title: \"docker命令学习（一）\"\ndate: 2016-08-29 21:34:35\ntype: \"tags\"\ntags:\n- docker\n---\n最近项目中涉及到了`Docker`，Docker作为一种新兴的虚拟化方式，有着众多的优势，如更快的交付和部署，更高效的虚拟化，更轻松的迁移和扩展，更简单的管理登，现将Docker命令学习记录下来。\n<!--more-->\n## 镜像方面\n`获取镜像`\n- 获取镜像\n```docker\ndocker pull\n```\n- 提交镜像","slug":"docker命令学习（一）","published":1,"updated":"2025-03-07T13:26:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2a000mrz5mhowyh1ji","content":"<p>最近项目中涉及到了<code>Docker</code>，Docker作为一种新兴的虚拟化方式，有着众多的优势，如更快的交付和部署，更高效的虚拟化，更轻松的迁移和扩展，更简单的管理登，现将Docker命令学习记录下来。</p>\n<span id=\"more\"></span>\n<h2 id=\"镜像方面\"><a href=\"#镜像方面\" class=\"headerlink\" title=\"镜像方面\"></a>镜像方面</h2><p><code>获取镜像</code></p>\n<ul>\n<li>获取镜像<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull</span><br></pre></td></tr></table></figure></li>\n<li>提交镜像</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近项目中涉及到了<code>Docker</code>，Docker作为一种新兴的虚拟化方式，有着众多的优势，如更快的交付和部署，更高效的虚拟化，更轻松的迁移和扩展，更简单的管理登，现将Docker命令学习记录下来。</p>","more":"<h2 id=\"镜像方面\"><a href=\"#镜像方面\" class=\"headerlink\" title=\"镜像方面\"></a>镜像方面</h2><p><code>获取镜像</code></p>\n<ul>\n<li>获取镜像<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull</span><br></pre></td></tr></table></figure></li>\n<li>提交镜像</li>\n</ul>"},{"title":"Java8新特性（原子性操作）","date":"2018-01-02T16:27:43.000Z","_content":">上期我们介绍了Java8中新的时间日期API，本期我们介绍Java8中原子性操作`LongAdder`。\n\n<!--more-->\n##原子操作\n根据百度百科的定义：\n>\"原子操作(atomic operation)是不需要synchronized\"，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。\n\n##AtomicLong\n在单线程的环境中，使用Long，如果对于多线程的环境，如果使用Long的话，需要加上`synchronized`关键字，从Java5开始，JDK提供了`AtomicLong`类，AtomicLong是一个提供原子操作的Long类，通过线程安全的方式操作加减，AtomicLong提供原子操作来进行Long的使用，因此十分适合高并发情况下的使用。\n\n```java\npublic class AtomicLongFeature {\n\tprivate static final int NUM_INC = 1_000_000;\n\n\tprivate static AtomicLong atomicLong = new AtomicLong(0);\n\n\tprivate static void update() {\n\t\tatomicLong.set(0);\n\t\tExecutorService executorService = Executors.newFixedThreadPool(5);\n\t\tIntStream.range(0, NUM_INC).forEach(i -> {\n\t\t\tRunnable task = () -> atomicLong.updateAndGet(n -> n + 2);\n\t\t\texecutorService.submit(task);\n\t\t});\n\t\tstop(executorService);\n\t\tSystem.out.println(atomicLong.get());\n\t}\n\n\tprivate static void stop(ExecutorService executorService) {\n\t\ttry {\n\t\t\texecutorService.shutdown();\n\t\t\texecutorService.awaitTermination(60, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (!executorService.isTerminated()) {\n\t\t\t\tSystem.out.println(\"kill tasks\");\n\t\t\t}\n\t\t\texecutorService.shutdownNow();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tupdate();\n\t}\n}\n```\n输出：\n2000000\n\n为什么`AtomicInteger`能支持高并发呢？看下`AtomicLong`的`updateAndGet`方法：\n\n```java\npublic final int updateAndGet(IntUnaryOperator updateFunction) {\n    int prev, next;\n    do {\n        prev = get();\n        next = updateFunction.applyAsInt(prev);\n    } while (!compareAndSet(prev, next));\n    return next;\n}\n\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n\n原因是每次`updateAndGet`时都会调用`compareAndSet`方法。\n\n>AtomicLong是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。\n\n##LongAdder\nAtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。那么LongAdder又是使用到了什么原理?难道有比cas更加快速的方式？\n\n```java\npublic class LongAdderFeature {\n\tprivate static final int NUM_INC = 1_000_000;\n\n\tprivate static LongAdder longAdder = new LongAdder();\n\n\tprivate static void update() {\n\t\tExecutorService executorService = Executors.newFixedThreadPool(5);\n\t\tIntStream.range(0, NUM_INC).forEach(i -> {\n\t\t\tRunnable task = () -> longAdder.add(2);\n\t\t\texecutorService.submit(task);\n\t\t});\n\t\tstop(executorService);\n\t\tSystem.out.println(longAdder.sum());\n\t}\n\n\tprivate static void stop(ExecutorService executorService) {\n\t\ttry {\n\t\t\texecutorService.shutdown();\n\t\t\texecutorService.awaitTermination(60, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (!executorService.isTerminated()) {\n\t\t\t\tSystem.out.println(\"kill tasks\");\n\t\t\t}\n\t\t\texecutorService.shutdownNow();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tupdate();\n\t}\n}\n```\n\n输出：\n2000000\n\n我们来看下LongAdder的add方法：\n\n```java\npublic void add(long x) {\n    Cell[] as; long b, v; int m; Cell a;\n    if ((as = cells) != null || !casBase(b = base, b + x)) {\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) < 0 ||\n            (a = as[getProbe() & m]) == null ||\n            !(uncontended = a.cas(v = a.value, v + x)))\n            longAccumulate(x, null, uncontended);\n    }\n}\n```\n\n我们可以看到一个Cell的类，那这个类是用来干什么的呢?\n\n```java\n@sun.misc.Contended static final class Cell {\n    volatile long value;\n    Cell(long x) { value = x; }\n    final boolean cas(long cmp, long val) {\n        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n    }\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long valueOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> ak = Cell.class;\n            valueOffset = UNSAFE.objectFieldOffset\n                (ak.getDeclaredField(\"value\"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\n我们可以看到Cell类的内部是一个volatile的变量，然后更改这个变量唯一的方式通过cas。我们可以猜测到LongAdder的高明之处可能在于将之前单个节点的并发分散到各个节点的，这样从而提高在高并发时候的效率。\n\n>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。\n\n```java\npublic long sum() {\n    Cell[] as = cells; Cell a;\n    long sum = base;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\n```\n\n>当计数的时候，将base和各个cell元素里面的值进行叠加，从而得到计算总数的目的。这里的问题是在计数的同时如果修改cell元素，有可能导致计数的结果不准确，所以缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。","source":"_posts/java8-atomic-operation.md","raw":"title: Java8新特性（原子性操作）\ndate: 2018-01-03 00:27:43\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们介绍了Java8中新的时间日期API，本期我们介绍Java8中原子性操作`LongAdder`。\n\n<!--more-->\n##原子操作\n根据百度百科的定义：\n>\"原子操作(atomic operation)是不需要synchronized\"，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。\n\n##AtomicLong\n在单线程的环境中，使用Long，如果对于多线程的环境，如果使用Long的话，需要加上`synchronized`关键字，从Java5开始，JDK提供了`AtomicLong`类，AtomicLong是一个提供原子操作的Long类，通过线程安全的方式操作加减，AtomicLong提供原子操作来进行Long的使用，因此十分适合高并发情况下的使用。\n\n```java\npublic class AtomicLongFeature {\n\tprivate static final int NUM_INC = 1_000_000;\n\n\tprivate static AtomicLong atomicLong = new AtomicLong(0);\n\n\tprivate static void update() {\n\t\tatomicLong.set(0);\n\t\tExecutorService executorService = Executors.newFixedThreadPool(5);\n\t\tIntStream.range(0, NUM_INC).forEach(i -> {\n\t\t\tRunnable task = () -> atomicLong.updateAndGet(n -> n + 2);\n\t\t\texecutorService.submit(task);\n\t\t});\n\t\tstop(executorService);\n\t\tSystem.out.println(atomicLong.get());\n\t}\n\n\tprivate static void stop(ExecutorService executorService) {\n\t\ttry {\n\t\t\texecutorService.shutdown();\n\t\t\texecutorService.awaitTermination(60, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (!executorService.isTerminated()) {\n\t\t\t\tSystem.out.println(\"kill tasks\");\n\t\t\t}\n\t\t\texecutorService.shutdownNow();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tupdate();\n\t}\n}\n```\n输出：\n2000000\n\n为什么`AtomicInteger`能支持高并发呢？看下`AtomicLong`的`updateAndGet`方法：\n\n```java\npublic final int updateAndGet(IntUnaryOperator updateFunction) {\n    int prev, next;\n    do {\n        prev = get();\n        next = updateFunction.applyAsInt(prev);\n    } while (!compareAndSet(prev, next));\n    return next;\n}\n\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n\n原因是每次`updateAndGet`时都会调用`compareAndSet`方法。\n\n>AtomicLong是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。\n\n##LongAdder\nAtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。那么LongAdder又是使用到了什么原理?难道有比cas更加快速的方式？\n\n```java\npublic class LongAdderFeature {\n\tprivate static final int NUM_INC = 1_000_000;\n\n\tprivate static LongAdder longAdder = new LongAdder();\n\n\tprivate static void update() {\n\t\tExecutorService executorService = Executors.newFixedThreadPool(5);\n\t\tIntStream.range(0, NUM_INC).forEach(i -> {\n\t\t\tRunnable task = () -> longAdder.add(2);\n\t\t\texecutorService.submit(task);\n\t\t});\n\t\tstop(executorService);\n\t\tSystem.out.println(longAdder.sum());\n\t}\n\n\tprivate static void stop(ExecutorService executorService) {\n\t\ttry {\n\t\t\texecutorService.shutdown();\n\t\t\texecutorService.awaitTermination(60, TimeUnit.SECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (!executorService.isTerminated()) {\n\t\t\t\tSystem.out.println(\"kill tasks\");\n\t\t\t}\n\t\t\texecutorService.shutdownNow();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tupdate();\n\t}\n}\n```\n\n输出：\n2000000\n\n我们来看下LongAdder的add方法：\n\n```java\npublic void add(long x) {\n    Cell[] as; long b, v; int m; Cell a;\n    if ((as = cells) != null || !casBase(b = base, b + x)) {\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) < 0 ||\n            (a = as[getProbe() & m]) == null ||\n            !(uncontended = a.cas(v = a.value, v + x)))\n            longAccumulate(x, null, uncontended);\n    }\n}\n```\n\n我们可以看到一个Cell的类，那这个类是用来干什么的呢?\n\n```java\n@sun.misc.Contended static final class Cell {\n    volatile long value;\n    Cell(long x) { value = x; }\n    final boolean cas(long cmp, long val) {\n        return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n    }\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long valueOffset;\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> ak = Cell.class;\n            valueOffset = UNSAFE.objectFieldOffset\n                (ak.getDeclaredField(\"value\"));\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\n我们可以看到Cell类的内部是一个volatile的变量，然后更改这个变量唯一的方式通过cas。我们可以猜测到LongAdder的高明之处可能在于将之前单个节点的并发分散到各个节点的，这样从而提高在高并发时候的效率。\n\n>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。\n\n```java\npublic long sum() {\n    Cell[] as = cells; Cell a;\n    long sum = base;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;\n        }\n    }\n    return sum;\n}\n```\n\n>当计数的时候，将base和各个cell元素里面的值进行叠加，从而得到计算总数的目的。这里的问题是在计数的同时如果修改cell元素，有可能导致计数的结果不准确，所以缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。","slug":"java8-atomic-operation","published":1,"updated":"2025-03-07T13:26:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2b000prz5m452xchu9","content":"<blockquote>\n<p>上期我们介绍了Java8中新的时间日期API，本期我们介绍Java8中原子性操作<code>LongAdder</code>。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##原子操作<br>根据百度百科的定义：</p>\n<blockquote>\n<p>“原子操作(atomic operation)是不需要synchronized”，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>\n</blockquote>\n<p>##AtomicLong<br>在单线程的环境中，使用Long，如果对于多线程的环境，如果使用Long的话，需要加上<code>synchronized</code>关键字，从Java5开始，JDK提供了<code>AtomicLong</code>类，AtomicLong是一个提供原子操作的Long类，通过线程安全的方式操作加减，AtomicLong提供原子操作来进行Long的使用，因此十分适合高并发情况下的使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicLongFeature</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NUM_INC</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">atomicLong</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tatomicLong.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, NUM_INC).forEach(i -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; atomicLong.updateAndGet(n -&gt; n + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\texecutorService.submit(task);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tstop(executorService);</span><br><span class=\"line\">\t\tSystem.out.println(atomicLong.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">(ExecutorService executorService)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\texecutorService.shutdown();</span><br><span class=\"line\">\t\t\texecutorService.awaitTermination(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!executorService.isTerminated()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;kill tasks&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\texecutorService.shutdownNow();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tupdate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>2000000</p>\n<p>为什么<code>AtomicInteger</code>能支持高并发呢？看下<code>AtomicLong</code>的<code>updateAndGet</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">updateAndGet</span><span class=\"params\">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> prev, next;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        prev = get();</span><br><span class=\"line\">        next = updateFunction.applyAsInt(prev);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!compareAndSet(prev, next));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSet</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原因是每次<code>updateAndGet</code>时都会调用<code>compareAndSet</code>方法。</p>\n<blockquote>\n<p>AtomicLong是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。</p>\n</blockquote>\n<p>##LongAdder<br>AtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。那么LongAdder又是使用到了什么原理?难道有比cas更加快速的方式？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongAdderFeature</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NUM_INC</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">LongAdder</span> <span class=\"variable\">longAdder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LongAdder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, NUM_INC).forEach(i -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; longAdder.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\texecutorService.submit(task);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tstop(executorService);</span><br><span class=\"line\">\t\tSystem.out.println(longAdder.sum());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">(ExecutorService executorService)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\texecutorService.shutdown();</span><br><span class=\"line\">\t\t\texecutorService.awaitTermination(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!executorService.isTerminated()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;kill tasks&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\texecutorService.shutdownNow();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tupdate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>2000000</p>\n<p>我们来看下LongAdder的add方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">long</span> x)</span> &#123;</span><br><span class=\"line\">    Cell[] as; <span class=\"type\">long</span> b, v; <span class=\"type\">int</span> m; Cell a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((as = cells) != <span class=\"literal\">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">uncontended</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (as == <span class=\"literal\">null</span> || (m = as.length - <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (a = as[getProbe() &amp; m]) == <span class=\"literal\">null</span> ||</span><br><span class=\"line\">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class=\"line\">            longAccumulate(x, <span class=\"literal\">null</span>, uncontended);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到一个Cell的类，那这个类是用来干什么的呢?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sun</span>.misc.Contended <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cell</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> value;</span><br><span class=\"line\">    Cell(<span class=\"type\">long</span> x) &#123; value = x; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">cas</span><span class=\"params\">(<span class=\"type\">long</span> cmp, <span class=\"type\">long</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UNSAFE.compareAndSwapLong(<span class=\"built_in\">this</span>, valueOffset, cmp, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; ak = Cell.class;</span><br><span class=\"line\">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (ak.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到Cell类的内部是一个volatile的变量，然后更改这个变量唯一的方式通过cas。我们可以猜测到LongAdder的高明之处可能在于将之前单个节点的并发分散到各个节点的，这样从而提高在高并发时候的效率。</p>\n<blockquote>\n<p>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sum</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Cell[] as = cells; Cell a;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> base;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (as != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = as[i]) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                sum += a.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当计数的时候，将base和各个cell元素里面的值进行叠加，从而得到计算总数的目的。这里的问题是在计数的同时如果修改cell元素，有可能导致计数的结果不准确，所以缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们介绍了Java8中新的时间日期API，本期我们介绍Java8中原子性操作<code>LongAdder</code>。</p>\n</blockquote>","more":"<p>##原子操作<br>根据百度百科的定义：</p>\n<blockquote>\n<p>“原子操作(atomic operation)是不需要synchronized”，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>\n</blockquote>\n<p>##AtomicLong<br>在单线程的环境中，使用Long，如果对于多线程的环境，如果使用Long的话，需要加上<code>synchronized</code>关键字，从Java5开始，JDK提供了<code>AtomicLong</code>类，AtomicLong是一个提供原子操作的Long类，通过线程安全的方式操作加减，AtomicLong提供原子操作来进行Long的使用，因此十分适合高并发情况下的使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicLongFeature</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NUM_INC</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">AtomicLong</span> <span class=\"variable\">atomicLong</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicLong</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tatomicLong.set(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, NUM_INC).forEach(i -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; atomicLong.updateAndGet(n -&gt; n + <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\texecutorService.submit(task);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tstop(executorService);</span><br><span class=\"line\">\t\tSystem.out.println(atomicLong.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">(ExecutorService executorService)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\texecutorService.shutdown();</span><br><span class=\"line\">\t\t\texecutorService.awaitTermination(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!executorService.isTerminated()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;kill tasks&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\texecutorService.shutdownNow();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tupdate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>2000000</p>\n<p>为什么<code>AtomicInteger</code>能支持高并发呢？看下<code>AtomicLong</code>的<code>updateAndGet</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">updateAndGet</span><span class=\"params\">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> prev, next;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        prev = get();</span><br><span class=\"line\">        next = updateFunction.applyAsInt(prev);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!compareAndSet(prev, next));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSet</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原因是每次<code>updateAndGet</code>时都会调用<code>compareAndSet</code>方法。</p>\n<blockquote>\n<p>AtomicLong是在使用非阻塞算法实现并发控制，在一些高并发程序中非常适合，但并不能每一种场景都适合，不同场景要使用使用不同的数值类。</p>\n</blockquote>\n<p>##LongAdder<br>AtomicLong的原理是依靠底层的cas来保障原子性的更新数据，在要添加或者减少的时候，会使用死循环不断地cas到特定的值，从而达到更新数据的目的。那么LongAdder又是使用到了什么原理?难道有比cas更加快速的方式？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongAdderFeature</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NUM_INC</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">LongAdder</span> <span class=\"variable\">longAdder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LongAdder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">update</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, NUM_INC).forEach(i -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> () -&gt; longAdder.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\texecutorService.submit(task);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tstop(executorService);</span><br><span class=\"line\">\t\tSystem.out.println(longAdder.sum());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stop</span><span class=\"params\">(ExecutorService executorService)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\texecutorService.shutdown();</span><br><span class=\"line\">\t\t\texecutorService.awaitTermination(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!executorService.isTerminated()) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;kill tasks&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\texecutorService.shutdownNow();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tupdate();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>2000000</p>\n<p>我们来看下LongAdder的add方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">long</span> x)</span> &#123;</span><br><span class=\"line\">    Cell[] as; <span class=\"type\">long</span> b, v; <span class=\"type\">int</span> m; Cell a;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((as = cells) != <span class=\"literal\">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">uncontended</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (as == <span class=\"literal\">null</span> || (m = as.length - <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">            (a = as[getProbe() &amp; m]) == <span class=\"literal\">null</span> ||</span><br><span class=\"line\">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class=\"line\">            longAccumulate(x, <span class=\"literal\">null</span>, uncontended);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到一个Cell的类，那这个类是用来干什么的呢?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sun</span>.misc.Contended <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Cell</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> value;</span><br><span class=\"line\">    Cell(<span class=\"type\">long</span> x) &#123; value = x; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">cas</span><span class=\"params\">(<span class=\"type\">long</span> cmp, <span class=\"type\">long</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UNSAFE.compareAndSwapLong(<span class=\"built_in\">this</span>, valueOffset, cmp, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> valueOffset;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; ak = Cell.class;</span><br><span class=\"line\">            valueOffset = UNSAFE.objectFieldOffset</span><br><span class=\"line\">                (ak.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到Cell类的内部是一个volatile的变量，然后更改这个变量唯一的方式通过cas。我们可以猜测到LongAdder的高明之处可能在于将之前单个节点的并发分散到各个节点的，这样从而提高在高并发时候的效率。</p>\n<blockquote>\n<p>LongAdder在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base的直接更新可以很好的保障和AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sum</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Cell[] as = cells; Cell a;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> base;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (as != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = as[i]) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                sum += a.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当计数的时候，将base和各个cell元素里面的值进行叠加，从而得到计算总数的目的。这里的问题是在计数的同时如果修改cell元素，有可能导致计数的结果不准确，所以缺点是LongAdder在统计的时候如果有并发更新，可能导致统计的数据有误差。</p>\n</blockquote>"},{"title":"Java8新特性（Lambda）","date":"2017-12-24T14:25:37.000Z","_content":">上期我们分析了Java8中Interface的相关新特性，其中包括函数式接口，可以在调用时，使用一个Lambda表达式作为参数，那么我们就来谈谈Java8中的Lambda表达式吧。\n\n<!--more-->\n##定义\n>Lambda表达式基于函数式接口实现，故可以认为Lambda表达式是对函数式接口的匿名内部类的一种简写形式。\n\n##格式\nLambda表达式的具体形式为：`()->{}`\n\n箭头表达式`->`将Lambda表达式分为了左右两部分，左侧为参数列表，右侧为具体实现，即Lambda体。\n\n具体有以下以及情形：\n\n####1. 无参数无返回值\n\n```java\nRunnable runnable = () -> {\n\tSystem.out.println(\"run\");\n};\n```\n    \n####2. 有一个参数无返回值\n```java\npublic interface MyInterface {\n\tvoid test(int x);\n}\n\nMyInterface i = (x) -> System.out.println(x);\n```\n\n####3. 只要一个参数，小括号可以不写\n```java\nMyInterface i = x -> System.out.println(x);\n```\n####4. 有多个参数有返回值，并且Lambda体有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"Comparator\");\n    return Integer.compare(x, y);\n};\n```\n####5. Lambda体中只有一条语句，return和{}可以省略\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n####6. Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”\n```java\nComparator<Integer> comparator = (Integer x, Intergery) -> Integer.compare(x, y);\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n###总结：\n\n+ 参数类型可忽略，若写所有参数都要写，若不写，可以类型推断\n+ 参数有且仅有一个时，`()`可以省略\n+ Lambda体只有一条语句，`return`和`{}`都可忽略\n\n##Java8内置四大核心函数式接口(java.util.function.*包)\n+ Consumer<T> 消费型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tconsumer(str, s -> System.out.println(s));\n}\n\npublic static void consumer(String str, Consumer<String> function) {\n\tfunction.accept(str);\n}\n```\n\n+ Supplier<T> 供给型接口\n\n```java\npublic static void main(String[] args) {\n\tsupplier(() -> \"str\");\n}\n\npublic static String supplier(Supplier<String> function) {\n\treturn function.get();\n}\n```\n\n+ Function<T, R> 函数型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tfunction(str, s -> s);\n}\n\t\npublic static String function(String str, Function<String, String> function) {\n\treturn function.apply(str);\n}\n```\n\n+ Predicate<T> 断定型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tpredicate(str, s -> s.isEmpty());\n}\n\npublic static boolean predicate(String str, Predicate<String> function) {\n\treturn function.test(str);\n}\n```\n\n>Lambda表达式就到这里了，一开始用起来会不习惯，用多了上手起来就熟练了，而且越用越信手拈来。\n>\n>####**下期我们将分析用引用方式简写Lambda表达式，敬请期待。**\n\n","source":"_posts/java8-lambda.md","raw":"title: Java8新特性（Lambda）\ndate: 2017-12-24 22:25:37\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们分析了Java8中Interface的相关新特性，其中包括函数式接口，可以在调用时，使用一个Lambda表达式作为参数，那么我们就来谈谈Java8中的Lambda表达式吧。\n\n<!--more-->\n##定义\n>Lambda表达式基于函数式接口实现，故可以认为Lambda表达式是对函数式接口的匿名内部类的一种简写形式。\n\n##格式\nLambda表达式的具体形式为：`()->{}`\n\n箭头表达式`->`将Lambda表达式分为了左右两部分，左侧为参数列表，右侧为具体实现，即Lambda体。\n\n具体有以下以及情形：\n\n####1. 无参数无返回值\n\n```java\nRunnable runnable = () -> {\n\tSystem.out.println(\"run\");\n};\n```\n    \n####2. 有一个参数无返回值\n```java\npublic interface MyInterface {\n\tvoid test(int x);\n}\n\nMyInterface i = (x) -> System.out.println(x);\n```\n\n####3. 只要一个参数，小括号可以不写\n```java\nMyInterface i = x -> System.out.println(x);\n```\n####4. 有多个参数有返回值，并且Lambda体有多条语句\n```java\nComparator<Integer> comparator = (x, y) -> {\n    System.out.println(\"Comparator\");\n    return Integer.compare(x, y);\n};\n```\n####5. Lambda体中只有一条语句，return和{}可以省略\n```java\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n####6. Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”\n```java\nComparator<Integer> comparator = (Integer x, Intergery) -> Integer.compare(x, y);\nComparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n```\n###总结：\n\n+ 参数类型可忽略，若写所有参数都要写，若不写，可以类型推断\n+ 参数有且仅有一个时，`()`可以省略\n+ Lambda体只有一条语句，`return`和`{}`都可忽略\n\n##Java8内置四大核心函数式接口(java.util.function.*包)\n+ Consumer<T> 消费型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tconsumer(str, s -> System.out.println(s));\n}\n\npublic static void consumer(String str, Consumer<String> function) {\n\tfunction.accept(str);\n}\n```\n\n+ Supplier<T> 供给型接口\n\n```java\npublic static void main(String[] args) {\n\tsupplier(() -> \"str\");\n}\n\npublic static String supplier(Supplier<String> function) {\n\treturn function.get();\n}\n```\n\n+ Function<T, R> 函数型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tfunction(str, s -> s);\n}\n\t\npublic static String function(String str, Function<String, String> function) {\n\treturn function.apply(str);\n}\n```\n\n+ Predicate<T> 断定型接口\n\n```java\npublic static void main(String[] args) {\n\tString str = \"str\";\n\tpredicate(str, s -> s.isEmpty());\n}\n\npublic static boolean predicate(String str, Predicate<String> function) {\n\treturn function.test(str);\n}\n```\n\n>Lambda表达式就到这里了，一开始用起来会不习惯，用多了上手起来就熟练了，而且越用越信手拈来。\n>\n>####**下期我们将分析用引用方式简写Lambda表达式，敬请期待。**\n\n","slug":"java8-lambda","published":1,"updated":"2025-03-07T13:26:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2b000rrz5m0thqd5gl","content":"<blockquote>\n<p>上期我们分析了Java8中Interface的相关新特性，其中包括函数式接口，可以在调用时，使用一个Lambda表达式作为参数，那么我们就来谈谈Java8中的Lambda表达式吧。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##定义</p>\n<blockquote>\n<p>Lambda表达式基于函数式接口实现，故可以认为Lambda表达式是对函数式接口的匿名内部类的一种简写形式。</p>\n</blockquote>\n<p>##格式<br>Lambda表达式的具体形式为：<code>()-&gt;&#123;&#125;</code></p>\n<p>箭头表达式<code>-&gt;</code>将Lambda表达式分为了左右两部分，左侧为参数列表，右侧为具体实现，即Lambda体。</p>\n<p>具体有以下以及情形：</p>\n<p>####1. 无参数无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;run&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####2. 有一个参数无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">MyInterface</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>####3. 只要一个参数，小括号可以不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MyInterface</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n<p>####4. 有多个参数有返回值，并且Lambda体有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Comparator&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####5. Lambda体中只有一条语句，return和{}可以省略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n<p>####6. Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Intergery) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n<p>###总结：</p>\n<ul>\n<li>参数类型可忽略，若写所有参数都要写，若不写，可以类型推断</li>\n<li>参数有且仅有一个时，<code>()</code>可以省略</li>\n<li>Lambda体只有一条语句，<code>return</code>和<code>&#123;&#125;</code>都可忽略</li>\n</ul>\n<p>##Java8内置四大核心函数式接口(java.util.function.*包)</p>\n<ul>\n<li>Consumer<T> 消费型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tconsumer(str, s -&gt; System.out.println(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">consumer</span><span class=\"params\">(String str, Consumer&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\tfunction.accept(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Supplier<T> 供给型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tsupplier(() -&gt; <span class=\"string\">&quot;str&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">supplier</span><span class=\"params\">(Supplier&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Function&lt;T, R&gt; 函数型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tfunction(str, s -&gt; s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">function</span><span class=\"params\">(String str, Function&lt;String, String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.apply(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Predicate<T> 断定型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tpredicate(str, s -&gt; s.isEmpty());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">predicate</span><span class=\"params\">(String str, Predicate&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.test(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Lambda表达式就到这里了，一开始用起来会不习惯，用多了上手起来就熟练了，而且越用越信手拈来。</p>\n<p>####<strong>下期我们将分析用引用方式简写Lambda表达式，敬请期待。</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分析了Java8中Interface的相关新特性，其中包括函数式接口，可以在调用时，使用一个Lambda表达式作为参数，那么我们就来谈谈Java8中的Lambda表达式吧。</p>\n</blockquote>","more":"<p>##定义</p>\n<blockquote>\n<p>Lambda表达式基于函数式接口实现，故可以认为Lambda表达式是对函数式接口的匿名内部类的一种简写形式。</p>\n</blockquote>\n<p>##格式<br>Lambda表达式的具体形式为：<code>()-&gt;&#123;&#125;</code></p>\n<p>箭头表达式<code>-&gt;</code>将Lambda表达式分为了左右两部分，左侧为参数列表，右侧为具体实现，即Lambda体。</p>\n<p>具体有以下以及情形：</p>\n<p>####1. 无参数无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> () -&gt; &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;run&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####2. 有一个参数无返回值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">MyInterface</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> (x) -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n\n<p>####3. 只要一个参数，小括号可以不写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MyInterface</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure>\n<p>####4. 有多个参数有返回值，并且Lambda体有多条语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Comparator&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Integer.compare(x, y);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####5. Lambda体中只有一条语句，return和{}可以省略</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n<p>####6. Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Comparator&lt;Integer&gt; comparator = (Integer x, Intergery) -&gt; Integer.compare(x, y);</span><br><span class=\"line\">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure>\n<p>###总结：</p>\n<ul>\n<li>参数类型可忽略，若写所有参数都要写，若不写，可以类型推断</li>\n<li>参数有且仅有一个时，<code>()</code>可以省略</li>\n<li>Lambda体只有一条语句，<code>return</code>和<code>&#123;&#125;</code>都可忽略</li>\n</ul>\n<p>##Java8内置四大核心函数式接口(java.util.function.*包)</p>\n<ul>\n<li>Consumer<T> 消费型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tconsumer(str, s -&gt; System.out.println(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">consumer</span><span class=\"params\">(String str, Consumer&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\tfunction.accept(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Supplier<T> 供给型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tsupplier(() -&gt; <span class=\"string\">&quot;str&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">supplier</span><span class=\"params\">(Supplier&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Function&lt;T, R&gt; 函数型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tfunction(str, s -&gt; s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">function</span><span class=\"params\">(String str, Function&lt;String, String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.apply(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Predicate<T> 断定型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;str&quot;</span>;</span><br><span class=\"line\">\tpredicate(str, s -&gt; s.isEmpty());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">predicate</span><span class=\"params\">(String str, Predicate&lt;String&gt; function)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> function.test(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Lambda表达式就到这里了，一开始用起来会不习惯，用多了上手起来就熟练了，而且越用越信手拈来。</p>\n<p>####<strong>下期我们将分析用引用方式简写Lambda表达式，敬请期待。</strong></p>\n</blockquote>"},{"title":"Java8新特性（Optional）","date":"2017-12-30T06:03:25.000Z","_content":">上期我们介绍了Java中的流性能，并行流的应用场景，本期我们介绍Java8种的另一个新特性：`Optional`。\n\n<!--more-->\n##背景\n只要是Java程序员，都应该遇到过空指针异常：`NullPointerException`，简称`NPE`。\n在Java8之前，我们都要判断下对象是否为null，或者用`Google`提供的**`Guava`**的Optional\n在Java8中，提供了`Optional`\n\n##使用\n\n+ init\n    + empty 构造一个空对象\n    + of 不能传null\n    + ofNullable 可以为null\n\n```java\npublic static<T> Optional<T> empty() {\n    @SuppressWarnings(\"unchecked\")\n    Optional<T> t = (Optional<T>) EMPTY;\n    return t;\n}\n\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n    \npublic static <T> Optional<T> ofNullable(T value) {\n    return value == null ? empty() : of(value);\n}\n```\n\n+ get\n    + 如果为null，会抛异常，用isPresent来判断\n\n```java\npublic T get() {\n    if (value == null) {\n        throw new NoSuchElementException(\"No value present\");\n    }\n    return value;\n}\n```\n\n+ isPresent\n    + 判断元素是否为null\n\n```java\npublic boolean isPresent() {\n    return value != null;\n}\n```\n\n+ ifPresent\n    + 判断不为null时执行操作，如optional.ifPresent(System.out::println)\n\n```java\npublic void ifPresent(Consumer<? super T> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n```\n\n+ filter\n\n```java\npublic Optional<T> filter(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate);\n    if (!isPresent())\n        return this;\n    else\n        return predicate.test(value) ? this : empty();\n}\n```\n\n+ map\n\n```java\npublic<U> Optional<U> map(Function<? super T, ? extends U> mapper) {\n        Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Optional.ofNullable(mapper.apply(value));\n    }\n}\n```\n\n+ flatMap\n\n```java\npublic<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {\n        Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Objects.requireNonNull(mapper.apply(value));\n    }\n}\n```\n\n+ orElse\n    + 如果为null返回某个默认值，否则返回具体值\n\n```java\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n```\n\n+ orElseGet\n\n```java\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n```\n\n+ orElseThrow\n\n```java\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionSupplier.get();\n    }\n}\n```\n\n##总结\n>Optional有什么用？\n\n+ 简化代码\n    + 类似于Lambda\n+ 能一定程度避免空指针\n    + 比如：optional.ifPresent(...)等\n+ 增加可读性\n    + 比如：optional.ifPresent(...).orElse(...);是不是比if／else分支更可读呢？","source":"_posts/java8-optional.md","raw":"title: Java8新特性（Optional）\ndate: 2017-12-30 14:03:25\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们介绍了Java中的流性能，并行流的应用场景，本期我们介绍Java8种的另一个新特性：`Optional`。\n\n<!--more-->\n##背景\n只要是Java程序员，都应该遇到过空指针异常：`NullPointerException`，简称`NPE`。\n在Java8之前，我们都要判断下对象是否为null，或者用`Google`提供的**`Guava`**的Optional\n在Java8中，提供了`Optional`\n\n##使用\n\n+ init\n    + empty 构造一个空对象\n    + of 不能传null\n    + ofNullable 可以为null\n\n```java\npublic static<T> Optional<T> empty() {\n    @SuppressWarnings(\"unchecked\")\n    Optional<T> t = (Optional<T>) EMPTY;\n    return t;\n}\n\npublic static <T> Optional<T> of(T value) {\n    return new Optional<>(value);\n}\n    \npublic static <T> Optional<T> ofNullable(T value) {\n    return value == null ? empty() : of(value);\n}\n```\n\n+ get\n    + 如果为null，会抛异常，用isPresent来判断\n\n```java\npublic T get() {\n    if (value == null) {\n        throw new NoSuchElementException(\"No value present\");\n    }\n    return value;\n}\n```\n\n+ isPresent\n    + 判断元素是否为null\n\n```java\npublic boolean isPresent() {\n    return value != null;\n}\n```\n\n+ ifPresent\n    + 判断不为null时执行操作，如optional.ifPresent(System.out::println)\n\n```java\npublic void ifPresent(Consumer<? super T> consumer) {\n    if (value != null)\n        consumer.accept(value);\n}\n```\n\n+ filter\n\n```java\npublic Optional<T> filter(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate);\n    if (!isPresent())\n        return this;\n    else\n        return predicate.test(value) ? this : empty();\n}\n```\n\n+ map\n\n```java\npublic<U> Optional<U> map(Function<? super T, ? extends U> mapper) {\n        Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Optional.ofNullable(mapper.apply(value));\n    }\n}\n```\n\n+ flatMap\n\n```java\npublic<U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper) {\n        Objects.requireNonNull(mapper);\n    if (!isPresent())\n        return empty();\n    else {\n        return Objects.requireNonNull(mapper.apply(value));\n    }\n}\n```\n\n+ orElse\n    + 如果为null返回某个默认值，否则返回具体值\n\n```java\npublic T orElse(T other) {\n    return value != null ? value : other;\n}\n```\n\n+ orElseGet\n\n```java\npublic T orElseGet(Supplier<? extends T> other) {\n    return value != null ? value : other.get();\n}\n```\n\n+ orElseThrow\n\n```java\npublic <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n    if (value != null) {\n        return value;\n    } else {\n        throw exceptionSupplier.get();\n    }\n}\n```\n\n##总结\n>Optional有什么用？\n\n+ 简化代码\n    + 类似于Lambda\n+ 能一定程度避免空指针\n    + 比如：optional.ifPresent(...)等\n+ 增加可读性\n    + 比如：optional.ifPresent(...).orElse(...);是不是比if／else分支更可读呢？","slug":"java8-optional","published":1,"updated":"2025-03-07T13:26:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2c000trz5m5rqlbrdr","content":"<blockquote>\n<p>上期我们介绍了Java中的流性能，并行流的应用场景，本期我们介绍Java8种的另一个新特性：<code>Optional</code>。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##背景<br>只要是Java程序员，都应该遇到过空指针异常：<code>NullPointerException</code>，简称<code>NPE</code>。<br>在Java8之前，我们都要判断下对象是否为null，或者用<code>Google</code>提供的**<code>Guava</code>**的Optional<br>在Java8中，提供了<code>Optional</code></p>\n<p>##使用</p>\n<ul>\n<li>init<ul>\n<li>empty 构造一个空对象</li>\n<li>of 不能传null</li>\n<li>ofNullable 可以为null</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Optional</span>&lt;&gt;(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">ofNullable</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value == <span class=\"literal\">null</span> ? empty() : of(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>get<ul>\n<li>如果为null，会抛异常，用isPresent来判断</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchElementException</span>(<span class=\"string\">&quot;No value present&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>isPresent<ul>\n<li>判断元素是否为null</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPresent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ifPresent<ul>\n<li>判断不为null时执行操作，如optional.ifPresent(System.out::println)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ifPresent</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; consumer)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        consumer.accept(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>filter</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Optional&lt;T&gt; <span class=\"title function_\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> predicate.test(value) ? <span class=\"built_in\">this</span> : empty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>map</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title function_\">map</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>flatMap</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title function_\">flatMap</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElse<ul>\n<li>如果为null返回某个默认值，否则返回具体值</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElse</span><span class=\"params\">(T other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElseGet</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElseGet</span><span class=\"params\">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElseThrow</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;X <span class=\"keyword\">extends</span> <span class=\"title class_\">Throwable</span>&gt; T <span class=\"title function_\">orElseThrow</span><span class=\"params\">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class=\"keyword\">throws</span> X &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exceptionSupplier.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##总结</p>\n<blockquote>\n<p>Optional有什么用？</p>\n</blockquote>\n<ul>\n<li>简化代码<ul>\n<li>类似于Lambda</li>\n</ul>\n</li>\n<li>能一定程度避免空指针<ul>\n<li>比如：optional.ifPresent(…)等</li>\n</ul>\n</li>\n<li>增加可读性<ul>\n<li>比如：optional.ifPresent(…).orElse(…);是不是比if／else分支更可读呢？</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们介绍了Java中的流性能，并行流的应用场景，本期我们介绍Java8种的另一个新特性：<code>Optional</code>。</p>\n</blockquote>","more":"<p>##背景<br>只要是Java程序员，都应该遇到过空指针异常：<code>NullPointerException</code>，简称<code>NPE</code>。<br>在Java8之前，我们都要判断下对象是否为null，或者用<code>Google</code>提供的**<code>Guava</code>**的Optional<br>在Java8中，提供了<code>Optional</code></p>\n<p>##使用</p>\n<ul>\n<li>init<ul>\n<li>empty 构造一个空对象</li>\n<li>of 不能传null</li>\n<li>ofNullable 可以为null</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Optional</span>&lt;&gt;(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Optional&lt;T&gt; <span class=\"title function_\">ofNullable</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value == <span class=\"literal\">null</span> ? empty() : of(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>get<ul>\n<li>如果为null，会抛异常，用isPresent来判断</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NoSuchElementException</span>(<span class=\"string\">&quot;No value present&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>isPresent<ul>\n<li>判断元素是否为null</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPresent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ifPresent<ul>\n<li>判断不为null时执行操作，如optional.ifPresent(System.out::println)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ifPresent</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; consumer)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        consumer.accept(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>filter</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Optional&lt;T&gt; <span class=\"title function_\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> predicate.test(value) ? <span class=\"built_in\">this</span> : empty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>map</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title function_\">map</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>flatMap</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>&lt;U&gt; Optional&lt;U&gt; <span class=\"title function_\">flatMap</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class=\"line\">        Objects.requireNonNull(mapper);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPresent())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> empty();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElse<ul>\n<li>如果为null返回某个默认值，否则返回具体值</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElse</span><span class=\"params\">(T other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElseGet</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> T <span class=\"title function_\">orElseGet</span><span class=\"params\">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value != <span class=\"literal\">null</span> ? value : other.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>orElseThrow</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;X <span class=\"keyword\">extends</span> <span class=\"title class_\">Throwable</span>&gt; T <span class=\"title function_\">orElseThrow</span><span class=\"params\">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class=\"keyword\">throws</span> X &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exceptionSupplier.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##总结</p>\n<blockquote>\n<p>Optional有什么用？</p>\n</blockquote>\n<ul>\n<li>简化代码<ul>\n<li>类似于Lambda</li>\n</ul>\n</li>\n<li>能一定程度避免空指针<ul>\n<li>比如：optional.ifPresent(…)等</li>\n</ul>\n</li>\n<li>增加可读性<ul>\n<li>比如：optional.ifPresent(…).orElse(…);是不是比if／else分支更可读呢？</li>\n</ul>\n</li>\n</ul>"},{"title":"Java8新特性（流性能）","date":"2017-12-30T05:15:49.000Z","_content":">上期介绍了Java8中`Stream`的新特性，本期我们将测试下`stream`与`parallelStream`的性能以及应用的场景。\n\n<!--more-->\n##先上代码\n\n```java\npublic class StreamTest {\n\n\tprivate static final int MAX_INT = 1_000_000;\n\n\tpublic static void stream() {\n\t\tList<String> list = new ArrayList<>();\n\t\tIntStream.range(0, MAX_INT).forEach(value -> {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tlist.add(uuid.toString());\n\t\t});\n\n\t\tlong startTime = System.nanoTime();\n\n\t\tlist.stream().sorted().collect(Collectors.toList());\n\n\t\tlong endTime = System.nanoTime();\n\t\tlong durationTime = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);\n\t\tSystem.out.println(\"stream execute time : \" + durationTime);\n\t}\n\n\tpublic static void parallelStream() {\n\t\tList<String> list = new ArrayList<>();\n\t\tIntStream.range(0, MAX_INT).forEach(value -> {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tlist.add(uuid.toString());\n\t\t});\n\n\t\tlong startTime = System.nanoTime();\n\n\t\tlist.parallelStream().sorted().collect(Collectors.toList());\n\n\t\tlong endTime = System.nanoTime();\n\t\tlong durationTime = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);\n\t\tSystem.out.println(\"parallelStream execute time : \" + durationTime);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tstream();\n\t\tparallelStream();\n\t}\n}\n```\n\n>MAX_INT = 1_000_000; //Jav8中数字可以用_间隔，类似1,000,000\n\nMax_INT为**1**时，结果为：\nstream execute time : **6**\nparallelStream execute time : **8**\n\nMax_INT为**100**时，结果为：\nstream execute time : **7**\nparallelStream execute time : **7**\n\nMax_INT为**1_000**时，结果为：\nstream execute time : **15**\nparallelStream execute time : **22**\n\nMax_INT为**10_000**时，结果为：\nstream execute time : **28**\nparallelStream execute time : **21**\n\nMax_INT为**100_000**时，结果为：\nstream execute time : **98**\nparallelStream execute time : **62**\n\nMax_INT为**1_000_000**时，结果为：\nstream execute time : **742**\nparallelStream execute time : **429**\n\nMax_INT为**5_000_000**时，结果为：\nstream execute time : **4299**\nparallelStream execute time : **2191**\n\nMax_INT为**10_000_000**时，结果为：\nstream execute time : **9849**\nparallelStream execute time : **6923**\n\n##分析\n>并行适用的场景？\n\n+ 有大量的元素要处理\n+ 性能问题是首要考虑的\n+ 没有在一个多线程的环境中\n\n>所以如Java Web应用，底层都是Servlet，我们知道，Servlet是多线程的，所以在web应用中并行流并不适用，而对于数据的处理、算法的验证等单线程环境是适用的。\n\n##原理\n\n并行流底层其实是`ForkJoinPool` ，用的是`分治法`，即`Fork/Join`方法\n\n当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线 程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。\n\n相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。\n\n```java\npublic static void main(String[] args) {\n\tForkJoinPool pool = ForkJoinPool.commonPool();\n\tSystem.out.println(pool.getParallelism());\n}\n```\n结果：\n3\n\n我们可以通过参数来修改：\n\n```java\n-Djava.util.concurrent.ForkJoinPool.common.parallelism=10\n```\n\n结果：\n10\n\n##总结\n>如何高效使用并行流？\n\n+ 如果用循环还是顺序流或者是并行流，像我们上面那样测试一下；\n+ 注意装箱，尽量使用`IntStream`, `LongStream`，和`DoubleStream`来避免装箱拆箱;\n+ 有些操作在并行流上性能很差，比如`limit`，`findFirst`等依赖顺序的操作。`unordered`方法可以把有序流转为无序流，使用`findAny`等好很多，在无序流上用`limit`也好很多;\n+ 计算流水线操作总成本，处理单个元素用时越多，并行就越划算；\n+ 对于较小的数据量，用并行不一定是好事儿；\n+ 区分单线程和多线程，多线程下并行不一定是好事儿；\n+ 数据结果是否易于分解，比如`ArrayList`比`LinkedList`易于分解，`range`创建的原始流也易于分解；\n+ 终端操作中的合并大家是否很大，大了也不划算。","source":"_posts/java8-stream-performance.md","raw":"title: Java8新特性（流性能）\ndate: 2017-12-30 13:15:49\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期介绍了Java8中`Stream`的新特性，本期我们将测试下`stream`与`parallelStream`的性能以及应用的场景。\n\n<!--more-->\n##先上代码\n\n```java\npublic class StreamTest {\n\n\tprivate static final int MAX_INT = 1_000_000;\n\n\tpublic static void stream() {\n\t\tList<String> list = new ArrayList<>();\n\t\tIntStream.range(0, MAX_INT).forEach(value -> {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tlist.add(uuid.toString());\n\t\t});\n\n\t\tlong startTime = System.nanoTime();\n\n\t\tlist.stream().sorted().collect(Collectors.toList());\n\n\t\tlong endTime = System.nanoTime();\n\t\tlong durationTime = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);\n\t\tSystem.out.println(\"stream execute time : \" + durationTime);\n\t}\n\n\tpublic static void parallelStream() {\n\t\tList<String> list = new ArrayList<>();\n\t\tIntStream.range(0, MAX_INT).forEach(value -> {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tlist.add(uuid.toString());\n\t\t});\n\n\t\tlong startTime = System.nanoTime();\n\n\t\tlist.parallelStream().sorted().collect(Collectors.toList());\n\n\t\tlong endTime = System.nanoTime();\n\t\tlong durationTime = TimeUnit.NANOSECONDS.toMillis(endTime - startTime);\n\t\tSystem.out.println(\"parallelStream execute time : \" + durationTime);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tstream();\n\t\tparallelStream();\n\t}\n}\n```\n\n>MAX_INT = 1_000_000; //Jav8中数字可以用_间隔，类似1,000,000\n\nMax_INT为**1**时，结果为：\nstream execute time : **6**\nparallelStream execute time : **8**\n\nMax_INT为**100**时，结果为：\nstream execute time : **7**\nparallelStream execute time : **7**\n\nMax_INT为**1_000**时，结果为：\nstream execute time : **15**\nparallelStream execute time : **22**\n\nMax_INT为**10_000**时，结果为：\nstream execute time : **28**\nparallelStream execute time : **21**\n\nMax_INT为**100_000**时，结果为：\nstream execute time : **98**\nparallelStream execute time : **62**\n\nMax_INT为**1_000_000**时，结果为：\nstream execute time : **742**\nparallelStream execute time : **429**\n\nMax_INT为**5_000_000**时，结果为：\nstream execute time : **4299**\nparallelStream execute time : **2191**\n\nMax_INT为**10_000_000**时，结果为：\nstream execute time : **9849**\nparallelStream execute time : **6923**\n\n##分析\n>并行适用的场景？\n\n+ 有大量的元素要处理\n+ 性能问题是首要考虑的\n+ 没有在一个多线程的环境中\n\n>所以如Java Web应用，底层都是Servlet，我们知道，Servlet是多线程的，所以在web应用中并行流并不适用，而对于数据的处理、算法的验证等单线程环境是适用的。\n\n##原理\n\n并行流底层其实是`ForkJoinPool` ，用的是`分治法`，即`Fork/Join`方法\n\n当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线 程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。\n\n相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。\n\n```java\npublic static void main(String[] args) {\n\tForkJoinPool pool = ForkJoinPool.commonPool();\n\tSystem.out.println(pool.getParallelism());\n}\n```\n结果：\n3\n\n我们可以通过参数来修改：\n\n```java\n-Djava.util.concurrent.ForkJoinPool.common.parallelism=10\n```\n\n结果：\n10\n\n##总结\n>如何高效使用并行流？\n\n+ 如果用循环还是顺序流或者是并行流，像我们上面那样测试一下；\n+ 注意装箱，尽量使用`IntStream`, `LongStream`，和`DoubleStream`来避免装箱拆箱;\n+ 有些操作在并行流上性能很差，比如`limit`，`findFirst`等依赖顺序的操作。`unordered`方法可以把有序流转为无序流，使用`findAny`等好很多，在无序流上用`limit`也好很多;\n+ 计算流水线操作总成本，处理单个元素用时越多，并行就越划算；\n+ 对于较小的数据量，用并行不一定是好事儿；\n+ 区分单线程和多线程，多线程下并行不一定是好事儿；\n+ 数据结果是否易于分解，比如`ArrayList`比`LinkedList`易于分解，`range`创建的原始流也易于分解；\n+ 终端操作中的合并大家是否很大，大了也不划算。","slug":"java8-stream-performance","published":1,"updated":"2025-03-07T13:26:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2e000wrz5m9qrkf66g","content":"<blockquote>\n<p>上期介绍了Java8中<code>Stream</code>的新特性，本期我们将测试下<code>stream</code>与<code>parallelStream</code>的性能以及应用的场景。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##先上代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_INT</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, MAX_INT).forEach(value -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">UUID</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID();</span><br><span class=\"line\">\t\t\tlist.add(uuid.toString());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist.stream().sorted().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">durationTime</span> <span class=\"operator\">=</span> TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stream execute time : &quot;</span> + durationTime);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parallelStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, MAX_INT).forEach(value -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">UUID</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID();</span><br><span class=\"line\">\t\t\tlist.add(uuid.toString());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist.parallelStream().sorted().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">durationTime</span> <span class=\"operator\">=</span> TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;parallelStream execute time : &quot;</span> + durationTime);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tstream();</span><br><span class=\"line\">\t\tparallelStream();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MAX_INT &#x3D; 1_000_000; &#x2F;&#x2F;Jav8中数字可以用_间隔，类似1,000,000</p>\n</blockquote>\n<p>Max_INT为<strong>1</strong>时，结果为：<br>stream execute time : <strong>6</strong><br>parallelStream execute time : <strong>8</strong></p>\n<p>Max_INT为<strong>100</strong>时，结果为：<br>stream execute time : <strong>7</strong><br>parallelStream execute time : <strong>7</strong></p>\n<p>Max_INT为<strong>1_000</strong>时，结果为：<br>stream execute time : <strong>15</strong><br>parallelStream execute time : <strong>22</strong></p>\n<p>Max_INT为<strong>10_000</strong>时，结果为：<br>stream execute time : <strong>28</strong><br>parallelStream execute time : <strong>21</strong></p>\n<p>Max_INT为<strong>100_000</strong>时，结果为：<br>stream execute time : <strong>98</strong><br>parallelStream execute time : <strong>62</strong></p>\n<p>Max_INT为<strong>1_000_000</strong>时，结果为：<br>stream execute time : <strong>742</strong><br>parallelStream execute time : <strong>429</strong></p>\n<p>Max_INT为<strong>5_000_000</strong>时，结果为：<br>stream execute time : <strong>4299</strong><br>parallelStream execute time : <strong>2191</strong></p>\n<p>Max_INT为<strong>10_000_000</strong>时，结果为：<br>stream execute time : <strong>9849</strong><br>parallelStream execute time : <strong>6923</strong></p>\n<p>##分析</p>\n<blockquote>\n<p>并行适用的场景？</p>\n</blockquote>\n<ul>\n<li>有大量的元素要处理</li>\n<li>性能问题是首要考虑的</li>\n<li>没有在一个多线程的环境中</li>\n</ul>\n<blockquote>\n<p>所以如Java Web应用，底层都是Servlet，我们知道，Servlet是多线程的，所以在web应用中并行流并不适用，而对于数据的处理、算法的验证等单线程环境是适用的。</p>\n</blockquote>\n<p>##原理</p>\n<p>并行流底层其实是<code>ForkJoinPool</code> ，用的是<code>分治法</code>，即<code>Fork/Join</code>方法</p>\n<p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线 程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>\n<p>相对于一般的线程池实现，fork&#x2F;join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork&#x2F;join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> ForkJoinPool.commonPool();</span><br><span class=\"line\">\tSystem.out.println(pool.getParallelism());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：<br>3</p>\n<p>我们可以通过参数来修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.util.concurrent.ForkJoinPool.common.parallelism=<span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>结果：<br>10</p>\n<p>##总结</p>\n<blockquote>\n<p>如何高效使用并行流？</p>\n</blockquote>\n<ul>\n<li>如果用循环还是顺序流或者是并行流，像我们上面那样测试一下；</li>\n<li>注意装箱，尽量使用<code>IntStream</code>, <code>LongStream</code>，和<code>DoubleStream</code>来避免装箱拆箱;</li>\n<li>有些操作在并行流上性能很差，比如<code>limit</code>，<code>findFirst</code>等依赖顺序的操作。<code>unordered</code>方法可以把有序流转为无序流，使用<code>findAny</code>等好很多，在无序流上用<code>limit</code>也好很多;</li>\n<li>计算流水线操作总成本，处理单个元素用时越多，并行就越划算；</li>\n<li>对于较小的数据量，用并行不一定是好事儿；</li>\n<li>区分单线程和多线程，多线程下并行不一定是好事儿；</li>\n<li>数据结果是否易于分解，比如<code>ArrayList</code>比<code>LinkedList</code>易于分解，<code>range</code>创建的原始流也易于分解；</li>\n<li>终端操作中的合并大家是否很大，大了也不划算。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期介绍了Java8中<code>Stream</code>的新特性，本期我们将测试下<code>stream</code>与<code>parallelStream</code>的性能以及应用的场景。</p>\n</blockquote>","more":"<p>##先上代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StreamTest</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_INT</span> <span class=\"operator\">=</span> <span class=\"number\">1_000_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, MAX_INT).forEach(value -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">UUID</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID();</span><br><span class=\"line\">\t\t\tlist.add(uuid.toString());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist.stream().sorted().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">durationTime</span> <span class=\"operator\">=</span> TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stream execute time : &quot;</span> + durationTime);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">parallelStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">\t\tIntStream.range(<span class=\"number\">0</span>, MAX_INT).forEach(value -&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">UUID</span> <span class=\"variable\">uuid</span> <span class=\"operator\">=</span> UUID.randomUUID();</span><br><span class=\"line\">\t\t\tlist.add(uuid.toString());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">startTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlist.parallelStream().sorted().collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">endTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"variable\">durationTime</span> <span class=\"operator\">=</span> TimeUnit.NANOSECONDS.toMillis(endTime - startTime);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;parallelStream execute time : &quot;</span> + durationTime);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tstream();</span><br><span class=\"line\">\t\tparallelStream();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MAX_INT &#x3D; 1_000_000; &#x2F;&#x2F;Jav8中数字可以用_间隔，类似1,000,000</p>\n</blockquote>\n<p>Max_INT为<strong>1</strong>时，结果为：<br>stream execute time : <strong>6</strong><br>parallelStream execute time : <strong>8</strong></p>\n<p>Max_INT为<strong>100</strong>时，结果为：<br>stream execute time : <strong>7</strong><br>parallelStream execute time : <strong>7</strong></p>\n<p>Max_INT为<strong>1_000</strong>时，结果为：<br>stream execute time : <strong>15</strong><br>parallelStream execute time : <strong>22</strong></p>\n<p>Max_INT为<strong>10_000</strong>时，结果为：<br>stream execute time : <strong>28</strong><br>parallelStream execute time : <strong>21</strong></p>\n<p>Max_INT为<strong>100_000</strong>时，结果为：<br>stream execute time : <strong>98</strong><br>parallelStream execute time : <strong>62</strong></p>\n<p>Max_INT为<strong>1_000_000</strong>时，结果为：<br>stream execute time : <strong>742</strong><br>parallelStream execute time : <strong>429</strong></p>\n<p>Max_INT为<strong>5_000_000</strong>时，结果为：<br>stream execute time : <strong>4299</strong><br>parallelStream execute time : <strong>2191</strong></p>\n<p>Max_INT为<strong>10_000_000</strong>时，结果为：<br>stream execute time : <strong>9849</strong><br>parallelStream execute time : <strong>6923</strong></p>\n<p>##分析</p>\n<blockquote>\n<p>并行适用的场景？</p>\n</blockquote>\n<ul>\n<li>有大量的元素要处理</li>\n<li>性能问题是首要考虑的</li>\n<li>没有在一个多线程的环境中</li>\n</ul>\n<blockquote>\n<p>所以如Java Web应用，底层都是Servlet，我们知道，Servlet是多线程的，所以在web应用中并行流并不适用，而对于数据的处理、算法的验证等单线程环境是适用的。</p>\n</blockquote>\n<p>##原理</p>\n<p>并行流底层其实是<code>ForkJoinPool</code> ，用的是<code>分治法</code>，即<code>Fork/Join</code>方法</p>\n<p>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线 程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>\n<p>相对于一般的线程池实现，fork&#x2F;join框架的优势体现在对其中包含的任务的处理方式上，在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态。而在fork&#x2F;join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行。这种方式减少了线程的等待时间，提高了性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">ForkJoinPool</span> <span class=\"variable\">pool</span> <span class=\"operator\">=</span> ForkJoinPool.commonPool();</span><br><span class=\"line\">\tSystem.out.println(pool.getParallelism());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：<br>3</p>\n<p>我们可以通过参数来修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.util.concurrent.ForkJoinPool.common.parallelism=<span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>结果：<br>10</p>\n<p>##总结</p>\n<blockquote>\n<p>如何高效使用并行流？</p>\n</blockquote>\n<ul>\n<li>如果用循环还是顺序流或者是并行流，像我们上面那样测试一下；</li>\n<li>注意装箱，尽量使用<code>IntStream</code>, <code>LongStream</code>，和<code>DoubleStream</code>来避免装箱拆箱;</li>\n<li>有些操作在并行流上性能很差，比如<code>limit</code>，<code>findFirst</code>等依赖顺序的操作。<code>unordered</code>方法可以把有序流转为无序流，使用<code>findAny</code>等好很多，在无序流上用<code>limit</code>也好很多;</li>\n<li>计算流水线操作总成本，处理单个元素用时越多，并行就越划算；</li>\n<li>对于较小的数据量，用并行不一定是好事儿；</li>\n<li>区分单线程和多线程，多线程下并行不一定是好事儿；</li>\n<li>数据结果是否易于分解，比如<code>ArrayList</code>比<code>LinkedList</code>易于分解，<code>range</code>创建的原始流也易于分解；</li>\n<li>终端操作中的合并大家是否很大，大了也不划算。</li>\n</ul>"},{"title":"Java8新特性（引用）","date":"2017-12-25T15:22:56.000Z","_content":">上期我们分析了Java8中的Lambda表达式，本期我们将分析Java8中的引用。\n\n<!--more-->\n##一、方法引用\n###定义\n>若Lambda体中的功能，已经有方法提供实现，可以使用方法引用，可以将方法引用理解为Lambda 表达式的另外一种表现形式。\n\n###格式\n方法引用的具体形式为：\n\n####1. 对象的引用 :: 实例方法名\n\n```java\npublic class People implements Serializable {\n\tprivate static final long serialVersionUID = -2052988928272007869L;\n\tprivate String id;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tPeople p = new People();\n\t\t// Supplier<String> supplier = () -> p.getId();\n\t\tSupplier<String> supplier = p::getId;\n\t\t// Consumer<String> consumer = id -> p.setId(id);\n\t\tConsumer<String> consumer = p::setId;\n\t\t...\n\t}\n}\n```\n    \n####2. 类名 :: 静态方法名\n```java\npublic static void main(String[] args) {\n\t// Comparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n\tComparator<Integer> comparator = Integer::compare;\n\t...\n}\n```\n\n>当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数 (或无参数) 时：ClassName::methodName\n\n####3. 类名 :: 实例方法名\n```java\npublic static void main(String[] args) {\n\t// Predicate<String> predicate = x -> x.isEmpty();\n\tPredicate<String> predicate = String::isEmpty;\n\t...\n}\n```\n###总结：\n+ 方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致(就是函数签名和返回值一致)\n+ 若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName\n\n##二、构造器引用\n###定义\n>构造器的参数列表，需要与函数式接口中参数列表保持一致 (就是函数签名一致)\n\n###格式\n类名 :: new\n\n```java\npublic class People implements Serializable {\n\tprivate static final long serialVersionUID = -2052988928272007869L;\n\tprivate String id;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// Supplier<People> supplier = () -> new People();\n\t\tSupplier<People> supplier = People::new;\n\t\t...\n\t}\n}\n```\n\n##三、数组引用\n###格式\n类型[] :: new\n\n```java\npublic static void main(String[] args) {\n\tFunction<Integer, People[]> function = People[]::new;\n\tPeople[] peoples = function.apply(10);\n}\n```\n\n>####**下期我们将分析Java8中的流：Stream，敬请期待。**\n\n","source":"_posts/java8-reference.md","raw":"title: Java8新特性（引用）\ndate: 2017-12-25 23:22:56\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们分析了Java8中的Lambda表达式，本期我们将分析Java8中的引用。\n\n<!--more-->\n##一、方法引用\n###定义\n>若Lambda体中的功能，已经有方法提供实现，可以使用方法引用，可以将方法引用理解为Lambda 表达式的另外一种表现形式。\n\n###格式\n方法引用的具体形式为：\n\n####1. 对象的引用 :: 实例方法名\n\n```java\npublic class People implements Serializable {\n\tprivate static final long serialVersionUID = -2052988928272007869L;\n\tprivate String id;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tPeople p = new People();\n\t\t// Supplier<String> supplier = () -> p.getId();\n\t\tSupplier<String> supplier = p::getId;\n\t\t// Consumer<String> consumer = id -> p.setId(id);\n\t\tConsumer<String> consumer = p::setId;\n\t\t...\n\t}\n}\n```\n    \n####2. 类名 :: 静态方法名\n```java\npublic static void main(String[] args) {\n\t// Comparator<Integer> comparator = (x, y) -> Integer.compare(x, y);\n\tComparator<Integer> comparator = Integer::compare;\n\t...\n}\n```\n\n>当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数 (或无参数) 时：ClassName::methodName\n\n####3. 类名 :: 实例方法名\n```java\npublic static void main(String[] args) {\n\t// Predicate<String> predicate = x -> x.isEmpty();\n\tPredicate<String> predicate = String::isEmpty;\n\t...\n}\n```\n###总结：\n+ 方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致(就是函数签名和返回值一致)\n+ 若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName\n\n##二、构造器引用\n###定义\n>构造器的参数列表，需要与函数式接口中参数列表保持一致 (就是函数签名一致)\n\n###格式\n类名 :: new\n\n```java\npublic class People implements Serializable {\n\tprivate static final long serialVersionUID = -2052988928272007869L;\n\tprivate String id;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// Supplier<People> supplier = () -> new People();\n\t\tSupplier<People> supplier = People::new;\n\t\t...\n\t}\n}\n```\n\n##三、数组引用\n###格式\n类型[] :: new\n\n```java\npublic static void main(String[] args) {\n\tFunction<Integer, People[]> function = People[]::new;\n\tPeople[] peoples = function.apply(10);\n}\n```\n\n>####**下期我们将分析Java8中的流：Stream，敬请期待。**\n\n","slug":"java8-reference","published":1,"updated":"2025-03-07T13:26:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2g000yrz5m95akbbk0","content":"<blockquote>\n<p>上期我们分析了Java8中的Lambda表达式，本期我们将分析Java8中的引用。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##一、方法引用<br>###定义</p>\n<blockquote>\n<p>若Lambda体中的功能，已经有方法提供实现，可以使用方法引用，可以将方法引用理解为Lambda 表达式的另外一种表现形式。</p>\n</blockquote>\n<p>###格式<br>方法引用的具体形式为：</p>\n<p>####1. 对象的引用 :: 实例方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2052988928272007869L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">People</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">People</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// Supplier&lt;String&gt; supplier = () -&gt; p.getId();</span></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; supplier = p::getId;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Consumer&lt;String&gt; consumer = id -&gt; p.setId(id);</span></span><br><span class=\"line\">\t\tConsumer&lt;String&gt; consumer = p::setId;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####2. 类名 :: 静态方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span></span><br><span class=\"line\">\tComparator&lt;Integer&gt; comparator = Integer::compare;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数 (或无参数) 时：ClassName::methodName</p>\n</blockquote>\n<p>####3. 类名 :: 实例方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Predicate&lt;String&gt; predicate = x -&gt; x.isEmpty();</span></span><br><span class=\"line\">\tPredicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###总结：</p>\n<ul>\n<li>方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致(就是函数签名和返回值一致)</li>\n<li>若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName</li>\n</ul>\n<p>##二、构造器引用<br>###定义</p>\n<blockquote>\n<p>构造器的参数列表，需要与函数式接口中参数列表保持一致 (就是函数签名一致)</p>\n</blockquote>\n<p>###格式<br>类名 :: new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2052988928272007869L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Supplier&lt;People&gt; supplier = () -&gt; new People();</span></span><br><span class=\"line\">\t\tSupplier&lt;People&gt; supplier = People::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##三、数组引用<br>###格式<br>类型[] :: new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tFunction&lt;Integer, People[]&gt; function = People[]::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\tPeople[] peoples = function.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>####<strong>下期我们将分析Java8中的流：Stream，敬请期待。</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分析了Java8中的Lambda表达式，本期我们将分析Java8中的引用。</p>\n</blockquote>","more":"<p>##一、方法引用<br>###定义</p>\n<blockquote>\n<p>若Lambda体中的功能，已经有方法提供实现，可以使用方法引用，可以将方法引用理解为Lambda 表达式的另外一种表现形式。</p>\n</blockquote>\n<p>###格式<br>方法引用的具体形式为：</p>\n<p>####1. 对象的引用 :: 实例方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2052988928272007869L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">People</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">People</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// Supplier&lt;String&gt; supplier = () -&gt; p.getId();</span></span><br><span class=\"line\">\t\tSupplier&lt;String&gt; supplier = p::getId;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Consumer&lt;String&gt; consumer = id -&gt; p.setId(id);</span></span><br><span class=\"line\">\t\tConsumer&lt;String&gt; consumer = p::setId;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####2. 类名 :: 静态方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span></span><br><span class=\"line\">\tComparator&lt;Integer&gt; comparator = Integer::compare;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个参数 (或无参数) 时：ClassName::methodName</p>\n</blockquote>\n<p>####3. 类名 :: 实例方法名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Predicate&lt;String&gt; predicate = x -&gt; x.isEmpty();</span></span><br><span class=\"line\">\tPredicate&lt;String&gt; predicate = String::isEmpty;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###总结：</p>\n<ul>\n<li>方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致(就是函数签名和返回值一致)</li>\n<li>若Lambda的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式：ClassName::MethodName</li>\n</ul>\n<p>##二、构造器引用<br>###定义</p>\n<blockquote>\n<p>构造器的参数列表，需要与函数式接口中参数列表保持一致 (就是函数签名一致)</p>\n</blockquote>\n<p>###格式<br>类名 :: new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">People</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> -<span class=\"number\">2052988928272007869L</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(String id)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Supplier&lt;People&gt; supplier = () -&gt; new People();</span></span><br><span class=\"line\">\t\tSupplier&lt;People&gt; supplier = People::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##三、数组引用<br>###格式<br>类型[] :: new</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tFunction&lt;Integer, People[]&gt; function = People[]::<span class=\"keyword\">new</span>;</span><br><span class=\"line\">\tPeople[] peoples = function.apply(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>####<strong>下期我们将分析Java8中的流：Stream，敬请期待。</strong></p>\n</blockquote>"},{"title":"Java8新特性（Interface）","date":"2017-12-21T15:34:22.000Z","_content":">在Java8版本以前，Interface接口中所有的方法都是`抽象方法`和`常量`，那么在Java8中，Interface有什么新特性呢？\n\n<!--more-->\n##静态成员\n>在Java8以前，我们要定义一些常量，一般会写一个类，类中都是`final static`的一些变量，如下：\n\n```java\npublic class Constants {\n\tpublic static final int MAX_SERVICE_TIME = 100;\n}\n\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Constants.MAX_SERVICE_TIME);\n\t}\n}\n```\n\n>在Java8中Interface支持`静态成员`，成员默认是`public final static`的，可以在类外直接调用。\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n}\n\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(MyInterface.MAX_SERVICE_TIME);\n\t}\n}\n```\n\n##default函数\n>在Java8以前，Interface中的函数是不能实现的，如下：\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n\n\tvoid test();\n}\n```\n\n>在Java8中，Interface中支持函数有实现，只要在函数前加上`default`关键字即可，如下：\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n\n\tvoid test();\n\t\n\tdefault void doSomething() {\n\t\tSystem.out.println(\"do something\");\n\t}\n}\n```\n\n>`default`函数，实现类可以不实现这个方法，如果不想子类去实现的一些方法，可以写成`default`函数。\n>\n>在Java8之前，如果我们想实现这样的功能，也是有办法的，那就是先定义`Interface`，然后定义`Abstract Class`实现`Interface`，然后再定义`Class`继承`Abstract Class`，这样`Class`就不用实现`Interface`中的全部方法。\n\n##static函数\n>在Java8中允许Interface定义`static`方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练，如下：\n\n```java\npublic interface MyInterface {\n\tdefault void doSomething() {\n\t\tSystem.out.println(\"do something\");\n\t}\n}\n\npublic class MyClass implements MyInterface {\n\n}\n\npublic interface MyClassFactory {\n\tpublic static MyClass getInstance() {\n\t\treturn new MyClass();\n\t}\n}\n```\n\n##@FunctionalInterface注解\n+ 什么是`函数式接口`？\n\n>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个`Lambda`表达式作为参数。\n\n```java\n@FunctionalInterface\npublic interface MyInterface {\n\tvoid test();\n}\n```\n\n>`@FunctionalInterface`注解能帮我们检测Interface是否是函数式接口，但是这个注解**是非必须的，不加也不会报错**。\n\n```java\n@FunctionalInterface\npublic interface MyInterface {//报错\n\tvoid test();\n\n\tvoid doSomething();\n}\n```\n\n>Interface中的`非default／static方法都是abstract的`，所以上面的接口不是函数式接口，加上@FunctionalInterface的话，就会提示我们这不是一个函数式接口。\n\n+ 函数式接口的作用？\n\n>函数式接口，可以在调用时，使用一个lambda表达式作为参数。\n>\n>###所以，Java8下一个特性即是Lambda表达式，请看下回详解。\n\n\n","source":"_posts/java8-interface.md","raw":"title: Java8新特性（Interface）\ndate: 2017-12-21 23:34:22\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>在Java8版本以前，Interface接口中所有的方法都是`抽象方法`和`常量`，那么在Java8中，Interface有什么新特性呢？\n\n<!--more-->\n##静态成员\n>在Java8以前，我们要定义一些常量，一般会写一个类，类中都是`final static`的一些变量，如下：\n\n```java\npublic class Constants {\n\tpublic static final int MAX_SERVICE_TIME = 100;\n}\n\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Constants.MAX_SERVICE_TIME);\n\t}\n}\n```\n\n>在Java8中Interface支持`静态成员`，成员默认是`public final static`的，可以在类外直接调用。\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n}\n\npublic class Hello {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(MyInterface.MAX_SERVICE_TIME);\n\t}\n}\n```\n\n##default函数\n>在Java8以前，Interface中的函数是不能实现的，如下：\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n\n\tvoid test();\n}\n```\n\n>在Java8中，Interface中支持函数有实现，只要在函数前加上`default`关键字即可，如下：\n\n```java\npublic interface MyInterface {\n\tint MAX_SERVICE_TIME = 100;\n\n\tvoid test();\n\t\n\tdefault void doSomething() {\n\t\tSystem.out.println(\"do something\");\n\t}\n}\n```\n\n>`default`函数，实现类可以不实现这个方法，如果不想子类去实现的一些方法，可以写成`default`函数。\n>\n>在Java8之前，如果我们想实现这样的功能，也是有办法的，那就是先定义`Interface`，然后定义`Abstract Class`实现`Interface`，然后再定义`Class`继承`Abstract Class`，这样`Class`就不用实现`Interface`中的全部方法。\n\n##static函数\n>在Java8中允许Interface定义`static`方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练，如下：\n\n```java\npublic interface MyInterface {\n\tdefault void doSomething() {\n\t\tSystem.out.println(\"do something\");\n\t}\n}\n\npublic class MyClass implements MyInterface {\n\n}\n\npublic interface MyClassFactory {\n\tpublic static MyClass getInstance() {\n\t\treturn new MyClass();\n\t}\n}\n```\n\n##@FunctionalInterface注解\n+ 什么是`函数式接口`？\n\n>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个`Lambda`表达式作为参数。\n\n```java\n@FunctionalInterface\npublic interface MyInterface {\n\tvoid test();\n}\n```\n\n>`@FunctionalInterface`注解能帮我们检测Interface是否是函数式接口，但是这个注解**是非必须的，不加也不会报错**。\n\n```java\n@FunctionalInterface\npublic interface MyInterface {//报错\n\tvoid test();\n\n\tvoid doSomething();\n}\n```\n\n>Interface中的`非default／static方法都是abstract的`，所以上面的接口不是函数式接口，加上@FunctionalInterface的话，就会提示我们这不是一个函数式接口。\n\n+ 函数式接口的作用？\n\n>函数式接口，可以在调用时，使用一个lambda表达式作为参数。\n>\n>###所以，Java8下一个特性即是Lambda表达式，请看下回详解。\n\n\n","slug":"java8-interface","published":1,"updated":"2025-03-07T13:26:47.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2g0011rz5mcwbg7l3u","content":"<blockquote>\n<p>在Java8版本以前，Interface接口中所有的方法都是<code>抽象方法</code>和<code>常量</code>，那么在Java8中，Interface有什么新特性呢？</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##静态成员</p>\n<blockquote>\n<p>在Java8以前，我们要定义一些常量，一般会写一个类，类中都是<code>final static</code>的一些变量，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Constants</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(Constants.MAX_SERVICE_TIME);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Java8中Interface支持<code>静态成员</code>，成员默认是<code>public final static</code>的，可以在类外直接调用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(MyInterface.MAX_SERVICE_TIME);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##default函数</p>\n<blockquote>\n<p>在Java8以前，Interface中的函数是不能实现的，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Java8中，Interface中支持函数有实现，只要在函数前加上<code>default</code>关键字即可，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;do something&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>default</code>函数，实现类可以不实现这个方法，如果不想子类去实现的一些方法，可以写成<code>default</code>函数。</p>\n<p>在Java8之前，如果我们想实现这样的功能，也是有办法的，那就是先定义<code>Interface</code>，然后定义<code>Abstract Class</code>实现<code>Interface</code>，然后再定义<code>Class</code>继承<code>Abstract Class</code>，这样<code>Class</code>就不用实现<code>Interface</code>中的全部方法。</p>\n</blockquote>\n<p>##static函数</p>\n<blockquote>\n<p>在Java8中允许Interface定义<code>static</code>方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;do something&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyClassFactory</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyClass <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##@FunctionalInterface注解</p>\n<ul>\n<li>什么是<code>函数式接口</code>？</li>\n</ul>\n<blockquote>\n<p>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个<code>Lambda</code>表达式作为参数。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@FunctionalInterface</code>注解能帮我们检测Interface是否是函数式接口，但是这个注解<strong>是非必须的，不加也不会报错</strong>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;<span class=\"comment\">//报错</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Interface中的<code>非default／static方法都是abstract的</code>，所以上面的接口不是函数式接口，加上@FunctionalInterface的话，就会提示我们这不是一个函数式接口。</p>\n</blockquote>\n<ul>\n<li>函数式接口的作用？</li>\n</ul>\n<blockquote>\n<p>函数式接口，可以在调用时，使用一个lambda表达式作为参数。</p>\n<p>###所以，Java8下一个特性即是Lambda表达式，请看下回详解。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在Java8版本以前，Interface接口中所有的方法都是<code>抽象方法</code>和<code>常量</code>，那么在Java8中，Interface有什么新特性呢？</p>\n</blockquote>","more":"<p>##静态成员</p>\n<blockquote>\n<p>在Java8以前，我们要定义一些常量，一般会写一个类，类中都是<code>final static</code>的一些变量，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Constants</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(Constants.MAX_SERVICE_TIME);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Java8中Interface支持<code>静态成员</code>，成员默认是<code>public final static</code>的，可以在类外直接调用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Hello</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(MyInterface.MAX_SERVICE_TIME);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##default函数</p>\n<blockquote>\n<p>在Java8以前，Interface中的函数是不能实现的，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Java8中，Interface中支持函数有实现，只要在函数前加上<code>default</code>关键字即可，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">MAX_SERVICE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;do something&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>default</code>函数，实现类可以不实现这个方法，如果不想子类去实现的一些方法，可以写成<code>default</code>函数。</p>\n<p>在Java8之前，如果我们想实现这样的功能，也是有办法的，那就是先定义<code>Interface</code>，然后定义<code>Abstract Class</code>实现<code>Interface</code>，然后再定义<code>Class</code>继承<code>Abstract Class</code>，这样<code>Class</code>就不用实现<code>Interface</code>中的全部方法。</p>\n</blockquote>\n<p>##static函数</p>\n<blockquote>\n<p>在Java8中允许Interface定义<code>static</code>方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练，如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;do something&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyClassFactory</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyClass <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyClass</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##@FunctionalInterface注解</p>\n<ul>\n<li>什么是<code>函数式接口</code>？</li>\n</ul>\n<blockquote>\n<p>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个<code>Lambda</code>表达式作为参数。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@FunctionalInterface</code>注解能帮我们检测Interface是否是函数式接口，但是这个注解<strong>是非必须的，不加也不会报错</strong>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;<span class=\"comment\">//报错</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Interface中的<code>非default／static方法都是abstract的</code>，所以上面的接口不是函数式接口，加上@FunctionalInterface的话，就会提示我们这不是一个函数式接口。</p>\n</blockquote>\n<ul>\n<li>函数式接口的作用？</li>\n</ul>\n<blockquote>\n<p>函数式接口，可以在调用时，使用一个lambda表达式作为参数。</p>\n<p>###所以，Java8下一个特性即是Lambda表达式，请看下回详解。</p>\n</blockquote>"},{"title":"Java8新特性（Stream）","date":"2017-12-28T14:38:44.000Z","_content":">上期我们分析了Java8中的引用，本期我们将分析Java8中的另一个重要的新特性：流Stream。\n>本文**`图片`**转载自[并发编程网](http://ifeve.com/stream/)\n\n<!--more-->\n##Stream是什么？\n在Java8源代码中，是这么定义Stream的：\n>A sequence of elements supporting sequential and parallel aggregate operations.\n\n简单翻译就是流是支持顺序和并行的汇聚操作的一组元素。\n\n从这个定义上来说，`Stream`可以说是一个高级版本的`Iterator`，Iterator只能一个一个遍历元素从而对元素进行操作，但是Stream可以执行非常复杂的查找、过滤和映射数据等操作，并且中间操作可以一直迭代。\n\n**Collections是存储元素，Stream是计算。**\n\nStream可以理解为一个管道（`Pipeline`），数据从管道的一边进入，经过中间各种处理，然后从管道的另一边出来新的数据。\n\n几个注意点：\n\n+ 1. Stream自己不会存储元素。\n+ 2. Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。\n+ 3. Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。\n\n##Stream的pipeline\n+ 创建Stream\n+ 中间操作：一个中间操作链，对数据源数据进行处理，但是是延迟执行的\n+ 终止操作：执行中间操作链，并产生结果，正如上面注意点3\n\n##创建Stream\n####1、java.util.Collection内置了获取流的方法，分别为串行流与并行流\n\n```java\ndefault Stream<E> stream() {\n    return StreamSupport.stream(spliterator(), false);\n}\n\ndefault Stream<E> parallelStream() {\n    return StreamSupport.stream(spliterator(), true);\n}\n```\n\n####2、java.util.Arrays内置了获取流的方法\n\n```java\npublic static <T> Stream<T> stream(T[] array) {\n    return stream(array, 0, array.length);\n}\n```\n\n####3、java.util.stream.Stream内置了创建流的方法，分别为通过对象创建流和通过函数创建流\n\n```java\npublic static<T> Stream<T> of(T t) {\n    return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n\npublic static<T> Stream<T> of(T... values) {\n    return Arrays.stream(values);\n}\n\npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n    Objects.requireNonNull(f);\n    final Iterator<T> iterator = new Iterator<T>() {\n        @SuppressWarnings(\"unchecked\")\n        T t = (T) Streams.NONE;\n\n        @Override\n        public boolean hasNext() {\n            return true;\n        }\n\n        @Override\n        public T next() {\n            return t = (t == Streams.NONE) ? seed : f.apply(t);\n        }\n    };\n    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n}\n\npublic static<T> Stream<T> generate(Supplier<T> s) {\n    Objects.requireNonNull(s);\n    return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);\n}\n```\n\n##中间操作（java.util.stream.Stream）\n####1、截断与切片\n\n+ filter：过滤\n\n```java\nStream<T> filter(Predicate<? super T> predicate);\n```\n![filter](http://img03.taobaocdn.com/imgextra/i3/90219132/T2OxXnXPlXXXXXXXXX_!!90219132.jpg)\n\n+ distinct：去除重复元素（通过equals和hashCode）\n\n```java\nStream<T> distinct();\n```\n![distinct](http://img04.taobaocdn.com/imgextra/i4/90219132/T2K0lnXPRXXXXXXXXX_!!90219132.jpg)\n\n+ limit：限制数量\n\n```java\nStream<T> limit(long maxSize);\n```\n![limit](http://img02.taobaocdn.com/imgextra/i2/90219132/T2QAXlXJBaXXXXXXXX_!!90219132.jpg)\n\n+ skip：跳过\n\n```java\nStream<T> skip(long n);\n```\n![skip](http://img04.taobaocdn.com/imgextra/i4/90219132/T24A8mXUJXXXXXXXXX_!!90219132.jpg)\n\n是不是有点类似SQL语句呢？\n\n####2、映射\n\n+ map\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n![map](http://img03.taobaocdn.com/imgextra/i3/90219132/T2PQJnXOJXXXXXXXXX_!!90219132.jpg)\n\n+ mapToInt\n+ mapToLong\n+ mapToDouble\n\n+ flatMap\n\n```java\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n```\n![flatMap](http://img01.taobaocdn.com/imgextra/i1/90219132/T2mBXnXQhXXXXXXXXX_!!90219132.jpg)\n\n+ flatMapToInt\n+ flatMapToLong\n+ flatMapToDouble\n\n####3、排序\n\n+ sorted\n\n```java\nStream<T> sorted();\nStream<T> sorted(Comparator<? super T> comparator);\n```\n\n####4、包装\n\n+ peek\n\n```java\nStream<T> peek(Consumer<? super T> action);\n```\n![peek](http://img03.taobaocdn.com/imgextra/i3/90219132/T2DrFmXHtaXXXXXXXX_!!90219132.jpg)\n\n##终止操作\n####查找与匹配\n\n+ allMatch：检查是否匹配所有元素\n\n```java\nboolean allMatch(Predicate<? super T> predicate);\n```\n\n+ anyMatch：检查是否至少匹配一个元素\n\n```java\nboolean anyMatch(Predicate<? super T> predicate);\n```\n\n+ noneMatch：检查是否没有匹配所有元素\n\n```java\nboolean noneMatch(Predicate<? super T> predicate);\n```\n\n+ findFirst：返回第一个元素\n\n```java\nOptional<T> findFirst();\n```\n\n+ findAny：返回当前流中的任意元素\n\n```java\nOptional<T> findAny();\n```\n\n+ count：返回流中元素总数\n\n```java\nlong count();\n```\n\n+ max：返回流中最大值\n\n```java\nOptional<T> max(Comparator<? super T> comparator);\n```\n\n+ min：返回流中最小值\n\n```java\nOptional<T> min(Comparator<? super T> comparator);\n```\n\n+ forEach：内部迭代\n\n```java\nvoid forEach(Consumer<? super T> action);\n```\n\n####规约\n\n+ reduce\n\n```java\nT reduce(T identity, BinaryOperator<T> accumulator);\n\nOptional<T> reduce(BinaryOperator<T> accumulator);\n\n<U> U reduce(U identity,\n                 BiFunction<U, ? super T, U> accumulator,\n                 BinaryOperator<U> combiner);\n```\n\n####收集\n\n+ collect\n\n```java\n<R, A> R collect(Collector<? super T, A, R> collector);\n\n<R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n```\n\n+ Collectors静态方法\n\n```java\nList<T> toList()\nSet<T> toSet()\nCollection<T> toCollection\nLong counting\nInteger summingInt\nDouble averagingInt\nIntSummaryStatistics summarizingInt\nString joining\nOptional<T> maxBy\nOptional<T> minBy\n...\n```\n\n>Stream是不是很方便呢？\n>下期我们将测试下Stream中串行流与并行流的性能","source":"_posts/java8-stream.md","raw":"title: Java8新特性（Stream）\ndate: 2017-12-28 22:38:44\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们分析了Java8中的引用，本期我们将分析Java8中的另一个重要的新特性：流Stream。\n>本文**`图片`**转载自[并发编程网](http://ifeve.com/stream/)\n\n<!--more-->\n##Stream是什么？\n在Java8源代码中，是这么定义Stream的：\n>A sequence of elements supporting sequential and parallel aggregate operations.\n\n简单翻译就是流是支持顺序和并行的汇聚操作的一组元素。\n\n从这个定义上来说，`Stream`可以说是一个高级版本的`Iterator`，Iterator只能一个一个遍历元素从而对元素进行操作，但是Stream可以执行非常复杂的查找、过滤和映射数据等操作，并且中间操作可以一直迭代。\n\n**Collections是存储元素，Stream是计算。**\n\nStream可以理解为一个管道（`Pipeline`），数据从管道的一边进入，经过中间各种处理，然后从管道的另一边出来新的数据。\n\n几个注意点：\n\n+ 1. Stream自己不会存储元素。\n+ 2. Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。\n+ 3. Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。\n\n##Stream的pipeline\n+ 创建Stream\n+ 中间操作：一个中间操作链，对数据源数据进行处理，但是是延迟执行的\n+ 终止操作：执行中间操作链，并产生结果，正如上面注意点3\n\n##创建Stream\n####1、java.util.Collection内置了获取流的方法，分别为串行流与并行流\n\n```java\ndefault Stream<E> stream() {\n    return StreamSupport.stream(spliterator(), false);\n}\n\ndefault Stream<E> parallelStream() {\n    return StreamSupport.stream(spliterator(), true);\n}\n```\n\n####2、java.util.Arrays内置了获取流的方法\n\n```java\npublic static <T> Stream<T> stream(T[] array) {\n    return stream(array, 0, array.length);\n}\n```\n\n####3、java.util.stream.Stream内置了创建流的方法，分别为通过对象创建流和通过函数创建流\n\n```java\npublic static<T> Stream<T> of(T t) {\n    return StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n\npublic static<T> Stream<T> of(T... values) {\n    return Arrays.stream(values);\n}\n\npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n    Objects.requireNonNull(f);\n    final Iterator<T> iterator = new Iterator<T>() {\n        @SuppressWarnings(\"unchecked\")\n        T t = (T) Streams.NONE;\n\n        @Override\n        public boolean hasNext() {\n            return true;\n        }\n\n        @Override\n        public T next() {\n            return t = (t == Streams.NONE) ? seed : f.apply(t);\n        }\n    };\n    return StreamSupport.stream(Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.ORDERED | Spliterator.IMMUTABLE), false);\n}\n\npublic static<T> Stream<T> generate(Supplier<T> s) {\n    Objects.requireNonNull(s);\n    return StreamSupport.stream(\n                new StreamSpliterators.InfiniteSupplyingSpliterator.OfRef<>(Long.MAX_VALUE, s), false);\n}\n```\n\n##中间操作（java.util.stream.Stream）\n####1、截断与切片\n\n+ filter：过滤\n\n```java\nStream<T> filter(Predicate<? super T> predicate);\n```\n![filter](http://img03.taobaocdn.com/imgextra/i3/90219132/T2OxXnXPlXXXXXXXXX_!!90219132.jpg)\n\n+ distinct：去除重复元素（通过equals和hashCode）\n\n```java\nStream<T> distinct();\n```\n![distinct](http://img04.taobaocdn.com/imgextra/i4/90219132/T2K0lnXPRXXXXXXXXX_!!90219132.jpg)\n\n+ limit：限制数量\n\n```java\nStream<T> limit(long maxSize);\n```\n![limit](http://img02.taobaocdn.com/imgextra/i2/90219132/T2QAXlXJBaXXXXXXXX_!!90219132.jpg)\n\n+ skip：跳过\n\n```java\nStream<T> skip(long n);\n```\n![skip](http://img04.taobaocdn.com/imgextra/i4/90219132/T24A8mXUJXXXXXXXXX_!!90219132.jpg)\n\n是不是有点类似SQL语句呢？\n\n####2、映射\n\n+ map\n\n```java\n<R> Stream<R> map(Function<? super T, ? extends R> mapper);\n```\n![map](http://img03.taobaocdn.com/imgextra/i3/90219132/T2PQJnXOJXXXXXXXXX_!!90219132.jpg)\n\n+ mapToInt\n+ mapToLong\n+ mapToDouble\n\n+ flatMap\n\n```java\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n```\n![flatMap](http://img01.taobaocdn.com/imgextra/i1/90219132/T2mBXnXQhXXXXXXXXX_!!90219132.jpg)\n\n+ flatMapToInt\n+ flatMapToLong\n+ flatMapToDouble\n\n####3、排序\n\n+ sorted\n\n```java\nStream<T> sorted();\nStream<T> sorted(Comparator<? super T> comparator);\n```\n\n####4、包装\n\n+ peek\n\n```java\nStream<T> peek(Consumer<? super T> action);\n```\n![peek](http://img03.taobaocdn.com/imgextra/i3/90219132/T2DrFmXHtaXXXXXXXX_!!90219132.jpg)\n\n##终止操作\n####查找与匹配\n\n+ allMatch：检查是否匹配所有元素\n\n```java\nboolean allMatch(Predicate<? super T> predicate);\n```\n\n+ anyMatch：检查是否至少匹配一个元素\n\n```java\nboolean anyMatch(Predicate<? super T> predicate);\n```\n\n+ noneMatch：检查是否没有匹配所有元素\n\n```java\nboolean noneMatch(Predicate<? super T> predicate);\n```\n\n+ findFirst：返回第一个元素\n\n```java\nOptional<T> findFirst();\n```\n\n+ findAny：返回当前流中的任意元素\n\n```java\nOptional<T> findAny();\n```\n\n+ count：返回流中元素总数\n\n```java\nlong count();\n```\n\n+ max：返回流中最大值\n\n```java\nOptional<T> max(Comparator<? super T> comparator);\n```\n\n+ min：返回流中最小值\n\n```java\nOptional<T> min(Comparator<? super T> comparator);\n```\n\n+ forEach：内部迭代\n\n```java\nvoid forEach(Consumer<? super T> action);\n```\n\n####规约\n\n+ reduce\n\n```java\nT reduce(T identity, BinaryOperator<T> accumulator);\n\nOptional<T> reduce(BinaryOperator<T> accumulator);\n\n<U> U reduce(U identity,\n                 BiFunction<U, ? super T, U> accumulator,\n                 BinaryOperator<U> combiner);\n```\n\n####收集\n\n+ collect\n\n```java\n<R, A> R collect(Collector<? super T, A, R> collector);\n\n<R> R collect(Supplier<R> supplier,\n                  BiConsumer<R, ? super T> accumulator,\n                  BiConsumer<R, R> combiner);\n```\n\n+ Collectors静态方法\n\n```java\nList<T> toList()\nSet<T> toSet()\nCollection<T> toCollection\nLong counting\nInteger summingInt\nDouble averagingInt\nIntSummaryStatistics summarizingInt\nString joining\nOptional<T> maxBy\nOptional<T> minBy\n...\n```\n\n>Stream是不是很方便呢？\n>下期我们将测试下Stream中串行流与并行流的性能","slug":"java8-stream","published":1,"updated":"2025-03-07T13:26:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2g0014rz5m3cdq4iul","content":"<blockquote>\n<p>上期我们分析了Java8中的引用，本期我们将分析Java8中的另一个重要的新特性：流Stream。<br>本文**<code>图片</code>**转载自<a href=\"http://ifeve.com/stream/\">并发编程网</a></p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##Stream是什么？<br>在Java8源代码中，是这么定义Stream的：</p>\n<blockquote>\n<p>A sequence of elements supporting sequential and parallel aggregate operations.</p>\n</blockquote>\n<p>简单翻译就是流是支持顺序和并行的汇聚操作的一组元素。</p>\n<p>从这个定义上来说，<code>Stream</code>可以说是一个高级版本的<code>Iterator</code>，Iterator只能一个一个遍历元素从而对元素进行操作，但是Stream可以执行非常复杂的查找、过滤和映射数据等操作，并且中间操作可以一直迭代。</p>\n<p><strong>Collections是存储元素，Stream是计算。</strong></p>\n<p>Stream可以理解为一个管道（<code>Pipeline</code>），数据从管道的一边进入，经过中间各种处理，然后从管道的另一边出来新的数据。</p>\n<p>几个注意点：</p>\n<ul>\n<li><ol>\n<li>Stream自己不会存储元素。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n</li>\n</ul>\n<p>##Stream的pipeline</p>\n<ul>\n<li>创建Stream</li>\n<li>中间操作：一个中间操作链，对数据源数据进行处理，但是是延迟执行的</li>\n<li>终止操作：执行中间操作链，并产生结果，正如上面注意点3</li>\n</ul>\n<p>##创建Stream<br>####1、java.util.Collection内置了获取流的方法，分别为串行流与并行流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;E&gt; <span class=\"title function_\">stream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;E&gt; <span class=\"title function_\">parallelStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>####2、java.util.Arrays内置了获取流的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">stream</span><span class=\"params\">(T[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream(array, <span class=\"number\">0</span>, array.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>####3、java.util.stream.Stream内置了创建流的方法，分别为通过对象创建流和通过函数创建流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(<span class=\"keyword\">new</span> <span class=\"title class_\">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T... values)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.stream(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">iterate</span><span class=\"params\">(<span class=\"keyword\">final</span> T seed, <span class=\"keyword\">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(f);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Iterator&lt;T&gt; iterator = <span class=\"keyword\">new</span> <span class=\"title class_\">Iterator</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> (T) Streams.NONE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> T <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">return</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class=\"line\">                iterator,</span><br><span class=\"line\">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">generate</span><span class=\"params\">(Supplier&lt;T&gt; s)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">StreamSpliterators</span>.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##中间操作（java.util.stream.Stream）<br>####1、截断与切片</p>\n<ul>\n<li>filter：过滤</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2OxXnXPlXXXXXXXXX_!!90219132.jpg\" alt=\"filter\"></p>\n<ul>\n<li>distinct：去除重复元素（通过equals和hashCode）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">distinct</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img04.taobaocdn.com/imgextra/i4/90219132/T2K0lnXPRXXXXXXXXX_!!90219132.jpg\" alt=\"distinct\"></p>\n<ul>\n<li>limit：限制数量</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">limit</span><span class=\"params\">(<span class=\"type\">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img02.taobaocdn.com/imgextra/i2/90219132/T2QAXlXJBaXXXXXXXX_!!90219132.jpg\" alt=\"limit\"></p>\n<ul>\n<li>skip：跳过</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img04.taobaocdn.com/imgextra/i4/90219132/T24A8mXUJXXXXXXXXX_!!90219132.jpg\" alt=\"skip\"></p>\n<p>是不是有点类似SQL语句呢？</p>\n<p>####2、映射</p>\n<ul>\n<li>map</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; Stream&lt;R&gt; <span class=\"title function_\">map</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2PQJnXOJXXXXXXXXX_!!90219132.jpg\" alt=\"map\"></p>\n<ul>\n<li><p>mapToInt</p>\n</li>\n<li><p>mapToLong</p>\n</li>\n<li><p>mapToDouble</p>\n</li>\n<li><p>flatMap</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; Stream&lt;R&gt; <span class=\"title function_\">flatMap</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img01.taobaocdn.com/imgextra/i1/90219132/T2mBXnXQhXXXXXXXXX_!!90219132.jpg\" alt=\"flatMap\"></p>\n<ul>\n<li>flatMapToInt</li>\n<li>flatMapToLong</li>\n<li>flatMapToDouble</li>\n</ul>\n<p>####3、排序</p>\n<ul>\n<li>sorted</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">sorted</span><span class=\"params\">()</span>;</span><br><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">sorted</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####4、包装</p>\n<ul>\n<li>peek</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">peek</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2DrFmXHtaXXXXXXXX_!!90219132.jpg\" alt=\"peek\"></p>\n<p>##终止操作<br>####查找与匹配</p>\n<ul>\n<li>allMatch：检查是否匹配所有元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">allMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>anyMatch：检查是否至少匹配一个元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">anyMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>noneMatch：检查是否没有匹配所有元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">noneMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>findFirst：返回第一个元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">findFirst</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>findAny：返回当前流中的任意元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">findAny</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>count：返回流中元素总数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">count</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>max：返回流中最大值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">max</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>min：返回流中最小值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">min</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach：内部迭代</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####规约</p>\n<ul>\n<li>reduce</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"title function_\">reduce</span><span class=\"params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">reduce</span><span class=\"params\">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;U&gt; U <span class=\"title function_\">reduce</span><span class=\"params\">(U identity,</span></span><br><span class=\"line\"><span class=\"params\">                 BiFunction&lt;U, ? <span class=\"built_in\">super</span> T, U&gt; accumulator,</span></span><br><span class=\"line\"><span class=\"params\">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####收集</p>\n<ul>\n<li>collect</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R, A&gt; R <span class=\"title function_\">collect</span><span class=\"params\">(Collector&lt;? <span class=\"built_in\">super</span> T, A, R&gt; collector)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;R&gt; R <span class=\"title function_\">collect</span><span class=\"params\">(Supplier&lt;R&gt; supplier,</span></span><br><span class=\"line\"><span class=\"params\">                  BiConsumer&lt;R, ? <span class=\"built_in\">super</span> T&gt; accumulator,</span></span><br><span class=\"line\"><span class=\"params\">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Collectors静态方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;T&gt; <span class=\"title function_\">toList</span><span class=\"params\">()</span></span><br><span class=\"line\">Set&lt;T&gt; <span class=\"title function_\">toSet</span><span class=\"params\">()</span></span><br><span class=\"line\">Collection&lt;T&gt; toCollection</span><br><span class=\"line\">Long counting</span><br><span class=\"line\">Integer summingInt</span><br><span class=\"line\">Double averagingInt</span><br><span class=\"line\">IntSummaryStatistics summarizingInt</span><br><span class=\"line\">String joining</span><br><span class=\"line\">Optional&lt;T&gt; maxBy</span><br><span class=\"line\">Optional&lt;T&gt; minBy</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Stream是不是很方便呢？<br>下期我们将测试下Stream中串行流与并行流的性能</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分析了Java8中的引用，本期我们将分析Java8中的另一个重要的新特性：流Stream。<br>本文**<code>图片</code>**转载自<a href=\"http://ifeve.com/stream/\">并发编程网</a></p>\n</blockquote>","more":"<p>##Stream是什么？<br>在Java8源代码中，是这么定义Stream的：</p>\n<blockquote>\n<p>A sequence of elements supporting sequential and parallel aggregate operations.</p>\n</blockquote>\n<p>简单翻译就是流是支持顺序和并行的汇聚操作的一组元素。</p>\n<p>从这个定义上来说，<code>Stream</code>可以说是一个高级版本的<code>Iterator</code>，Iterator只能一个一个遍历元素从而对元素进行操作，但是Stream可以执行非常复杂的查找、过滤和映射数据等操作，并且中间操作可以一直迭代。</p>\n<p><strong>Collections是存储元素，Stream是计算。</strong></p>\n<p>Stream可以理解为一个管道（<code>Pipeline</code>），数据从管道的一边进入，经过中间各种处理，然后从管道的另一边出来新的数据。</p>\n<p>几个注意点：</p>\n<ul>\n<li><ol>\n<li>Stream自己不会存储元素。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Stream不会改变原对象。相反，他们会返回一个持有结果的新Stream。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>Stream操作是延迟执行。这意味着他们会等到需要结果的时候才执行。</li>\n</ol>\n</li>\n</ul>\n<p>##Stream的pipeline</p>\n<ul>\n<li>创建Stream</li>\n<li>中间操作：一个中间操作链，对数据源数据进行处理，但是是延迟执行的</li>\n<li>终止操作：执行中间操作链，并产生结果，正如上面注意点3</li>\n</ul>\n<p>##创建Stream<br>####1、java.util.Collection内置了获取流的方法，分别为串行流与并行流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;E&gt; <span class=\"title function_\">stream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;E&gt; <span class=\"title function_\">parallelStream</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator(), <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>####2、java.util.Arrays内置了获取流的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">stream</span><span class=\"params\">(T[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stream(array, <span class=\"number\">0</span>, array.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>####3、java.util.stream.Stream内置了创建流的方法，分别为通过对象创建流和通过函数创建流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(<span class=\"keyword\">new</span> <span class=\"title class_\">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">of</span><span class=\"params\">(T... values)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Arrays.stream(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">iterate</span><span class=\"params\">(<span class=\"keyword\">final</span> T seed, <span class=\"keyword\">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(f);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Iterator&lt;T&gt; iterator = <span class=\"keyword\">new</span> <span class=\"title class_\">Iterator</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> (T) Streams.NONE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasNext</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> T <span class=\"title function_\">next</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">return</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class=\"line\">                iterator,</span><br><span class=\"line\">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">generate</span><span class=\"params\">(Supplier&lt;T&gt; s)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">StreamSpliterators</span>.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##中间操作（java.util.stream.Stream）<br>####1、截断与切片</p>\n<ul>\n<li>filter：过滤</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">filter</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2OxXnXPlXXXXXXXXX_!!90219132.jpg\" alt=\"filter\"></p>\n<ul>\n<li>distinct：去除重复元素（通过equals和hashCode）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">distinct</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img04.taobaocdn.com/imgextra/i4/90219132/T2K0lnXPRXXXXXXXXX_!!90219132.jpg\" alt=\"distinct\"></p>\n<ul>\n<li>limit：限制数量</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">limit</span><span class=\"params\">(<span class=\"type\">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img02.taobaocdn.com/imgextra/i2/90219132/T2QAXlXJBaXXXXXXXX_!!90219132.jpg\" alt=\"limit\"></p>\n<ul>\n<li>skip：跳过</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">skip</span><span class=\"params\">(<span class=\"type\">long</span> n)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img04.taobaocdn.com/imgextra/i4/90219132/T24A8mXUJXXXXXXXXX_!!90219132.jpg\" alt=\"skip\"></p>\n<p>是不是有点类似SQL语句呢？</p>\n<p>####2、映射</p>\n<ul>\n<li>map</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; Stream&lt;R&gt; <span class=\"title function_\">map</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2PQJnXOJXXXXXXXXX_!!90219132.jpg\" alt=\"map\"></p>\n<ul>\n<li><p>mapToInt</p>\n</li>\n<li><p>mapToLong</p>\n</li>\n<li><p>mapToDouble</p>\n</li>\n<li><p>flatMap</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; Stream&lt;R&gt; <span class=\"title function_\">flatMap</span><span class=\"params\">(Function&lt;? <span class=\"built_in\">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img01.taobaocdn.com/imgextra/i1/90219132/T2mBXnXQhXXXXXXXXX_!!90219132.jpg\" alt=\"flatMap\"></p>\n<ul>\n<li>flatMapToInt</li>\n<li>flatMapToLong</li>\n<li>flatMapToDouble</li>\n</ul>\n<p>####3、排序</p>\n<ul>\n<li>sorted</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">sorted</span><span class=\"params\">()</span>;</span><br><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">sorted</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####4、包装</p>\n<ul>\n<li>peek</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">peek</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://img03.taobaocdn.com/imgextra/i3/90219132/T2DrFmXHtaXXXXXXXX_!!90219132.jpg\" alt=\"peek\"></p>\n<p>##终止操作<br>####查找与匹配</p>\n<ul>\n<li>allMatch：检查是否匹配所有元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">allMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>anyMatch：检查是否至少匹配一个元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">anyMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>noneMatch：检查是否没有匹配所有元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">noneMatch</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>findFirst：返回第一个元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">findFirst</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>findAny：返回当前流中的任意元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">findAny</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>count：返回流中元素总数</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">count</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>max：返回流中最大值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">max</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>min：返回流中最小值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">min</span><span class=\"params\">(Comparator&lt;? <span class=\"built_in\">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach：内部迭代</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####规约</p>\n<ul>\n<li>reduce</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"title function_\">reduce</span><span class=\"params\">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Optional&lt;T&gt; <span class=\"title function_\">reduce</span><span class=\"params\">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;U&gt; U <span class=\"title function_\">reduce</span><span class=\"params\">(U identity,</span></span><br><span class=\"line\"><span class=\"params\">                 BiFunction&lt;U, ? <span class=\"built_in\">super</span> T, U&gt; accumulator,</span></span><br><span class=\"line\"><span class=\"params\">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>####收集</p>\n<ul>\n<li>collect</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;R, A&gt; R <span class=\"title function_\">collect</span><span class=\"params\">(Collector&lt;? <span class=\"built_in\">super</span> T, A, R&gt; collector)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;R&gt; R <span class=\"title function_\">collect</span><span class=\"params\">(Supplier&lt;R&gt; supplier,</span></span><br><span class=\"line\"><span class=\"params\">                  BiConsumer&lt;R, ? <span class=\"built_in\">super</span> T&gt; accumulator,</span></span><br><span class=\"line\"><span class=\"params\">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Collectors静态方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;T&gt; <span class=\"title function_\">toList</span><span class=\"params\">()</span></span><br><span class=\"line\">Set&lt;T&gt; <span class=\"title function_\">toSet</span><span class=\"params\">()</span></span><br><span class=\"line\">Collection&lt;T&gt; toCollection</span><br><span class=\"line\">Long counting</span><br><span class=\"line\">Integer summingInt</span><br><span class=\"line\">Double averagingInt</span><br><span class=\"line\">IntSummaryStatistics summarizingInt</span><br><span class=\"line\">String joining</span><br><span class=\"line\">Optional&lt;T&gt; maxBy</span><br><span class=\"line\">Optional&lt;T&gt; minBy</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Stream是不是很方便呢？<br>下期我们将测试下Stream中串行流与并行流的性能</p>\n</blockquote>"},{"title":"Java8新特性（时间/日期）","date":"2017-12-30T14:11:22.000Z","_content":">上期我们介绍了Java8中的`Optional`，本期我们介绍Java8中新的时间日期API。\n\n<!--more-->\n##JSR\n在讲之前，首先讲一下JSR，什么是`JSR`呢？`Java Specification Requests`，是Java规范提案。\n常见的JSR有：\n\n+ `JSR-303` 参数验证\n+ `JSR-310` 时间\n+ `JSR-311` Restful API规范\n\n`JSR-310`即时间规范标准：\n\n在Java8之前，操作时间日期的类为：`Date`和`Calendar`，第三方包如**`Joda-time`**\n在Java8中，新增了许多时间日期API\n\n##Joda-time\n\n####引入Maven依赖\n\n```xml\n<dependency>\n    <groupId>joda-time</groupId>\n    <artifactId>joda-time</artifactId>\n    <version>2.9.2</version>\n</dependency>\n```\n\n####核心类\n+ Instant：不可变的类，用来表示时间轴上一个瞬时的点\n+ DateTime：不可变的类，用来替换JDK的Calendar类\n+ LocalDate：不可变的类，表示一个本地的日期，而不包含时间部分（没有时区信息）\n+ LocalTime：不可变的类，表示一个本地的时间，而不包含日期部分（没有时区信息）\n+ LocalDateTime：不可变的类，表示一个本地的日期－时间（没有时区信息）\n\n####用法举例\n\n```java\npublic static void main(String[] args) {\n    DateTime today = DateTime.now();\n    DateTime tomorrow = today.plusDays(1);\n    DateTime oneHourAfter = today.plusHours(1);\n    System.out.println(today.toString());\n    System.out.println(tomorrow.toString());\n    System.out.println(oneHourAfter.toString());\n\n    DateTime day = new DateTime(2017,12,30,17,47,30);\n    System.out.println(day.dayOfYear().getAsString());\n    System.out.println(day.dayOfMonth().getAsString());\n    System.out.println(day.dayOfWeek().getAsString());\n}\n```\n\n结果：\n\n```java\n2017-12-30T17:49:24.065+08:00\n2017-12-31T17:49:24.065+08:00\n2017-12-30T18:49:24.065+08:00\n364\n30\n6\n```\n\n>如果用过Joda-time的，那么Java8中新的时间日期API就很容易上手了。\n\n##Java8中新的时间日期API\n\n####LocalDate／LocalTime／LocalDateTime\n+ now() ：根据当前时间创建对象\n+ of()：根据指定日期/时间创建对象\n+ plusDays／plusWeeks／plusMonths／plusYears 时间向后推移\n+ minusDays／minusWeeks／minusMonths／minusYears 时间向前推移\n+ plus／minus\n+ withDayOfMonth/withDayOfYear/withMonth/withYear 修改\n+ getDayOfMonth 获得月份天数(1-31)\n+ getDayOfYear 获得年份天数(1-366)\n+ getDayOfWeek 获得星期几(返回一个 DayOfWeek 枚举值)\n+ getMonth 获得月份, 返回一个 Month 枚举值\n+ getMonthValue 获得月份(1-12)\n+ getYear 获得年份\n+ until 获得两个日期之间的 Period 对象， 或者指定 ChronoUnits 的数字\n+ isBefore／isAfter 比较两个 LocalDate\n+ isLeapYear 判断是否是闰年\n\n####Instant 时间戳\n用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算。\n\n####Duration 和 Period\n+ Duration：用于计算两个“时间”间隔，Duration.between...\n+ Period：用于计算两个“日期”间隔，Period.between...\n\n####Clock 时钟\nClock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。\n\n```java\nClock clock = Clock.systemDefaultZone();  \nlong millis = clock.millis();  \nInstant instant = clock.instant();  \nDate date = Date.from(instant);\n```\n\n####日期的操作\n+ TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。\n+ TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。\n\n####解析与格式化\njava.time.format.DateTimeFormatter类：该类提供了三种格式化方法：\n\n+ 1. 预定义的标准格式 \n+ 2. 语言环境相关的格式 \n+ 3. 自定义的格式\n\n```java\nDateTimeFormatter isoDateTime = DateTimeFormatter.ISO_DATE_TIME;\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss E\");\n```\n\n####时区的处理\nJava8中加入了对时区的支持，带时区的时间为分别为：\n\n+ ZonedDate\n+ ZonedTime\n+ ZonedDateTime\n\n其中每个时区都对应着ID，地区ID都为 “{区域}/{城市}”的格式 例如 :Asia/Shanghai等，ZoneId:该类中包含了所有的时区信息 \n\n+ 1. getAvailableZoneIds() : 可以获取所有时区时区\n+ 2. of(id) : 用指定的时区信息获取 ZoneId 对象","source":"_posts/java8-time-date.md","raw":"title: Java8新特性（时间/日期）\ndate: 2017-12-30 22:11:22\ncategories: Java\ntags: [Java,Java8新特性]\n---\n>上期我们介绍了Java8中的`Optional`，本期我们介绍Java8中新的时间日期API。\n\n<!--more-->\n##JSR\n在讲之前，首先讲一下JSR，什么是`JSR`呢？`Java Specification Requests`，是Java规范提案。\n常见的JSR有：\n\n+ `JSR-303` 参数验证\n+ `JSR-310` 时间\n+ `JSR-311` Restful API规范\n\n`JSR-310`即时间规范标准：\n\n在Java8之前，操作时间日期的类为：`Date`和`Calendar`，第三方包如**`Joda-time`**\n在Java8中，新增了许多时间日期API\n\n##Joda-time\n\n####引入Maven依赖\n\n```xml\n<dependency>\n    <groupId>joda-time</groupId>\n    <artifactId>joda-time</artifactId>\n    <version>2.9.2</version>\n</dependency>\n```\n\n####核心类\n+ Instant：不可变的类，用来表示时间轴上一个瞬时的点\n+ DateTime：不可变的类，用来替换JDK的Calendar类\n+ LocalDate：不可变的类，表示一个本地的日期，而不包含时间部分（没有时区信息）\n+ LocalTime：不可变的类，表示一个本地的时间，而不包含日期部分（没有时区信息）\n+ LocalDateTime：不可变的类，表示一个本地的日期－时间（没有时区信息）\n\n####用法举例\n\n```java\npublic static void main(String[] args) {\n    DateTime today = DateTime.now();\n    DateTime tomorrow = today.plusDays(1);\n    DateTime oneHourAfter = today.plusHours(1);\n    System.out.println(today.toString());\n    System.out.println(tomorrow.toString());\n    System.out.println(oneHourAfter.toString());\n\n    DateTime day = new DateTime(2017,12,30,17,47,30);\n    System.out.println(day.dayOfYear().getAsString());\n    System.out.println(day.dayOfMonth().getAsString());\n    System.out.println(day.dayOfWeek().getAsString());\n}\n```\n\n结果：\n\n```java\n2017-12-30T17:49:24.065+08:00\n2017-12-31T17:49:24.065+08:00\n2017-12-30T18:49:24.065+08:00\n364\n30\n6\n```\n\n>如果用过Joda-time的，那么Java8中新的时间日期API就很容易上手了。\n\n##Java8中新的时间日期API\n\n####LocalDate／LocalTime／LocalDateTime\n+ now() ：根据当前时间创建对象\n+ of()：根据指定日期/时间创建对象\n+ plusDays／plusWeeks／plusMonths／plusYears 时间向后推移\n+ minusDays／minusWeeks／minusMonths／minusYears 时间向前推移\n+ plus／minus\n+ withDayOfMonth/withDayOfYear/withMonth/withYear 修改\n+ getDayOfMonth 获得月份天数(1-31)\n+ getDayOfYear 获得年份天数(1-366)\n+ getDayOfWeek 获得星期几(返回一个 DayOfWeek 枚举值)\n+ getMonth 获得月份, 返回一个 Month 枚举值\n+ getMonthValue 获得月份(1-12)\n+ getYear 获得年份\n+ until 获得两个日期之间的 Period 对象， 或者指定 ChronoUnits 的数字\n+ isBefore／isAfter 比较两个 LocalDate\n+ isLeapYear 判断是否是闰年\n\n####Instant 时间戳\n用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算。\n\n####Duration 和 Period\n+ Duration：用于计算两个“时间”间隔，Duration.between...\n+ Period：用于计算两个“日期”间隔，Period.between...\n\n####Clock 时钟\nClock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。\n\n```java\nClock clock = Clock.systemDefaultZone();  \nlong millis = clock.millis();  \nInstant instant = clock.instant();  \nDate date = Date.from(instant);\n```\n\n####日期的操作\n+ TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。\n+ TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。\n\n####解析与格式化\njava.time.format.DateTimeFormatter类：该类提供了三种格式化方法：\n\n+ 1. 预定义的标准格式 \n+ 2. 语言环境相关的格式 \n+ 3. 自定义的格式\n\n```java\nDateTimeFormatter isoDateTime = DateTimeFormatter.ISO_DATE_TIME;\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss E\");\n```\n\n####时区的处理\nJava8中加入了对时区的支持，带时区的时间为分别为：\n\n+ ZonedDate\n+ ZonedTime\n+ ZonedDateTime\n\n其中每个时区都对应着ID，地区ID都为 “{区域}/{城市}”的格式 例如 :Asia/Shanghai等，ZoneId:该类中包含了所有的时区信息 \n\n+ 1. getAvailableZoneIds() : 可以获取所有时区时区\n+ 2. of(id) : 用指定的时区信息获取 ZoneId 对象","slug":"java8-time-date","published":1,"updated":"2025-03-07T13:26:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2h0018rz5m3yv77t4f","content":"<blockquote>\n<p>上期我们介绍了Java8中的<code>Optional</code>，本期我们介绍Java8中新的时间日期API。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##JSR<br>在讲之前，首先讲一下JSR，什么是<code>JSR</code>呢？<code>Java Specification Requests</code>，是Java规范提案。<br>常见的JSR有：</p>\n<ul>\n<li><code>JSR-303</code> 参数验证</li>\n<li><code>JSR-310</code> 时间</li>\n<li><code>JSR-311</code> Restful API规范</li>\n</ul>\n<p><code>JSR-310</code>即时间规范标准：</p>\n<p>在Java8之前，操作时间日期的类为：<code>Date</code>和<code>Calendar</code>，第三方包如**<code>Joda-time</code>**<br>在Java8中，新增了许多时间日期API</p>\n<p>##Joda-time</p>\n<p>####引入Maven依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>joda-time<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>joda-time<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>####核心类</p>\n<ul>\n<li>Instant：不可变的类，用来表示时间轴上一个瞬时的点</li>\n<li>DateTime：不可变的类，用来替换JDK的Calendar类</li>\n<li>LocalDate：不可变的类，表示一个本地的日期，而不包含时间部分（没有时区信息）</li>\n<li>LocalTime：不可变的类，表示一个本地的时间，而不包含日期部分（没有时区信息）</li>\n<li>LocalDateTime：不可变的类，表示一个本地的日期－时间（没有时区信息）</li>\n</ul>\n<p>####用法举例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> DateTime.now();</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">tomorrow</span> <span class=\"operator\">=</span> today.plusDays(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">oneHourAfter</span> <span class=\"operator\">=</span> today.plusHours(<span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(today.toString());</span><br><span class=\"line\">    System.out.println(tomorrow.toString());</span><br><span class=\"line\">    System.out.println(oneHourAfter.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DateTime</span>(<span class=\"number\">2017</span>,<span class=\"number\">12</span>,<span class=\"number\">30</span>,<span class=\"number\">17</span>,<span class=\"number\">47</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">    System.out.println(day.dayOfYear().getAsString());</span><br><span class=\"line\">    System.out.println(day.dayOfMonth().getAsString());</span><br><span class=\"line\">    System.out.println(day.dayOfWeek().getAsString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-30T17:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-31T17:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-30T18:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">364</span></span><br><span class=\"line\"><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果用过Joda-time的，那么Java8中新的时间日期API就很容易上手了。</p>\n</blockquote>\n<p>##Java8中新的时间日期API</p>\n<p>####LocalDate／LocalTime／LocalDateTime</p>\n<ul>\n<li>now() ：根据当前时间创建对象</li>\n<li>of()：根据指定日期&#x2F;时间创建对象</li>\n<li>plusDays／plusWeeks／plusMonths／plusYears 时间向后推移</li>\n<li>minusDays／minusWeeks／minusMonths／minusYears 时间向前推移</li>\n<li>plus／minus</li>\n<li>withDayOfMonth&#x2F;withDayOfYear&#x2F;withMonth&#x2F;withYear 修改</li>\n<li>getDayOfMonth 获得月份天数(1-31)</li>\n<li>getDayOfYear 获得年份天数(1-366)</li>\n<li>getDayOfWeek 获得星期几(返回一个 DayOfWeek 枚举值)</li>\n<li>getMonth 获得月份, 返回一个 Month 枚举值</li>\n<li>getMonthValue 获得月份(1-12)</li>\n<li>getYear 获得年份</li>\n<li>until 获得两个日期之间的 Period 对象， 或者指定 ChronoUnits 的数字</li>\n<li>isBefore／isAfter 比较两个 LocalDate</li>\n<li>isLeapYear 判断是否是闰年</li>\n</ul>\n<p>####Instant 时间戳<br>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算。</p>\n<p>####Duration 和 Period</p>\n<ul>\n<li>Duration：用于计算两个“时间”间隔，Duration.between…</li>\n<li>Period：用于计算两个“日期”间隔，Period.between…</li>\n</ul>\n<p>####Clock 时钟<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Clock</span> <span class=\"variable\">clock</span> <span class=\"operator\">=</span> Clock.systemDefaultZone();  </span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">millis</span> <span class=\"operator\">=</span> clock.millis();  </span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">instant</span> <span class=\"operator\">=</span> clock.instant();  </span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure>\n\n<p>####日期的操作</p>\n<ul>\n<li>TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</li>\n<li>TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。</li>\n</ul>\n<p>####解析与格式化<br>java.time.format.DateTimeFormatter类：该类提供了三种格式化方法：</p>\n<ul>\n<li><ol>\n<li>预定义的标准格式</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>语言环境相关的格式</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>自定义的格式</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">isoDateTime</span> <span class=\"operator\">=</span> DateTimeFormatter.ISO_DATE_TIME;</span><br><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dateTimeFormatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy年MM月dd日 HH:mm:ss E&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>####时区的处理<br>Java8中加入了对时区的支持，带时区的时间为分别为：</p>\n<ul>\n<li>ZonedDate</li>\n<li>ZonedTime</li>\n<li>ZonedDateTime</li>\n</ul>\n<p>其中每个时区都对应着ID，地区ID都为 “{区域}&#x2F;{城市}”的格式 例如 :Asia&#x2F;Shanghai等，ZoneId:该类中包含了所有的时区信息 </p>\n<ul>\n<li><ol>\n<li>getAvailableZoneIds() : 可以获取所有时区时区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>of(id) : 用指定的时区信息获取 ZoneId 对象</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们介绍了Java8中的<code>Optional</code>，本期我们介绍Java8中新的时间日期API。</p>\n</blockquote>","more":"<p>##JSR<br>在讲之前，首先讲一下JSR，什么是<code>JSR</code>呢？<code>Java Specification Requests</code>，是Java规范提案。<br>常见的JSR有：</p>\n<ul>\n<li><code>JSR-303</code> 参数验证</li>\n<li><code>JSR-310</code> 时间</li>\n<li><code>JSR-311</code> Restful API规范</li>\n</ul>\n<p><code>JSR-310</code>即时间规范标准：</p>\n<p>在Java8之前，操作时间日期的类为：<code>Date</code>和<code>Calendar</code>，第三方包如**<code>Joda-time</code>**<br>在Java8中，新增了许多时间日期API</p>\n<p>##Joda-time</p>\n<p>####引入Maven依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>joda-time<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>joda-time<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>####核心类</p>\n<ul>\n<li>Instant：不可变的类，用来表示时间轴上一个瞬时的点</li>\n<li>DateTime：不可变的类，用来替换JDK的Calendar类</li>\n<li>LocalDate：不可变的类，表示一个本地的日期，而不包含时间部分（没有时区信息）</li>\n<li>LocalTime：不可变的类，表示一个本地的时间，而不包含日期部分（没有时区信息）</li>\n<li>LocalDateTime：不可变的类，表示一个本地的日期－时间（没有时区信息）</li>\n</ul>\n<p>####用法举例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">today</span> <span class=\"operator\">=</span> DateTime.now();</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">tomorrow</span> <span class=\"operator\">=</span> today.plusDays(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">oneHourAfter</span> <span class=\"operator\">=</span> today.plusHours(<span class=\"number\">1</span>);</span><br><span class=\"line\">    System.out.println(today.toString());</span><br><span class=\"line\">    System.out.println(tomorrow.toString());</span><br><span class=\"line\">    System.out.println(oneHourAfter.toString());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">DateTime</span> <span class=\"variable\">day</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DateTime</span>(<span class=\"number\">2017</span>,<span class=\"number\">12</span>,<span class=\"number\">30</span>,<span class=\"number\">17</span>,<span class=\"number\">47</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">    System.out.println(day.dayOfYear().getAsString());</span><br><span class=\"line\">    System.out.println(day.dayOfMonth().getAsString());</span><br><span class=\"line\">    System.out.println(day.dayOfWeek().getAsString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-30T17:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-31T17:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">2017</span>-<span class=\"number\">12</span>-30T18:<span class=\"number\">49</span>:<span class=\"number\">24.065</span>+08:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"number\">364</span></span><br><span class=\"line\"><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果用过Joda-time的，那么Java8中新的时间日期API就很容易上手了。</p>\n</blockquote>\n<p>##Java8中新的时间日期API</p>\n<p>####LocalDate／LocalTime／LocalDateTime</p>\n<ul>\n<li>now() ：根据当前时间创建对象</li>\n<li>of()：根据指定日期&#x2F;时间创建对象</li>\n<li>plusDays／plusWeeks／plusMonths／plusYears 时间向后推移</li>\n<li>minusDays／minusWeeks／minusMonths／minusYears 时间向前推移</li>\n<li>plus／minus</li>\n<li>withDayOfMonth&#x2F;withDayOfYear&#x2F;withMonth&#x2F;withYear 修改</li>\n<li>getDayOfMonth 获得月份天数(1-31)</li>\n<li>getDayOfYear 获得年份天数(1-366)</li>\n<li>getDayOfWeek 获得星期几(返回一个 DayOfWeek 枚举值)</li>\n<li>getMonth 获得月份, 返回一个 Month 枚举值</li>\n<li>getMonthValue 获得月份(1-12)</li>\n<li>getYear 获得年份</li>\n<li>until 获得两个日期之间的 Period 对象， 或者指定 ChronoUnits 的数字</li>\n<li>isBefore／isAfter 比较两个 LocalDate</li>\n<li>isLeapYear 判断是否是闰年</li>\n</ul>\n<p>####Instant 时间戳<br>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算。</p>\n<p>####Duration 和 Period</p>\n<ul>\n<li>Duration：用于计算两个“时间”间隔，Duration.between…</li>\n<li>Period：用于计算两个“日期”间隔，Period.between…</li>\n</ul>\n<p>####Clock 时钟<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Clock</span> <span class=\"variable\">clock</span> <span class=\"operator\">=</span> Clock.systemDefaultZone();  </span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">millis</span> <span class=\"operator\">=</span> clock.millis();  </span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">instant</span> <span class=\"operator\">=</span> clock.instant();  </span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> Date.from(instant);</span><br></pre></td></tr></table></figure>\n\n<p>####日期的操作</p>\n<ul>\n<li>TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</li>\n<li>TemporalAdjusters：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。</li>\n</ul>\n<p>####解析与格式化<br>java.time.format.DateTimeFormatter类：该类提供了三种格式化方法：</p>\n<ul>\n<li><ol>\n<li>预定义的标准格式</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>语言环境相关的格式</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>自定义的格式</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">isoDateTime</span> <span class=\"operator\">=</span> DateTimeFormatter.ISO_DATE_TIME;</span><br><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dateTimeFormatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy年MM月dd日 HH:mm:ss E&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>####时区的处理<br>Java8中加入了对时区的支持，带时区的时间为分别为：</p>\n<ul>\n<li>ZonedDate</li>\n<li>ZonedTime</li>\n<li>ZonedDateTime</li>\n</ul>\n<p>其中每个时区都对应着ID，地区ID都为 “{区域}&#x2F;{城市}”的格式 例如 :Asia&#x2F;Shanghai等，ZoneId:该类中包含了所有的时区信息 </p>\n<ul>\n<li><ol>\n<li>getAvailableZoneIds() : 可以获取所有时区时区</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>of(id) : 用指定的时区信息获取 ZoneId 对象</li>\n</ol>\n</li>\n</ul>"},{"title":"Java8新特性（序）","date":"2017-12-20T15:42:37.000Z","_content":"Jdk目前已经发展到`Java 9`了，历史上有两个版本变化比较大，一个是`Java 5`，另一个就是`Java 8`。\n本Java8新特性系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。\n\n<!--more-->\n#历史版本如下：\n\n| 版本 | 名称 | 发行日期 |\n| ------------- |:-------------:| -----:|\n| JDK 1.1.4 | Sparkler（宝石） | 1997-09-12 |\n| JDK 1.1.5 | Pumpkin（南瓜） | 1997-12-13 |\n| JDK 1.1.6 | Abigail（阿比盖尔–女子名） | 1998-04-24 |\n| JDK 1.1.7 | Brutus（布鲁图–古罗马政治家和将军） | 1998-09-28 |\n| JDK 1.1.8 | Chelsea（切尔西–城市名） | 1998-04-24 |\n| J2SE 1.2 | Playground（运动场 | 1998-12-04 |\n| J2SE 1.2.1 | none（无） | 1999-03-30 |\n| J2SE 1.2.2 | Cricket（蟋蟀） | 1999-07-08 |\n| J2SE 1.3 | Kestrel（美洲红隼） | 2000-05-08 |\n| J2SE 1.3.1 | Ladybird（瓢虫） | 2001-05-17 |\n| J2SE 1.4.0 | Merlin（灰背隼） | 2002-02-13 |\n| J2SE 1.4.1 | grasshopper（蚱蜢） | 2002-09-16 |\n| J2SE 1.4.2 | Mantis（螳螂） | 2003-06-26 |\n| Java SE 5.0 (1.5.0) | Tiger（老虎） | 2004-09-30 |\n| Java SE 6.0 (1.6.0) | Mustang（野马） | 2006-04-xx |\n| Java SE 7.0 (1.7.0) | Dolphin（海豚） | 2011-07-28 |\n| Java SE 8.0 (1.8.0) | Spider（蜘蛛） | 2014-03-18 |\n| Java SE 9 |  | 2017-09-21 |\n\n#最近三个版本的新特性如下：\n##Java 7\n>开发代号是Dolphin（海豚），于2011-07-28发行\n\n引入的新特性包括：\n\n+ switch语句块中允许以字符串作为分支条件；\n+ 在创建泛型对象时应用类型推断；\n+ 在一个语句块中捕获多种异常；\n+ 支持动态语言；\n+ 支持try-with-resources；\n+ 引入Java NIO.2开发包；\n+ 数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；\n+ 钻石型语法；\n+ null值的自动处理。\n\n##Java 8\n>开发代号是Spider（蜘蛛），于2014年3月14号发布\n\n引入的新特性包括：\n\n+ Lambda表达式\n+ Pipelines和Streams\n+ Date和Time API\n+ Default方法\n+ Type注解\n+ Nashhorn JavaScript引擎\n+ 并发计数器\n+ Parallel操作\n+ 移除PermGen Error\n+ TLS SNI\n\n##Java 9\n>于2017年9月21日发布\n\n引入的新特性包括：\n\n+ 模块化系统–Jigsaw 项目\n+ JShell–Java 9 REPL\n+ 集合工厂方法\n+ 接口中的私有方法\n+ 响应式流\n+ 多分辨率图像API–JEP 251\n+ 进程API的改进\n+ Try-With-Resources\n+ 钻石（diamond）操作符范围的延伸\n+ 增强的注释Deprecate\n+ 统一的JVM日志\n+ 注释SafeVarargs范围的延伸\n+ HTTP 2 客户端\n+ HTML5风格的Java帮助文档\n+ 保留下划线字符。变量不能被命名为_；\n+ 废弃Applet API；\n+ javac不再支持Java1.4以及之前的版本；\n+ 废弃Java浏览器插件；\n+ 栈遍历API–栈遍历API能过滤和迟访问在堆栈跟踪中的信息\n\n\n>###目前`Java8`在Java各版本使用率中已高达`60%`以上，未来还会继续上升，所以学会用Java8，用好Java8势在必行，本系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。\n>\n>##**人生苦短，拥抱Java8。**","source":"_posts/java8.md","raw":"title: Java8新特性（序）\ndate: 2017-12-20 23:42:37\ncategories: Java\ntags: [Java,Java8新特性]\n---\nJdk目前已经发展到`Java 9`了，历史上有两个版本变化比较大，一个是`Java 5`，另一个就是`Java 8`。\n本Java8新特性系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。\n\n<!--more-->\n#历史版本如下：\n\n| 版本 | 名称 | 发行日期 |\n| ------------- |:-------------:| -----:|\n| JDK 1.1.4 | Sparkler（宝石） | 1997-09-12 |\n| JDK 1.1.5 | Pumpkin（南瓜） | 1997-12-13 |\n| JDK 1.1.6 | Abigail（阿比盖尔–女子名） | 1998-04-24 |\n| JDK 1.1.7 | Brutus（布鲁图–古罗马政治家和将军） | 1998-09-28 |\n| JDK 1.1.8 | Chelsea（切尔西–城市名） | 1998-04-24 |\n| J2SE 1.2 | Playground（运动场 | 1998-12-04 |\n| J2SE 1.2.1 | none（无） | 1999-03-30 |\n| J2SE 1.2.2 | Cricket（蟋蟀） | 1999-07-08 |\n| J2SE 1.3 | Kestrel（美洲红隼） | 2000-05-08 |\n| J2SE 1.3.1 | Ladybird（瓢虫） | 2001-05-17 |\n| J2SE 1.4.0 | Merlin（灰背隼） | 2002-02-13 |\n| J2SE 1.4.1 | grasshopper（蚱蜢） | 2002-09-16 |\n| J2SE 1.4.2 | Mantis（螳螂） | 2003-06-26 |\n| Java SE 5.0 (1.5.0) | Tiger（老虎） | 2004-09-30 |\n| Java SE 6.0 (1.6.0) | Mustang（野马） | 2006-04-xx |\n| Java SE 7.0 (1.7.0) | Dolphin（海豚） | 2011-07-28 |\n| Java SE 8.0 (1.8.0) | Spider（蜘蛛） | 2014-03-18 |\n| Java SE 9 |  | 2017-09-21 |\n\n#最近三个版本的新特性如下：\n##Java 7\n>开发代号是Dolphin（海豚），于2011-07-28发行\n\n引入的新特性包括：\n\n+ switch语句块中允许以字符串作为分支条件；\n+ 在创建泛型对象时应用类型推断；\n+ 在一个语句块中捕获多种异常；\n+ 支持动态语言；\n+ 支持try-with-resources；\n+ 引入Java NIO.2开发包；\n+ 数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；\n+ 钻石型语法；\n+ null值的自动处理。\n\n##Java 8\n>开发代号是Spider（蜘蛛），于2014年3月14号发布\n\n引入的新特性包括：\n\n+ Lambda表达式\n+ Pipelines和Streams\n+ Date和Time API\n+ Default方法\n+ Type注解\n+ Nashhorn JavaScript引擎\n+ 并发计数器\n+ Parallel操作\n+ 移除PermGen Error\n+ TLS SNI\n\n##Java 9\n>于2017年9月21日发布\n\n引入的新特性包括：\n\n+ 模块化系统–Jigsaw 项目\n+ JShell–Java 9 REPL\n+ 集合工厂方法\n+ 接口中的私有方法\n+ 响应式流\n+ 多分辨率图像API–JEP 251\n+ 进程API的改进\n+ Try-With-Resources\n+ 钻石（diamond）操作符范围的延伸\n+ 增强的注释Deprecate\n+ 统一的JVM日志\n+ 注释SafeVarargs范围的延伸\n+ HTTP 2 客户端\n+ HTML5风格的Java帮助文档\n+ 保留下划线字符。变量不能被命名为_；\n+ 废弃Applet API；\n+ javac不再支持Java1.4以及之前的版本；\n+ 废弃Java浏览器插件；\n+ 栈遍历API–栈遍历API能过滤和迟访问在堆栈跟踪中的信息\n\n\n>###目前`Java8`在Java各版本使用率中已高达`60%`以上，未来还会继续上升，所以学会用Java8，用好Java8势在必行，本系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。\n>\n>##**人生苦短，拥抱Java8。**","slug":"java8","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2h001brz5mgpub81ww","content":"<p>Jdk目前已经发展到<code>Java 9</code>了，历史上有两个版本变化比较大，一个是<code>Java 5</code>，另一个就是<code>Java 8</code>。<br>本Java8新特性系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。</p>\n<span id=\"more\"></span>\n<p>#历史版本如下：</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th align=\"center\">名称</th>\n<th align=\"right\">发行日期</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JDK 1.1.4</td>\n<td align=\"center\">Sparkler（宝石）</td>\n<td align=\"right\">1997-09-12</td>\n</tr>\n<tr>\n<td>JDK 1.1.5</td>\n<td align=\"center\">Pumpkin（南瓜）</td>\n<td align=\"right\">1997-12-13</td>\n</tr>\n<tr>\n<td>JDK 1.1.6</td>\n<td align=\"center\">Abigail（阿比盖尔–女子名）</td>\n<td align=\"right\">1998-04-24</td>\n</tr>\n<tr>\n<td>JDK 1.1.7</td>\n<td align=\"center\">Brutus（布鲁图–古罗马政治家和将军）</td>\n<td align=\"right\">1998-09-28</td>\n</tr>\n<tr>\n<td>JDK 1.1.8</td>\n<td align=\"center\">Chelsea（切尔西–城市名）</td>\n<td align=\"right\">1998-04-24</td>\n</tr>\n<tr>\n<td>J2SE 1.2</td>\n<td align=\"center\">Playground（运动场</td>\n<td align=\"right\">1998-12-04</td>\n</tr>\n<tr>\n<td>J2SE 1.2.1</td>\n<td align=\"center\">none（无）</td>\n<td align=\"right\">1999-03-30</td>\n</tr>\n<tr>\n<td>J2SE 1.2.2</td>\n<td align=\"center\">Cricket（蟋蟀）</td>\n<td align=\"right\">1999-07-08</td>\n</tr>\n<tr>\n<td>J2SE 1.3</td>\n<td align=\"center\">Kestrel（美洲红隼）</td>\n<td align=\"right\">2000-05-08</td>\n</tr>\n<tr>\n<td>J2SE 1.3.1</td>\n<td align=\"center\">Ladybird（瓢虫）</td>\n<td align=\"right\">2001-05-17</td>\n</tr>\n<tr>\n<td>J2SE 1.4.0</td>\n<td align=\"center\">Merlin（灰背隼）</td>\n<td align=\"right\">2002-02-13</td>\n</tr>\n<tr>\n<td>J2SE 1.4.1</td>\n<td align=\"center\">grasshopper（蚱蜢）</td>\n<td align=\"right\">2002-09-16</td>\n</tr>\n<tr>\n<td>J2SE 1.4.2</td>\n<td align=\"center\">Mantis（螳螂）</td>\n<td align=\"right\">2003-06-26</td>\n</tr>\n<tr>\n<td>Java SE 5.0 (1.5.0)</td>\n<td align=\"center\">Tiger（老虎）</td>\n<td align=\"right\">2004-09-30</td>\n</tr>\n<tr>\n<td>Java SE 6.0 (1.6.0)</td>\n<td align=\"center\">Mustang（野马）</td>\n<td align=\"right\">2006-04-xx</td>\n</tr>\n<tr>\n<td>Java SE 7.0 (1.7.0)</td>\n<td align=\"center\">Dolphin（海豚）</td>\n<td align=\"right\">2011-07-28</td>\n</tr>\n<tr>\n<td>Java SE 8.0 (1.8.0)</td>\n<td align=\"center\">Spider（蜘蛛）</td>\n<td align=\"right\">2014-03-18</td>\n</tr>\n<tr>\n<td>Java SE 9</td>\n<td align=\"center\"></td>\n<td align=\"right\">2017-09-21</td>\n</tr>\n</tbody></table>\n<p>#最近三个版本的新特性如下：<br>##Java 7</p>\n<blockquote>\n<p>开发代号是Dolphin（海豚），于2011-07-28发行</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>switch语句块中允许以字符串作为分支条件；</li>\n<li>在创建泛型对象时应用类型推断；</li>\n<li>在一个语句块中捕获多种异常；</li>\n<li>支持动态语言；</li>\n<li>支持try-with-resources；</li>\n<li>引入Java NIO.2开发包；</li>\n<li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li>\n<li>钻石型语法；</li>\n<li>null值的自动处理。</li>\n</ul>\n<p>##Java 8</p>\n<blockquote>\n<p>开发代号是Spider（蜘蛛），于2014年3月14号发布</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>Lambda表达式</li>\n<li>Pipelines和Streams</li>\n<li>Date和Time API</li>\n<li>Default方法</li>\n<li>Type注解</li>\n<li>Nashhorn JavaScript引擎</li>\n<li>并发计数器</li>\n<li>Parallel操作</li>\n<li>移除PermGen Error</li>\n<li>TLS SNI</li>\n</ul>\n<p>##Java 9</p>\n<blockquote>\n<p>于2017年9月21日发布</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>模块化系统–Jigsaw 项目</li>\n<li>JShell–Java 9 REPL</li>\n<li>集合工厂方法</li>\n<li>接口中的私有方法</li>\n<li>响应式流</li>\n<li>多分辨率图像API–JEP 251</li>\n<li>进程API的改进</li>\n<li>Try-With-Resources</li>\n<li>钻石（diamond）操作符范围的延伸</li>\n<li>增强的注释Deprecate</li>\n<li>统一的JVM日志</li>\n<li>注释SafeVarargs范围的延伸</li>\n<li>HTTP 2 客户端</li>\n<li>HTML5风格的Java帮助文档</li>\n<li>保留下划线字符。变量不能被命名为_；</li>\n<li>废弃Applet API；</li>\n<li>javac不再支持Java1.4以及之前的版本；</li>\n<li>废弃Java浏览器插件；</li>\n<li>栈遍历API–栈遍历API能过滤和迟访问在堆栈跟踪中的信息</li>\n</ul>\n<blockquote>\n<p>###目前<code>Java8</code>在Java各版本使用率中已高达<code>60%</code>以上，未来还会继续上升，所以学会用Java8，用好Java8势在必行，本系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。</p>\n<p>##<strong>人生苦短，拥抱Java8。</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Jdk目前已经发展到<code>Java 9</code>了，历史上有两个版本变化比较大，一个是<code>Java 5</code>，另一个就是<code>Java 8</code>。<br>本Java8新特性系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。</p>","more":"<p>#历史版本如下：</p>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th align=\"center\">名称</th>\n<th align=\"right\">发行日期</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JDK 1.1.4</td>\n<td align=\"center\">Sparkler（宝石）</td>\n<td align=\"right\">1997-09-12</td>\n</tr>\n<tr>\n<td>JDK 1.1.5</td>\n<td align=\"center\">Pumpkin（南瓜）</td>\n<td align=\"right\">1997-12-13</td>\n</tr>\n<tr>\n<td>JDK 1.1.6</td>\n<td align=\"center\">Abigail（阿比盖尔–女子名）</td>\n<td align=\"right\">1998-04-24</td>\n</tr>\n<tr>\n<td>JDK 1.1.7</td>\n<td align=\"center\">Brutus（布鲁图–古罗马政治家和将军）</td>\n<td align=\"right\">1998-09-28</td>\n</tr>\n<tr>\n<td>JDK 1.1.8</td>\n<td align=\"center\">Chelsea（切尔西–城市名）</td>\n<td align=\"right\">1998-04-24</td>\n</tr>\n<tr>\n<td>J2SE 1.2</td>\n<td align=\"center\">Playground（运动场</td>\n<td align=\"right\">1998-12-04</td>\n</tr>\n<tr>\n<td>J2SE 1.2.1</td>\n<td align=\"center\">none（无）</td>\n<td align=\"right\">1999-03-30</td>\n</tr>\n<tr>\n<td>J2SE 1.2.2</td>\n<td align=\"center\">Cricket（蟋蟀）</td>\n<td align=\"right\">1999-07-08</td>\n</tr>\n<tr>\n<td>J2SE 1.3</td>\n<td align=\"center\">Kestrel（美洲红隼）</td>\n<td align=\"right\">2000-05-08</td>\n</tr>\n<tr>\n<td>J2SE 1.3.1</td>\n<td align=\"center\">Ladybird（瓢虫）</td>\n<td align=\"right\">2001-05-17</td>\n</tr>\n<tr>\n<td>J2SE 1.4.0</td>\n<td align=\"center\">Merlin（灰背隼）</td>\n<td align=\"right\">2002-02-13</td>\n</tr>\n<tr>\n<td>J2SE 1.4.1</td>\n<td align=\"center\">grasshopper（蚱蜢）</td>\n<td align=\"right\">2002-09-16</td>\n</tr>\n<tr>\n<td>J2SE 1.4.2</td>\n<td align=\"center\">Mantis（螳螂）</td>\n<td align=\"right\">2003-06-26</td>\n</tr>\n<tr>\n<td>Java SE 5.0 (1.5.0)</td>\n<td align=\"center\">Tiger（老虎）</td>\n<td align=\"right\">2004-09-30</td>\n</tr>\n<tr>\n<td>Java SE 6.0 (1.6.0)</td>\n<td align=\"center\">Mustang（野马）</td>\n<td align=\"right\">2006-04-xx</td>\n</tr>\n<tr>\n<td>Java SE 7.0 (1.7.0)</td>\n<td align=\"center\">Dolphin（海豚）</td>\n<td align=\"right\">2011-07-28</td>\n</tr>\n<tr>\n<td>Java SE 8.0 (1.8.0)</td>\n<td align=\"center\">Spider（蜘蛛）</td>\n<td align=\"right\">2014-03-18</td>\n</tr>\n<tr>\n<td>Java SE 9</td>\n<td align=\"center\"></td>\n<td align=\"right\">2017-09-21</td>\n</tr>\n</tbody></table>\n<p>#最近三个版本的新特性如下：<br>##Java 7</p>\n<blockquote>\n<p>开发代号是Dolphin（海豚），于2011-07-28发行</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>switch语句块中允许以字符串作为分支条件；</li>\n<li>在创建泛型对象时应用类型推断；</li>\n<li>在一个语句块中捕获多种异常；</li>\n<li>支持动态语言；</li>\n<li>支持try-with-resources；</li>\n<li>引入Java NIO.2开发包；</li>\n<li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li>\n<li>钻石型语法；</li>\n<li>null值的自动处理。</li>\n</ul>\n<p>##Java 8</p>\n<blockquote>\n<p>开发代号是Spider（蜘蛛），于2014年3月14号发布</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>Lambda表达式</li>\n<li>Pipelines和Streams</li>\n<li>Date和Time API</li>\n<li>Default方法</li>\n<li>Type注解</li>\n<li>Nashhorn JavaScript引擎</li>\n<li>并发计数器</li>\n<li>Parallel操作</li>\n<li>移除PermGen Error</li>\n<li>TLS SNI</li>\n</ul>\n<p>##Java 9</p>\n<blockquote>\n<p>于2017年9月21日发布</p>\n</blockquote>\n<p>引入的新特性包括：</p>\n<ul>\n<li>模块化系统–Jigsaw 项目</li>\n<li>JShell–Java 9 REPL</li>\n<li>集合工厂方法</li>\n<li>接口中的私有方法</li>\n<li>响应式流</li>\n<li>多分辨率图像API–JEP 251</li>\n<li>进程API的改进</li>\n<li>Try-With-Resources</li>\n<li>钻石（diamond）操作符范围的延伸</li>\n<li>增强的注释Deprecate</li>\n<li>统一的JVM日志</li>\n<li>注释SafeVarargs范围的延伸</li>\n<li>HTTP 2 客户端</li>\n<li>HTML5风格的Java帮助文档</li>\n<li>保留下划线字符。变量不能被命名为_；</li>\n<li>废弃Applet API；</li>\n<li>javac不再支持Java1.4以及之前的版本；</li>\n<li>废弃Java浏览器插件；</li>\n<li>栈遍历API–栈遍历API能过滤和迟访问在堆栈跟踪中的信息</li>\n</ul>\n<blockquote>\n<p>###目前<code>Java8</code>在Java各版本使用率中已高达<code>60%</code>以上，未来还会继续上升，所以学会用Java8，用好Java8势在必行，本系列将着重分析理解Java8的新特性，以及其是怎么为我们开发提升效率的。</p>\n<p>##<strong>人生苦短，拥抱Java8。</strong></p>\n</blockquote>"},{"title":"Java9新特性系列（便利的集合工厂方法）","date":"2018-02-25T14:19:23.000Z","_content":"# Java8前时代\n\n>在Java8版本以前，创建一个**只读不可变**的集合，先要初始化，然后塞数据，然后置为只读：\n\n```java\nSet<String> set = new HashSet<>();\nset.add(\"a\");\nset.add(\"b\");\nset.add(\"c\");\nset = Collections.unmodifiableSet(set);\n```\n\n上面的方式占用太多行，能不能用单行表达式呢？用如下方式：\n\n```java\nSet<String> set = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\")));\nSet<String> set = Collections.unmodifiableSet(new HashSet<String>() {{\n    add(\"a\"); add(\"b\"); add(\"c\");\n}});\n```\n\n# Java8\n\n在Java8中可以用流的方法创建，具体可以看之前的一篇文章[Java8新特性系列（Stream）](http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/)，实现方法如下：\n\n```java\nSet<String> set = Collections.unmodifiableSet(Stream.of(\"a\", \"b\", \"c\").collect(toSet()));\n```\n<!--more-->\n\n# Java9\n\nJava9中引入了很多方便的API，Convenience Factory Methods for Collections，即集合工厂方法，[官方Feature](http://openjdk.java.net/jeps/269)，上述的实现中Java9中有如下实现方式：\n\n```java\nSet<String> set = Collections.unmodifiableSet(new HashSet<String>() {{\n    add(\"a\"); add(\"b\"); add(\"c\");\n}});\n```\n\n也可以用如下方式：\n\n```java\nSet<String> set = Set.of(\"a\", \"b\", \"c\");\n```\n\nJava9中`List`提供了一系列类似的方法：\n\n```java\n/**\n * Returns an immutable list containing zero elements.\n * @since 9\n */\nstatic <E> List<E> of() {\n    return ImmutableCollections.List0.instance();\n}\n\n/**\n * Returns an immutable list containing one element.\n * @since 9\n */\nstatic <E> List<E> of(E e1) {\n    return new ImmutableCollections.List1<>(e1);\n}\n\n/**\n * Returns an immutable list containing one element.\n * @since 9\n */\nstatic <E> List<E> of(E e1) {\n    return new ImmutableCollections.List1<>(e1);\n}\n\n/**\n * Returns an immutable list containing three elements.\n * @since 9\n */\nstatic <E> List<E> of(E e1, E e2, E e3) {\n    return new ImmutableCollections.ListN<>(e1, e2, e3);\n}\n\n...\n\n/**\n * Returns an immutable list containing ten elements.\n * @since 9\n */\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n    return new ImmutableCollections.ListN<>(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);\n}\n\n@SafeVarargs\n@SuppressWarnings(\"varargs\")\nstatic <E> List<E> of(E... elements) {\n    switch (elements.length) { // implicit null check of elements\n        case 0:\n            return ImmutableCollections.List0.instance();\n        case 1:\n            return new ImmutableCollections.List1<>(elements[0]);\n        case 2:\n            return new ImmutableCollections.List2<>(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN<>(elements);\n    }\n}\n```\n\nJava9中Set、Map都有类似的方法，创建**只读不可变**的集合：\n\n```java\nSet.of()\n...\nMap.of()\nMap.of(k1, v1)\nMap.of(k1, v1, k2, v2)\nMap.of(k1, v1, k2, v2, k3, v3)\n...\nMap.ofEntries(Map.Entry<K,V>...)\nMap.Entry<K,V> entry(K k, V v)\nMap.ofEntries(\n    entry(k1, v1),\n    entry(k2, v2),\n    entry(k3, v3),\n    // ...\n    entry(kn, vn)\n);\n```","source":"_posts/java9-collection-factory.md","raw":"title: Java9新特性系列（便利的集合工厂方法）\ndate: 2018-02-25 22:19:23\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java8前时代\n\n>在Java8版本以前，创建一个**只读不可变**的集合，先要初始化，然后塞数据，然后置为只读：\n\n```java\nSet<String> set = new HashSet<>();\nset.add(\"a\");\nset.add(\"b\");\nset.add(\"c\");\nset = Collections.unmodifiableSet(set);\n```\n\n上面的方式占用太多行，能不能用单行表达式呢？用如下方式：\n\n```java\nSet<String> set = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\")));\nSet<String> set = Collections.unmodifiableSet(new HashSet<String>() {{\n    add(\"a\"); add(\"b\"); add(\"c\");\n}});\n```\n\n# Java8\n\n在Java8中可以用流的方法创建，具体可以看之前的一篇文章[Java8新特性系列（Stream）](http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/)，实现方法如下：\n\n```java\nSet<String> set = Collections.unmodifiableSet(Stream.of(\"a\", \"b\", \"c\").collect(toSet()));\n```\n<!--more-->\n\n# Java9\n\nJava9中引入了很多方便的API，Convenience Factory Methods for Collections，即集合工厂方法，[官方Feature](http://openjdk.java.net/jeps/269)，上述的实现中Java9中有如下实现方式：\n\n```java\nSet<String> set = Collections.unmodifiableSet(new HashSet<String>() {{\n    add(\"a\"); add(\"b\"); add(\"c\");\n}});\n```\n\n也可以用如下方式：\n\n```java\nSet<String> set = Set.of(\"a\", \"b\", \"c\");\n```\n\nJava9中`List`提供了一系列类似的方法：\n\n```java\n/**\n * Returns an immutable list containing zero elements.\n * @since 9\n */\nstatic <E> List<E> of() {\n    return ImmutableCollections.List0.instance();\n}\n\n/**\n * Returns an immutable list containing one element.\n * @since 9\n */\nstatic <E> List<E> of(E e1) {\n    return new ImmutableCollections.List1<>(e1);\n}\n\n/**\n * Returns an immutable list containing one element.\n * @since 9\n */\nstatic <E> List<E> of(E e1) {\n    return new ImmutableCollections.List1<>(e1);\n}\n\n/**\n * Returns an immutable list containing three elements.\n * @since 9\n */\nstatic <E> List<E> of(E e1, E e2, E e3) {\n    return new ImmutableCollections.ListN<>(e1, e2, e3);\n}\n\n...\n\n/**\n * Returns an immutable list containing ten elements.\n * @since 9\n */\nstatic <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10) {\n    return new ImmutableCollections.ListN<>(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);\n}\n\n@SafeVarargs\n@SuppressWarnings(\"varargs\")\nstatic <E> List<E> of(E... elements) {\n    switch (elements.length) { // implicit null check of elements\n        case 0:\n            return ImmutableCollections.List0.instance();\n        case 1:\n            return new ImmutableCollections.List1<>(elements[0]);\n        case 2:\n            return new ImmutableCollections.List2<>(elements[0], elements[1]);\n        default:\n            return new ImmutableCollections.ListN<>(elements);\n    }\n}\n```\n\nJava9中Set、Map都有类似的方法，创建**只读不可变**的集合：\n\n```java\nSet.of()\n...\nMap.of()\nMap.of(k1, v1)\nMap.of(k1, v1, k2, v2)\nMap.of(k1, v1, k2, v2, k3, v3)\n...\nMap.ofEntries(Map.Entry<K,V>...)\nMap.Entry<K,V> entry(K k, V v)\nMap.ofEntries(\n    entry(k1, v1),\n    entry(k2, v2),\n    entry(k3, v3),\n    // ...\n    entry(kn, vn)\n);\n```","slug":"java9-collection-factory","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2i001erz5mbj3l8hdr","content":"<h1 id=\"Java8前时代\"><a href=\"#Java8前时代\" class=\"headerlink\" title=\"Java8前时代\"></a>Java8前时代</h1><blockquote>\n<p>在Java8版本以前，创建一个<strong>只读不可变</strong>的集合，先要初始化，然后塞数据，然后置为只读：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">set = Collections.unmodifiableSet(set);</span><br></pre></td></tr></table></figure>\n\n<p>上面的方式占用太多行，能不能用单行表达式呢？用如下方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)));</span><br><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>); add(<span class=\"string\">&quot;b&quot;</span>); add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h1><p>在Java8中可以用流的方法创建，具体可以看之前的一篇文章<a href=\"http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/\">Java8新特性系列（Stream）</a>，实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>).collect(toSet()));</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中引入了很多方便的API，Convenience Factory Methods for Collections，即集合工厂方法，<a href=\"http://openjdk.java.net/jeps/269\">官方Feature</a>，上述的实现中Java9中有如下实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>); add(<span class=\"string\">&quot;b&quot;</span>); add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>也可以用如下方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Set.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Java9中<code>List</code>提供了一系列类似的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing zero elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ImmutableCollections.List0.instance();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing one element.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(e1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing one element.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(e1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing three elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1, E e2, E e3)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(e1, e2, e3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing ten elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E... elements)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (elements.length) &#123; <span class=\"comment\">// implicit null check of elements</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ImmutableCollections.List0.instance();</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(elements[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List2&lt;&gt;(elements[<span class=\"number\">0</span>], elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(elements);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java9中Set、Map都有类似的方法，创建<strong>只读不可变</strong>的集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set.of()</span><br><span class=\"line\">...</span><br><span class=\"line\">Map.of()</span><br><span class=\"line\">Map.of(k1, v1)</span><br><span class=\"line\">Map.of(k1, v1, k2, v2)</span><br><span class=\"line\">Map.of(k1, v1, k2, v2, k3, v3)</span><br><span class=\"line\">...</span><br><span class=\"line\">Map.ofEntries(Map.Entry&lt;K,V&gt;...)</span><br><span class=\"line\">Map.Entry&lt;K,V&gt; <span class=\"title function_\">entry</span><span class=\"params\">(K k, V v)</span></span><br><span class=\"line\">Map.ofEntries(</span><br><span class=\"line\">    entry(k1, v1),</span><br><span class=\"line\">    entry(k2, v2),</span><br><span class=\"line\">    entry(k3, v3),</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    entry(kn, vn)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Java8前时代\"><a href=\"#Java8前时代\" class=\"headerlink\" title=\"Java8前时代\"></a>Java8前时代</h1><blockquote>\n<p>在Java8版本以前，创建一个<strong>只读不可变</strong>的集合，先要初始化，然后塞数据，然后置为只读：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">set.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">set = Collections.unmodifiableSet(set);</span><br></pre></td></tr></table></figure>\n\n<p>上面的方式占用太多行，能不能用单行表达式呢？用如下方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)));</span><br><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>); add(<span class=\"string\">&quot;b&quot;</span>); add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h1><p>在Java8中可以用流的方法创建，具体可以看之前的一篇文章<a href=\"http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/\">Java8新特性系列（Stream）</a>，实现方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(Stream.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>).collect(toSet()));</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中引入了很多方便的API，Convenience Factory Methods for Collections，即集合工厂方法，<a href=\"http://openjdk.java.net/jeps/269\">官方Feature</a>，上述的实现中Java9中有如下实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>); add(<span class=\"string\">&quot;b&quot;</span>); add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>也可以用如下方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = Set.of(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Java9中<code>List</code>提供了一系列类似的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing zero elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ImmutableCollections.List0.instance();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing one element.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(e1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing one element.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(e1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing three elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1, E e2, E e3)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(e1, e2, e3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an immutable list containing ten elements.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 9</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SafeVarargs</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> &lt;E&gt; List&lt;E&gt; <span class=\"title function_\">of</span><span class=\"params\">(E... elements)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (elements.length) &#123; <span class=\"comment\">// implicit null check of elements</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ImmutableCollections.List0.instance();</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List1&lt;&gt;(elements[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.List2&lt;&gt;(elements[<span class=\"number\">0</span>], elements[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ImmutableCollections</span>.ListN&lt;&gt;(elements);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java9中Set、Map都有类似的方法，创建<strong>只读不可变</strong>的集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set.of()</span><br><span class=\"line\">...</span><br><span class=\"line\">Map.of()</span><br><span class=\"line\">Map.of(k1, v1)</span><br><span class=\"line\">Map.of(k1, v1, k2, v2)</span><br><span class=\"line\">Map.of(k1, v1, k2, v2, k3, v3)</span><br><span class=\"line\">...</span><br><span class=\"line\">Map.ofEntries(Map.Entry&lt;K,V&gt;...)</span><br><span class=\"line\">Map.Entry&lt;K,V&gt; <span class=\"title function_\">entry</span><span class=\"params\">(K k, V v)</span></span><br><span class=\"line\">Map.ofEntries(</span><br><span class=\"line\">    entry(k1, v1),</span><br><span class=\"line\">    entry(k2, v2),</span><br><span class=\"line\">    entry(k3, v3),</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    entry(kn, vn)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>"},{"title":"Java9新特性系列（<>钻石操作符改进）","date":"2018-02-23T14:16:31.000Z","_content":"# Java7前时代\n\n在Java7之前每次声明泛型变量的时必须左右两边都同时声明泛型：\n\n```java\nList<String> list = new ArrayList<String>();\nSet<String> set = new HashSet<String>();\nMap<String, List<String>> map = new HashMap<String, List<String>>();\n```\n>这样看来右边的泛型声明就变得是多余的了？\n\n# Java7\n\n在Java7中，对这一点进行了改进，就不必两边都要声明泛型，这种只适用<>标记的操作，称之为`钻石操作符Diamond Operator`：\n\n```java\nList<String> list = new ArrayList<>();\nSet<String> set = new HashSet<>();\nMap<String, List<String>> map = new HashMap<>();\n```\n>对比之前的用法是不是很清晰很方便呢？\n\n但是Java7中钻石操作符不允许在匿名类上使用：\n\n```java\nList<String> list = new ArrayList<>();\nList<String> list = new ArrayList<>(){};//报错\nSet<String> set = new HashSet<>();\nSet<String> set = new HashSet<>(){};//报错\nMap<String, List<String>> map = new HashMap<>();\nMap<String, List<String>> map = new HashMap<>(){};//报错\n```\n>如果与匿名类共同使用，会报错：`'<>' cannot be used with anonymous classes`\n\n<!--more-->\n\n# Java9\n\n在Java9中，钻石操作符能与匿名实现类共同使用，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>**Allow diamond with anonymous classes if the argument type of the inferred type is denotable.** Because the inferred type using diamond with an anonymous class constructor could be outside of the set of types supported by the signature attribute, using diamond with anonymous classes was disallowed in Java SE 7. As noted in the JSR 334 proposed final draft, it would be possible to ease this restriction if the inferred type was denotable.\n\n```java\nList<String> list = new ArrayList<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n        \nSet<String> set = new HashSet<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n    \n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n\nMap<String, List<String>> map = new HashMap<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n```","source":"_posts/java9-diamond-operator.md","raw":"title: Java9新特性系列（<>钻石操作符改进）\ndate: 2018-02-23 22:16:31\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java7前时代\n\n在Java7之前每次声明泛型变量的时必须左右两边都同时声明泛型：\n\n```java\nList<String> list = new ArrayList<String>();\nSet<String> set = new HashSet<String>();\nMap<String, List<String>> map = new HashMap<String, List<String>>();\n```\n>这样看来右边的泛型声明就变得是多余的了？\n\n# Java7\n\n在Java7中，对这一点进行了改进，就不必两边都要声明泛型，这种只适用<>标记的操作，称之为`钻石操作符Diamond Operator`：\n\n```java\nList<String> list = new ArrayList<>();\nSet<String> set = new HashSet<>();\nMap<String, List<String>> map = new HashMap<>();\n```\n>对比之前的用法是不是很清晰很方便呢？\n\n但是Java7中钻石操作符不允许在匿名类上使用：\n\n```java\nList<String> list = new ArrayList<>();\nList<String> list = new ArrayList<>(){};//报错\nSet<String> set = new HashSet<>();\nSet<String> set = new HashSet<>(){};//报错\nMap<String, List<String>> map = new HashMap<>();\nMap<String, List<String>> map = new HashMap<>(){};//报错\n```\n>如果与匿名类共同使用，会报错：`'<>' cannot be used with anonymous classes`\n\n<!--more-->\n\n# Java9\n\n在Java9中，钻石操作符能与匿名实现类共同使用，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>**Allow diamond with anonymous classes if the argument type of the inferred type is denotable.** Because the inferred type using diamond with an anonymous class constructor could be outside of the set of types supported by the signature attribute, using diamond with anonymous classes was disallowed in Java SE 7. As noted in the JSR 334 proposed final draft, it would be possible to ease this restriction if the inferred type was denotable.\n\n```java\nList<String> list = new ArrayList<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n        \nSet<String> set = new HashSet<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n    \n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n\nMap<String, List<String>> map = new HashMap<>() {\n    @Override\n    public int size() {\n        return super.size();\n    }\n\n    @Override\n    public String toString() {\n        return super.toString();\n    }\n};\n```","slug":"java9-diamond-operator","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2i001hrz5m181w7vy9","content":"<h1 id=\"Java7前时代\"><a href=\"#Java7前时代\" class=\"headerlink\" title=\"Java7前时代\"></a>Java7前时代</h1><p>在Java7之前每次声明泛型变量的时必须左右两边都同时声明泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样看来右边的泛型声明就变得是多余的了？</p>\n</blockquote>\n<h1 id=\"Java7\"><a href=\"#Java7\" class=\"headerlink\" title=\"Java7\"></a>Java7</h1><p>在Java7中，对这一点进行了改进，就不必两边都要声明泛型，这种只适用&lt;&gt;标记的操作，称之为<code>钻石操作符Diamond Operator</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对比之前的用法是不是很清晰很方便呢？</p>\n</blockquote>\n<p>但是Java7中钻石操作符不允许在匿名类上使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果与匿名类共同使用，会报错：<code>&#39;&lt;&gt;&#39; cannot be used with anonymous classes</code></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>在Java9中，钻石操作符能与匿名实现类共同使用，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p><strong>Allow diamond with anonymous classes if the argument type of the inferred type is denotable.</strong> Because the inferred type using diamond with an anonymous class constructor could be outside of the set of types supported by the signature attribute, using diamond with anonymous classes was disallowed in Java SE 7. As noted in the JSR 334 proposed final draft, it would be possible to ease this restriction if the inferred type was denotable.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Java7前时代\"><a href=\"#Java7前时代\" class=\"headerlink\" title=\"Java7前时代\"></a>Java7前时代</h1><p>在Java7之前每次声明泛型变量的时必须左右两边都同时声明泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;String&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这样看来右边的泛型声明就变得是多余的了？</p>\n</blockquote>\n<h1 id=\"Java7\"><a href=\"#Java7\" class=\"headerlink\" title=\"Java7\"></a>Java7</h1><p>在Java7中，对这一点进行了改进，就不必两边都要声明泛型，这种只适用&lt;&gt;标记的操作，称之为<code>钻石操作符Diamond Operator</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对比之前的用法是不是很清晰很方便呢？</p>\n</blockquote>\n<p>但是Java7中钻石操作符不允许在匿名类上使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;()&#123;&#125;;<span class=\"comment\">//报错</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果与匿名类共同使用，会报错：<code>&#39;&lt;&gt;&#39; cannot be used with anonymous classes</code></p>\n</blockquote>","more":"<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>在Java9中，钻石操作符能与匿名实现类共同使用，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p><strong>Allow diamond with anonymous classes if the argument type of the inferred type is denotable.</strong> Because the inferred type using diamond with an anonymous class constructor could be outside of the set of types supported by the signature attribute, using diamond with anonymous classes was disallowed in Java SE 7. As noted in the JSR 334 proposed final draft, it would be possible to ease this restriction if the inferred type was denotable.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">size</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"Java9新特性系列（HTTP 2 Client）","date":"2018-02-28T14:25:16.000Z","_content":"# HTTP\n\nHTTP，HyperText Transfer Protocol，即超文本传输协议。1999年6月定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1，HTTP/2标准于2015年5月正是发表。\n\n# HTTP/2与HTTP1.1的区别\n\n+ HTTP/2采用二进制格式而非文本格式\n+ 完全的多路复用\n+ 使用头压缩，降低了开销\n+ 让服务器可以主动推送（push）数据到客户端\n\n<!--more-->\n\n# Java9中新的Http Client\n\n[官方Feature](http://openjdk.java.net/jeps/110)：\n\n### 动机\n>The existing HttpURLConnection API and its implementation have numerous problems:\n* The base URLConnection API was designed with multiple protocols in mind, nearly all of which are now defunct (ftp, gopher, etc.).\n* The API predates HTTP/1.1 and is too abstract.\n* It is hard to use, with many undocumented behaviors.\n* It works in blocking mode only (i.e., one thread per request/response).\n\n+ It is very hard to maintain.\n\n### 摘要\n\n>Define a new HTTP client API that implements HTTP/2 and WebSocket, and can replace the legacy HttpURLConnection API. The API will be delivered as an incubator module, as defined in JEP 11, with JDK 9. This implies:\n* The API and implementation will not be part of Java SE.\n* The API will live under the jdk.incubtor namespace.\n* The module will not resolve by default at compile or run time.\n\n### 总结\n\n在Java9之前，都是使用`HttpURLConnection`，本身存在很多问题，比如只支持HTTP/1.1、很难用、只适用于blocking模式、很难维护等等。\n在Java9中，提供了新的方式来处理HTTP调用，提供了新的HTTP Client，将替代HttpURLConnection，并提供对`WebSocket`和`HTTP/2`的支持，且提供流和服务器推送等功能的API。\n\n新的HTTP Client在jdk.incubtor.httpclient模块中，如果要使用，需要在模块声明文件(module-info.java)中引入：\n\n```java\nmodule main_module {\n    ...\n    requires jdk.incubtor.httpclient;\n    ...\n}\n```\n\n### 使用举例\n\n```java\nHttpClient client = HttpClient.newHttpClient(); \nHttpRequest req = HttpRequest.newBuilder(URI.create(\"http://hellomypastor.net\" )).GET().build();\nHttpResponse<String> response = client.send(req, HttpResponse.BodyHandler.asString());\nSystem.out.println(response.statusCode());\nSystem.out.println(response.version().name());\nSystem.out.println(response.body());\n}\n```","source":"_posts/java9-http-2-client.md","raw":"title: Java9新特性系列（HTTP 2 Client）\ndate: 2018-02-28 22:25:16\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# HTTP\n\nHTTP，HyperText Transfer Protocol，即超文本传输协议。1999年6月定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1，HTTP/2标准于2015年5月正是发表。\n\n# HTTP/2与HTTP1.1的区别\n\n+ HTTP/2采用二进制格式而非文本格式\n+ 完全的多路复用\n+ 使用头压缩，降低了开销\n+ 让服务器可以主动推送（push）数据到客户端\n\n<!--more-->\n\n# Java9中新的Http Client\n\n[官方Feature](http://openjdk.java.net/jeps/110)：\n\n### 动机\n>The existing HttpURLConnection API and its implementation have numerous problems:\n* The base URLConnection API was designed with multiple protocols in mind, nearly all of which are now defunct (ftp, gopher, etc.).\n* The API predates HTTP/1.1 and is too abstract.\n* It is hard to use, with many undocumented behaviors.\n* It works in blocking mode only (i.e., one thread per request/response).\n\n+ It is very hard to maintain.\n\n### 摘要\n\n>Define a new HTTP client API that implements HTTP/2 and WebSocket, and can replace the legacy HttpURLConnection API. The API will be delivered as an incubator module, as defined in JEP 11, with JDK 9. This implies:\n* The API and implementation will not be part of Java SE.\n* The API will live under the jdk.incubtor namespace.\n* The module will not resolve by default at compile or run time.\n\n### 总结\n\n在Java9之前，都是使用`HttpURLConnection`，本身存在很多问题，比如只支持HTTP/1.1、很难用、只适用于blocking模式、很难维护等等。\n在Java9中，提供了新的方式来处理HTTP调用，提供了新的HTTP Client，将替代HttpURLConnection，并提供对`WebSocket`和`HTTP/2`的支持，且提供流和服务器推送等功能的API。\n\n新的HTTP Client在jdk.incubtor.httpclient模块中，如果要使用，需要在模块声明文件(module-info.java)中引入：\n\n```java\nmodule main_module {\n    ...\n    requires jdk.incubtor.httpclient;\n    ...\n}\n```\n\n### 使用举例\n\n```java\nHttpClient client = HttpClient.newHttpClient(); \nHttpRequest req = HttpRequest.newBuilder(URI.create(\"http://hellomypastor.net\" )).GET().build();\nHttpResponse<String> response = client.send(req, HttpResponse.BodyHandler.asString());\nSystem.out.println(response.statusCode());\nSystem.out.println(response.version().name());\nSystem.out.println(response.body());\n}\n```","slug":"java9-http-2-client","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2j001lrz5m0ftfh2m5","content":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP，HyperText Transfer Protocol，即超文本传输协议。1999年6月定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1，HTTP&#x2F;2标准于2015年5月正是发表。</p>\n<h1 id=\"HTTP-x2F-2与HTTP1-1的区别\"><a href=\"#HTTP-x2F-2与HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP&#x2F;2与HTTP1.1的区别\"></a>HTTP&#x2F;2与HTTP1.1的区别</h1><ul>\n<li>HTTP&#x2F;2采用二进制格式而非文本格式</li>\n<li>完全的多路复用</li>\n<li>使用头压缩，降低了开销</li>\n<li>让服务器可以主动推送（push）数据到客户端</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9中新的Http-Client\"><a href=\"#Java9中新的Http-Client\" class=\"headerlink\" title=\"Java9中新的Http Client\"></a>Java9中新的Http Client</h1><p><a href=\"http://openjdk.java.net/jeps/110\">官方Feature</a>：</p>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><blockquote>\n<p>The existing HttpURLConnection API and its implementation have numerous problems:</p>\n</blockquote>\n<ul>\n<li>The base URLConnection API was designed with multiple protocols in mind, nearly all of which are now defunct (ftp, gopher, etc.).</li>\n<li>The API predates HTTP&#x2F;1.1 and is too abstract.</li>\n<li>It is hard to use, with many undocumented behaviors.</li>\n<li>It works in blocking mode only (i.e., one thread per request&#x2F;response).</li>\n</ul>\n<ul>\n<li>It is very hard to maintain.</li>\n</ul>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>Define a new HTTP client API that implements HTTP&#x2F;2 and WebSocket, and can replace the legacy HttpURLConnection API. The API will be delivered as an incubator module, as defined in JEP 11, with JDK 9. This implies:</p>\n</blockquote>\n<ul>\n<li>The API and implementation will not be part of Java SE.</li>\n<li>The API will live under the jdk.incubtor namespace.</li>\n<li>The module will not resolve by default at compile or run time.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在Java9之前，都是使用<code>HttpURLConnection</code>，本身存在很多问题，比如只支持HTTP&#x2F;1.1、很难用、只适用于blocking模式、很难维护等等。<br>在Java9中，提供了新的方式来处理HTTP调用，提供了新的HTTP Client，将替代HttpURLConnection，并提供对<code>WebSocket</code>和<code>HTTP/2</code>的支持，且提供流和服务器推送等功能的API。</p>\n<p>新的HTTP Client在jdk.incubtor.httpclient模块中，如果要使用，需要在模块声明文件(module-info.java)中引入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> main_module &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.incubtor.httpclient;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">HttpClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> HttpClient.newHttpClient(); </span><br><span class=\"line\"><span class=\"type\">HttpRequest</span> <span class=\"variable\">req</span> <span class=\"operator\">=</span> HttpRequest.newBuilder(URI.create(<span class=\"string\">&quot;http://hellomypastor.net&quot;</span> )).GET().build();</span><br><span class=\"line\">HttpResponse&lt;String&gt; response = client.send(req, HttpResponse.BodyHandler.asString());</span><br><span class=\"line\">System.out.println(response.statusCode());</span><br><span class=\"line\">System.out.println(response.version().name());</span><br><span class=\"line\">System.out.println(response.body());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h1><p>HTTP，HyperText Transfer Protocol，即超文本传输协议。1999年6月定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1，HTTP&#x2F;2标准于2015年5月正是发表。</p>\n<h1 id=\"HTTP-x2F-2与HTTP1-1的区别\"><a href=\"#HTTP-x2F-2与HTTP1-1的区别\" class=\"headerlink\" title=\"HTTP&#x2F;2与HTTP1.1的区别\"></a>HTTP&#x2F;2与HTTP1.1的区别</h1><ul>\n<li>HTTP&#x2F;2采用二进制格式而非文本格式</li>\n<li>完全的多路复用</li>\n<li>使用头压缩，降低了开销</li>\n<li>让服务器可以主动推送（push）数据到客户端</li>\n</ul>","more":"<h1 id=\"Java9中新的Http-Client\"><a href=\"#Java9中新的Http-Client\" class=\"headerlink\" title=\"Java9中新的Http Client\"></a>Java9中新的Http Client</h1><p><a href=\"http://openjdk.java.net/jeps/110\">官方Feature</a>：</p>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><blockquote>\n<p>The existing HttpURLConnection API and its implementation have numerous problems:</p>\n</blockquote>\n<ul>\n<li>The base URLConnection API was designed with multiple protocols in mind, nearly all of which are now defunct (ftp, gopher, etc.).</li>\n<li>The API predates HTTP&#x2F;1.1 and is too abstract.</li>\n<li>It is hard to use, with many undocumented behaviors.</li>\n<li>It works in blocking mode only (i.e., one thread per request&#x2F;response).</li>\n</ul>\n<ul>\n<li>It is very hard to maintain.</li>\n</ul>\n<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>Define a new HTTP client API that implements HTTP&#x2F;2 and WebSocket, and can replace the legacy HttpURLConnection API. The API will be delivered as an incubator module, as defined in JEP 11, with JDK 9. This implies:</p>\n</blockquote>\n<ul>\n<li>The API and implementation will not be part of Java SE.</li>\n<li>The API will live under the jdk.incubtor namespace.</li>\n<li>The module will not resolve by default at compile or run time.</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在Java9之前，都是使用<code>HttpURLConnection</code>，本身存在很多问题，比如只支持HTTP&#x2F;1.1、很难用、只适用于blocking模式、很难维护等等。<br>在Java9中，提供了新的方式来处理HTTP调用，提供了新的HTTP Client，将替代HttpURLConnection，并提供对<code>WebSocket</code>和<code>HTTP/2</code>的支持，且提供流和服务器推送等功能的API。</p>\n<p>新的HTTP Client在jdk.incubtor.httpclient模块中，如果要使用，需要在模块声明文件(module-info.java)中引入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> main_module &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> jdk.incubtor.httpclient;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">HttpClient</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> HttpClient.newHttpClient(); </span><br><span class=\"line\"><span class=\"type\">HttpRequest</span> <span class=\"variable\">req</span> <span class=\"operator\">=</span> HttpRequest.newBuilder(URI.create(<span class=\"string\">&quot;http://hellomypastor.net&quot;</span> )).GET().build();</span><br><span class=\"line\">HttpResponse&lt;String&gt; response = client.send(req, HttpResponse.BodyHandler.asString());</span><br><span class=\"line\">System.out.println(response.statusCode());</span><br><span class=\"line\">System.out.println(response.version().name());</span><br><span class=\"line\">System.out.println(response.body());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java9新特性系列（JDK与JRE）","date":"2018-01-30T15:59:06.000Z","_content":"# JDK与JRE\nJDK = JRE + 开发工具集(例如Javac编译工具等) \nJRE = JVM + JavaSE标准类库\n\n<!--more-->\n#JDK8的目录结构\n![JDK8目录结构](http://upload-images.jianshu.io/upload_images/2855474-75377787ceb911ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ bin：包含命令行开发和调试工具，如javac，jar和javadoc\n+ include：包含在编译本地代码时使用的 C/C++头文件\n+ lib：包含 JDK 工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类\n+ jre/bin：包含基本命令，如java命令。 在Windows平台上， 它包含系统的运行时动态链接库(DLL)\n+ jre/lib：包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件\n#JDK9的目录结构\n![JDK9目录结构](http://upload-images.jianshu.io/upload_images/2855474-b274b577edf0c72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ bin：包含所有命令。 在Windows平台上，它继续包含系 统的运行时动态链接库\n+ conf：包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties 和.policy文件\n+ include：包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于 JDK 中\n+ jmods：包含JMOD格式的平台模块。创建自定义运行时映像时需要它。它只存在于JDK中","source":"_posts/java9-jdk-jre）.md","raw":"title: Java9新特性系列（JDK与JRE）\ndate: 2018-01-30 23:59:06\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# JDK与JRE\nJDK = JRE + 开发工具集(例如Javac编译工具等) \nJRE = JVM + JavaSE标准类库\n\n<!--more-->\n#JDK8的目录结构\n![JDK8目录结构](http://upload-images.jianshu.io/upload_images/2855474-75377787ceb911ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ bin：包含命令行开发和调试工具，如javac，jar和javadoc\n+ include：包含在编译本地代码时使用的 C/C++头文件\n+ lib：包含 JDK 工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类\n+ jre/bin：包含基本命令，如java命令。 在Windows平台上， 它包含系统的运行时动态链接库(DLL)\n+ jre/lib：包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件\n#JDK9的目录结构\n![JDK9目录结构](http://upload-images.jianshu.io/upload_images/2855474-b274b577edf0c72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ bin：包含所有命令。 在Windows平台上，它继续包含系 统的运行时动态链接库\n+ conf：包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties 和.policy文件\n+ include：包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于 JDK 中\n+ jmods：包含JMOD格式的平台模块。创建自定义运行时映像时需要它。它只存在于JDK中","slug":"java9-jdk-jre）","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2j001orz5m45cc5cc8","content":"<h1 id=\"JDK与JRE\"><a href=\"#JDK与JRE\" class=\"headerlink\" title=\"JDK与JRE\"></a>JDK与JRE</h1><p>JDK &#x3D; JRE + 开发工具集(例如Javac编译工具等)<br>JRE &#x3D; JVM + JavaSE标准类库</p>\n<span id=\"more\"></span>\n<p>#JDK8的目录结构<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-75377787ceb911ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK8目录结构\"></p>\n<ul>\n<li>bin：包含命令行开发和调试工具，如javac，jar和javadoc</li>\n<li>include：包含在编译本地代码时使用的 C&#x2F;C++头文件</li>\n<li>lib：包含 JDK 工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类</li>\n<li>jre&#x2F;bin：包含基本命令，如java命令。 在Windows平台上， 它包含系统的运行时动态链接库(DLL)</li>\n<li>jre&#x2F;lib：包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件</li>\n</ul>\n<p>#JDK9的目录结构<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b274b577edf0c72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK9目录结构\"></p>\n<ul>\n<li>bin：包含所有命令。 在Windows平台上，它继续包含系 统的运行时动态链接库</li>\n<li>conf：包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties 和.policy文件</li>\n<li>include：包含要在以前编译本地代码时使用的C&#x2F;C++头文件。 它只存在于 JDK 中</li>\n<li>jmods：包含JMOD格式的平台模块。创建自定义运行时映像时需要它。它只存在于JDK中</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"JDK与JRE\"><a href=\"#JDK与JRE\" class=\"headerlink\" title=\"JDK与JRE\"></a>JDK与JRE</h1><p>JDK &#x3D; JRE + 开发工具集(例如Javac编译工具等)<br>JRE &#x3D; JVM + JavaSE标准类库</p>","more":"<p>#JDK8的目录结构<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-75377787ceb911ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK8目录结构\"></p>\n<ul>\n<li>bin：包含命令行开发和调试工具，如javac，jar和javadoc</li>\n<li>include：包含在编译本地代码时使用的 C&#x2F;C++头文件</li>\n<li>lib：包含 JDK 工具的几个JAR和其他类型的文件。 它有一个tools.jar文件，其中包含javac编译器的Java类</li>\n<li>jre&#x2F;bin：包含基本命令，如java命令。 在Windows平台上， 它包含系统的运行时动态链接库(DLL)</li>\n<li>jre&#x2F;lib：包含用户可编辑的配置文件，如.properties和.policy文件。包含几个JAR。 rt.jar文件包含运行时的Java类和资源文件</li>\n</ul>\n<p>#JDK9的目录结构<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b274b577edf0c72b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"JDK9目录结构\"></p>\n<ul>\n<li>bin：包含所有命令。 在Windows平台上，它继续包含系 统的运行时动态链接库</li>\n<li>conf：包含用户可编辑的配置文件，例如以前位于jre\\lib目录中的.properties 和.policy文件</li>\n<li>include：包含要在以前编译本地代码时使用的C&#x2F;C++头文件。 它只存在于 JDK 中</li>\n<li>jmods：包含JMOD格式的平台模块。创建自定义运行时映像时需要它。它只存在于JDK中</li>\n</ul>"},{"title":"Java9新特性系列（JShell）","date":"2018-02-20T15:23:12.000Z","_content":"# JShell是什么？\n引入JDK官方的[Summary](http://openjdk.java.net/jeps/222)：\n>Provide an interactive tool to evaluate declarations, statements, and expressions of the Java programming language, together with an API so that other applications can leverage this functionality.\n\n<!--more-->\n+ JShell是Java的REPL工具(Read-eval-print-loop)：交互式解析器，一种命令行工具。它允许你无需使用类或者方法包装来执行Java语句。\n\n+ 像Python和Scala之类的语言早就有交互式编程环境REPL了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。\n\n#JShell的理念\n`即写即得，快速运行`\n\n#JShell的目标\n+ Java9中终于拥有了REPL工具：jShell。利用jShell在没有创建类\n的情况下直接声明变量，计算表达式，执行语句。即开发时可以\n在命令行里直接运行java的代码，而无需创建Java文件，无需跟\n人解释”public static void main(String[] args)”这句废话。\n+ jShell也可以从文件中加载语句或者将语句保存到文件中。\n+ jShell也可以是tab键进行自动补全和自动添加分号。\n\n#JShell使用举例\n+ 进入JShell：\n![进入shell](http://upload-images.jianshu.io/upload_images/2855474-34ff70475f523327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 帮助：\n![帮助](http://upload-images.jianshu.io/upload_images/2855474-63d7f089570840ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 基本使用：\n![基本使用](http://upload-images.jianshu.io/upload_images/2855474-7b4c1788e5fbd843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ Java表达式\nJShell终端还可以自己计算Java表达式。字符串连接、方法回调、算法，诸如此类\n![Java表达式](http://upload-images.jianshu.io/upload_images/2855474-a48e24fe84b5ddbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 分号对于纯语句是可选的：\n![分号对于纯语句可选](http://upload-images.jianshu.io/upload_images/2855474-b45d1f7205faff09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 导入指定的包\n![导入指定的包](http://upload-images.jianshu.io/upload_images/2855474-b9f533bf979e9ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 向前引用\n你在定义方法时可以引用其他方法或变量，且这些方法或变量仅会在一段时间后被定义\n+ Tab键自动补全代码\n![Tab键自动补全代码](http://upload-images.jianshu.io/upload_images/2855474-5355e73e1b89c85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ REPL网络\n使用JShell时，我们不会受限于机器和网络访问，这带来了一些有趣的机会。例如，想想把它当做一个终端来与服务器交流，远程连接到服务器并且从外面控制一些参数。另一个选择是查询数据库，这里真的是有无限可能。\n![REPL网络](http://upload-images.jianshu.io/upload_images/2855474-1466df68e43df40e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 保存和加载工作空间\n    + 列出当前session中所有有效的代码片段\n![代码片段](http://upload-images.jianshu.io/upload_images/2855474-a2045db5764bbcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    + 列出当前session中所有创建过的变量\n![创建过的变量](http://upload-images.jianshu.io/upload_images/2855474-803ceda76ef23bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    + 列出当前session中所有创建过的方法\n![创建过的方法](http://upload-images.jianshu.io/upload_images/2855474-60fd1e84b22722b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 使用外部编辑器来编写java代码\n\n```shell\n/edit add\n```\n+ 从外部文件加载源代码\n\n```shell\n/open xxx.java\n```\n+ 没有受检异常/编译时异常\n![没有受检异常](http://upload-images.jianshu.io/upload_images/2855474-764f973a8d337fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果你一直担心受检异常会毁掉你的REPL经历，无需再担心，JShell在后台为你隐藏好了\n+ 退出shell\n\n```shell\n/exit\n```\n+ JShell API\n\n>JShell除了可以作为单独的JDK工具，还可以提供一个API，它能对外部调用开放所有的功能\n\n+ 在运行中修改定义\n\n>你可以重新声明变量、方法或者类，而无需担心原始的声明。一旦你这样操作了，就会收到一个信息提示你发生了什么，但除此之外一切照旧。\n\n**怎么样？是不是心动了？赶紧试试吧～**","source":"_posts/java9-jshell.md","raw":"title: Java9新特性系列（JShell）\ndate: 2018-02-20 23:23:12\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# JShell是什么？\n引入JDK官方的[Summary](http://openjdk.java.net/jeps/222)：\n>Provide an interactive tool to evaluate declarations, statements, and expressions of the Java programming language, together with an API so that other applications can leverage this functionality.\n\n<!--more-->\n+ JShell是Java的REPL工具(Read-eval-print-loop)：交互式解析器，一种命令行工具。它允许你无需使用类或者方法包装来执行Java语句。\n\n+ 像Python和Scala之类的语言早就有交互式编程环境REPL了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。\n\n#JShell的理念\n`即写即得，快速运行`\n\n#JShell的目标\n+ Java9中终于拥有了REPL工具：jShell。利用jShell在没有创建类\n的情况下直接声明变量，计算表达式，执行语句。即开发时可以\n在命令行里直接运行java的代码，而无需创建Java文件，无需跟\n人解释”public static void main(String[] args)”这句废话。\n+ jShell也可以从文件中加载语句或者将语句保存到文件中。\n+ jShell也可以是tab键进行自动补全和自动添加分号。\n\n#JShell使用举例\n+ 进入JShell：\n![进入shell](http://upload-images.jianshu.io/upload_images/2855474-34ff70475f523327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 帮助：\n![帮助](http://upload-images.jianshu.io/upload_images/2855474-63d7f089570840ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 基本使用：\n![基本使用](http://upload-images.jianshu.io/upload_images/2855474-7b4c1788e5fbd843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ Java表达式\nJShell终端还可以自己计算Java表达式。字符串连接、方法回调、算法，诸如此类\n![Java表达式](http://upload-images.jianshu.io/upload_images/2855474-a48e24fe84b5ddbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 分号对于纯语句是可选的：\n![分号对于纯语句可选](http://upload-images.jianshu.io/upload_images/2855474-b45d1f7205faff09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 导入指定的包\n![导入指定的包](http://upload-images.jianshu.io/upload_images/2855474-b9f533bf979e9ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 向前引用\n你在定义方法时可以引用其他方法或变量，且这些方法或变量仅会在一段时间后被定义\n+ Tab键自动补全代码\n![Tab键自动补全代码](http://upload-images.jianshu.io/upload_images/2855474-5355e73e1b89c85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ REPL网络\n使用JShell时，我们不会受限于机器和网络访问，这带来了一些有趣的机会。例如，想想把它当做一个终端来与服务器交流，远程连接到服务器并且从外面控制一些参数。另一个选择是查询数据库，这里真的是有无限可能。\n![REPL网络](http://upload-images.jianshu.io/upload_images/2855474-1466df68e43df40e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 保存和加载工作空间\n    + 列出当前session中所有有效的代码片段\n![代码片段](http://upload-images.jianshu.io/upload_images/2855474-a2045db5764bbcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    + 列出当前session中所有创建过的变量\n![创建过的变量](http://upload-images.jianshu.io/upload_images/2855474-803ceda76ef23bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    + 列出当前session中所有创建过的方法\n![创建过的方法](http://upload-images.jianshu.io/upload_images/2855474-60fd1e84b22722b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ 使用外部编辑器来编写java代码\n\n```shell\n/edit add\n```\n+ 从外部文件加载源代码\n\n```shell\n/open xxx.java\n```\n+ 没有受检异常/编译时异常\n![没有受检异常](http://upload-images.jianshu.io/upload_images/2855474-764f973a8d337fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果你一直担心受检异常会毁掉你的REPL经历，无需再担心，JShell在后台为你隐藏好了\n+ 退出shell\n\n```shell\n/exit\n```\n+ JShell API\n\n>JShell除了可以作为单独的JDK工具，还可以提供一个API，它能对外部调用开放所有的功能\n\n+ 在运行中修改定义\n\n>你可以重新声明变量、方法或者类，而无需担心原始的声明。一旦你这样操作了，就会收到一个信息提示你发生了什么，但除此之外一切照旧。\n\n**怎么样？是不是心动了？赶紧试试吧～**","slug":"java9-jshell","published":1,"updated":"2025-03-07T13:26:47.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2k001rrz5mcdfo8pfu","content":"<h1 id=\"JShell是什么？\"><a href=\"#JShell是什么？\" class=\"headerlink\" title=\"JShell是什么？\"></a>JShell是什么？</h1><p>引入JDK官方的<a href=\"http://openjdk.java.net/jeps/222\">Summary</a>：</p>\n<blockquote>\n<p>Provide an interactive tool to evaluate declarations, statements, and expressions of the Java programming language, together with an API so that other applications can leverage this functionality.</p>\n</blockquote>\n<span id=\"more\"></span>\n<ul>\n<li><p>JShell是Java的REPL工具(Read-eval-print-loop)：交互式解析器，一种命令行工具。它允许你无需使用类或者方法包装来执行Java语句。</p>\n</li>\n<li><p>像Python和Scala之类的语言早就有交互式编程环境REPL了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。</p>\n</li>\n</ul>\n<p>#JShell的理念<br><code>即写即得，快速运行</code></p>\n<p>#JShell的目标</p>\n<ul>\n<li>Java9中终于拥有了REPL工具：jShell。利用jShell在没有创建类<br>的情况下直接声明变量，计算表达式，执行语句。即开发时可以<br>在命令行里直接运行java的代码，而无需创建Java文件，无需跟<br>人解释”public static void main(String[] args)”这句废话。</li>\n<li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li>\n<li>jShell也可以是tab键进行自动补全和自动添加分号。</li>\n</ul>\n<p>#JShell使用举例</p>\n<ul>\n<li><p>进入JShell：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-34ff70475f523327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进入shell\"></p>\n</li>\n<li><p>帮助：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-63d7f089570840ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"帮助\"></p>\n</li>\n<li><p>基本使用：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-7b4c1788e5fbd843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"基本使用\"></p>\n</li>\n<li><p>Java表达式<br>JShell终端还可以自己计算Java表达式。字符串连接、方法回调、算法，诸如此类<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-a48e24fe84b5ddbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java表达式\"></p>\n</li>\n<li><p>分号对于纯语句是可选的：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b45d1f7205faff09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分号对于纯语句可选\"></p>\n</li>\n<li><p>导入指定的包<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b9f533bf979e9ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"导入指定的包\"></p>\n</li>\n<li><p>向前引用<br>你在定义方法时可以引用其他方法或变量，且这些方法或变量仅会在一段时间后被定义</p>\n</li>\n<li><p>Tab键自动补全代码<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-5355e73e1b89c85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Tab键自动补全代码\"></p>\n</li>\n<li><p>REPL网络<br>使用JShell时，我们不会受限于机器和网络访问，这带来了一些有趣的机会。例如，想想把它当做一个终端来与服务器交流，远程连接到服务器并且从外面控制一些参数。另一个选择是查询数据库，这里真的是有无限可能。<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-1466df68e43df40e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"REPL网络\"></p>\n</li>\n<li><p>保存和加载工作空间</p>\n<ul>\n<li><p>列出当前session中所有有效的代码片段<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-a2045db5764bbcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码片段\"></p>\n</li>\n<li><p>列出当前session中所有创建过的变量</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2855474-803ceda76ef23bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建过的变量\"></p>\n<pre><code>+ 列出当前session中所有创建过的方法\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2855474-60fd1e84b22722b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建过的方法\"></p>\n<ul>\n<li>使用外部编辑器来编写java代码</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/edit add</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从外部文件加载源代码</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/open xxx.java</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有受检异常&#x2F;编译时异常<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-764f973a8d337fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"没有受检异常\"></li>\n</ul>\n<p>如果你一直担心受检异常会毁掉你的REPL经历，无需再担心，JShell在后台为你隐藏好了</p>\n<ul>\n<li>退出shell</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/exit</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JShell API</li>\n</ul>\n<blockquote>\n<p>JShell除了可以作为单独的JDK工具，还可以提供一个API，它能对外部调用开放所有的功能</p>\n</blockquote>\n<ul>\n<li>在运行中修改定义</li>\n</ul>\n<blockquote>\n<p>你可以重新声明变量、方法或者类，而无需担心原始的声明。一旦你这样操作了，就会收到一个信息提示你发生了什么，但除此之外一切照旧。</p>\n</blockquote>\n<p><strong>怎么样？是不是心动了？赶紧试试吧～</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JShell是什么？\"><a href=\"#JShell是什么？\" class=\"headerlink\" title=\"JShell是什么？\"></a>JShell是什么？</h1><p>引入JDK官方的<a href=\"http://openjdk.java.net/jeps/222\">Summary</a>：</p>\n<blockquote>\n<p>Provide an interactive tool to evaluate declarations, statements, and expressions of the Java programming language, together with an API so that other applications can leverage this functionality.</p>\n</blockquote>","more":"<ul>\n<li><p>JShell是Java的REPL工具(Read-eval-print-loop)：交互式解析器，一种命令行工具。它允许你无需使用类或者方法包装来执行Java语句。</p>\n</li>\n<li><p>像Python和Scala之类的语言早就有交互式编程环境REPL了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码，就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文件、声明类、提供测试方法方可实现。</p>\n</li>\n</ul>\n<p>#JShell的理念<br><code>即写即得，快速运行</code></p>\n<p>#JShell的目标</p>\n<ul>\n<li>Java9中终于拥有了REPL工具：jShell。利用jShell在没有创建类<br>的情况下直接声明变量，计算表达式，执行语句。即开发时可以<br>在命令行里直接运行java的代码，而无需创建Java文件，无需跟<br>人解释”public static void main(String[] args)”这句废话。</li>\n<li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li>\n<li>jShell也可以是tab键进行自动补全和自动添加分号。</li>\n</ul>\n<p>#JShell使用举例</p>\n<ul>\n<li><p>进入JShell：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-34ff70475f523327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进入shell\"></p>\n</li>\n<li><p>帮助：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-63d7f089570840ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"帮助\"></p>\n</li>\n<li><p>基本使用：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-7b4c1788e5fbd843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"基本使用\"></p>\n</li>\n<li><p>Java表达式<br>JShell终端还可以自己计算Java表达式。字符串连接、方法回调、算法，诸如此类<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-a48e24fe84b5ddbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Java表达式\"></p>\n</li>\n<li><p>分号对于纯语句是可选的：<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b45d1f7205faff09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"分号对于纯语句可选\"></p>\n</li>\n<li><p>导入指定的包<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-b9f533bf979e9ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"导入指定的包\"></p>\n</li>\n<li><p>向前引用<br>你在定义方法时可以引用其他方法或变量，且这些方法或变量仅会在一段时间后被定义</p>\n</li>\n<li><p>Tab键自动补全代码<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-5355e73e1b89c85a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Tab键自动补全代码\"></p>\n</li>\n<li><p>REPL网络<br>使用JShell时，我们不会受限于机器和网络访问，这带来了一些有趣的机会。例如，想想把它当做一个终端来与服务器交流，远程连接到服务器并且从外面控制一些参数。另一个选择是查询数据库，这里真的是有无限可能。<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-1466df68e43df40e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"REPL网络\"></p>\n</li>\n<li><p>保存和加载工作空间</p>\n<ul>\n<li><p>列出当前session中所有有效的代码片段<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-a2045db5764bbcbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码片段\"></p>\n</li>\n<li><p>列出当前session中所有创建过的变量</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2855474-803ceda76ef23bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建过的变量\"></p>\n<pre><code>+ 列出当前session中所有创建过的方法\n</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2855474-60fd1e84b22722b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建过的方法\"></p>\n<ul>\n<li>使用外部编辑器来编写java代码</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/edit add</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从外部文件加载源代码</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/open xxx.java</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有受检异常&#x2F;编译时异常<br><img src=\"http://upload-images.jianshu.io/upload_images/2855474-764f973a8d337fb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"没有受检异常\"></li>\n</ul>\n<p>如果你一直担心受检异常会毁掉你的REPL经历，无需再担心，JShell在后台为你隐藏好了</p>\n<ul>\n<li>退出shell</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/exit</span><br></pre></td></tr></table></figure>\n<ul>\n<li>JShell API</li>\n</ul>\n<blockquote>\n<p>JShell除了可以作为单独的JDK工具，还可以提供一个API，它能对外部调用开放所有的功能</p>\n</blockquote>\n<ul>\n<li>在运行中修改定义</li>\n</ul>\n<blockquote>\n<p>你可以重新声明变量、方法或者类，而无需担心原始的声明。一旦你这样操作了，就会收到一个信息提示你发生了什么，但除此之外一切照旧。</p>\n</blockquote>\n<p><strong>怎么样？是不是心动了？赶紧试试吧～</strong></p>"},{"title":"Java9新特性系列（Interface改进）","date":"2018-02-21T14:06:58.000Z","_content":"# Java8前时代的Interface\n>在Java8版本以前，Interface接口中所有的方法都是`抽象方法`和`常量`\n\n# Java8\nJava8接口相关的可以看之前的一篇文章[Java8新特性系列（Interface）](http://hellomypastor.net/2017/12/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Interface%EF%BC%89/)\n\n## 静态成员\n>在Java8中Interface支持`静态成员`，成员默认是`public final static`的，可以在类外直接调用。\n\n## default函数\n>在Java8中，Interface中支持函数有实现，只要在函数前加上`default`关键字即可，如下：\n\n## static函数\n>在Java8中允许Interface定义`static`方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练。\n\n## @FunctionalInterface注解\n+ 什么是`函数式接口`？\n\n>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个`Lambda`表达式作为参数。`@FunctionalInterface`注解能帮我们检测Interface是否是函数式接口，但是这个注解**是非必须的，不加也不会报错**。\n\n+ 函数式接口的作用？\n\n>函数式接口，可以在调用时，使用一个lambda表达式作为参数。\n\nJava8中的Interface扩展了Java8之前的接口，更像是一个抽象类。\n\n<!--more-->\n\n# Java9\nJava9中Interface更加灵活强大，支持私有方法，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>**Support for private methods in interfaces** was briefly in consideration for inclusion in Java SE 8 as part of the effort to add support for Lambda Expressions, but was withdrawn to enable better focus on higher priority tasks for Java SE 8. It is now proposed that support for private interface methods be undertaken thereby enabling non abstract methods of an interface to share code between them.\n\n```java\npackage net.hellomypastor.java9;\n\n@FunctionalInterface\npublic interface MyInterface {\n    void test();\n\n    default void defaultMethod() {\n        privateMethod();\n        System.out.println(\"defaultMethod\");\n    }\n\n    public static void staticMethod() {\n        System.out.println(\"staticMethod\");\n    }\n\n    private void privateMethod() {\n        System.out.println(\"privateMethod\");\n    }\n}\n```\n\n>接口中的私有方法供内部调用，不会暴露给实现类。","source":"_posts/java9-interface.md","raw":"title: Java9新特性系列（Interface改进）\ndate: 2018-02-21 22:06:58\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java8前时代的Interface\n>在Java8版本以前，Interface接口中所有的方法都是`抽象方法`和`常量`\n\n# Java8\nJava8接口相关的可以看之前的一篇文章[Java8新特性系列（Interface）](http://hellomypastor.net/2017/12/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Interface%EF%BC%89/)\n\n## 静态成员\n>在Java8中Interface支持`静态成员`，成员默认是`public final static`的，可以在类外直接调用。\n\n## default函数\n>在Java8中，Interface中支持函数有实现，只要在函数前加上`default`关键字即可，如下：\n\n## static函数\n>在Java8中允许Interface定义`static`方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练。\n\n## @FunctionalInterface注解\n+ 什么是`函数式接口`？\n\n>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个`Lambda`表达式作为参数。`@FunctionalInterface`注解能帮我们检测Interface是否是函数式接口，但是这个注解**是非必须的，不加也不会报错**。\n\n+ 函数式接口的作用？\n\n>函数式接口，可以在调用时，使用一个lambda表达式作为参数。\n\nJava8中的Interface扩展了Java8之前的接口，更像是一个抽象类。\n\n<!--more-->\n\n# Java9\nJava9中Interface更加灵活强大，支持私有方法，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>**Support for private methods in interfaces** was briefly in consideration for inclusion in Java SE 8 as part of the effort to add support for Lambda Expressions, but was withdrawn to enable better focus on higher priority tasks for Java SE 8. It is now proposed that support for private interface methods be undertaken thereby enabling non abstract methods of an interface to share code between them.\n\n```java\npackage net.hellomypastor.java9;\n\n@FunctionalInterface\npublic interface MyInterface {\n    void test();\n\n    default void defaultMethod() {\n        privateMethod();\n        System.out.println(\"defaultMethod\");\n    }\n\n    public static void staticMethod() {\n        System.out.println(\"staticMethod\");\n    }\n\n    private void privateMethod() {\n        System.out.println(\"privateMethod\");\n    }\n}\n```\n\n>接口中的私有方法供内部调用，不会暴露给实现类。","slug":"java9-interface","published":1,"updated":"2025-03-07T13:26:47.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2k001urz5meweqdkzu","content":"<h1 id=\"Java8前时代的Interface\"><a href=\"#Java8前时代的Interface\" class=\"headerlink\" title=\"Java8前时代的Interface\"></a>Java8前时代的Interface</h1><blockquote>\n<p>在Java8版本以前，Interface接口中所有的方法都是<code>抽象方法</code>和<code>常量</code></p>\n</blockquote>\n<h1 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h1><p>Java8接口相关的可以看之前的一篇文章<a href=\"http://hellomypastor.net/2017/12/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Interface%EF%BC%89/\">Java8新特性系列（Interface）</a></p>\n<h2 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h2><blockquote>\n<p>在Java8中Interface支持<code>静态成员</code>，成员默认是<code>public final static</code>的，可以在类外直接调用。</p>\n</blockquote>\n<h2 id=\"default函数\"><a href=\"#default函数\" class=\"headerlink\" title=\"default函数\"></a>default函数</h2><blockquote>\n<p>在Java8中，Interface中支持函数有实现，只要在函数前加上<code>default</code>关键字即可，如下：</p>\n</blockquote>\n<h2 id=\"static函数\"><a href=\"#static函数\" class=\"headerlink\" title=\"static函数\"></a>static函数</h2><blockquote>\n<p>在Java8中允许Interface定义<code>static</code>方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练。</p>\n</blockquote>\n<h2 id=\"FunctionalInterface注解\"><a href=\"#FunctionalInterface注解\" class=\"headerlink\" title=\"@FunctionalInterface注解\"></a>@FunctionalInterface注解</h2><ul>\n<li>什么是<code>函数式接口</code>？</li>\n</ul>\n<blockquote>\n<p>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个<code>Lambda</code>表达式作为参数。<code>@FunctionalInterface</code>注解能帮我们检测Interface是否是函数式接口，但是这个注解<strong>是非必须的，不加也不会报错</strong>。</p>\n</blockquote>\n<ul>\n<li>函数式接口的作用？</li>\n</ul>\n<blockquote>\n<p>函数式接口，可以在调用时，使用一个lambda表达式作为参数。</p>\n</blockquote>\n<p>Java8中的Interface扩展了Java8之前的接口，更像是一个抽象类。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中Interface更加灵活强大，支持私有方法，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p><strong>Support for private methods in interfaces</strong> was briefly in consideration for inclusion in Java SE 8 as part of the effort to add support for Lambda Expressions, but was withdrawn to enable better focus on higher priority tasks for Java SE 8. It is now proposed that support for private interface methods be undertaken thereby enabling non abstract methods of an interface to share code between them.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.java9;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">defaultMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        privateMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;defaultMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">staticMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;staticMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">privateMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;privateMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口中的私有方法供内部调用，不会暴露给实现类。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java8前时代的Interface\"><a href=\"#Java8前时代的Interface\" class=\"headerlink\" title=\"Java8前时代的Interface\"></a>Java8前时代的Interface</h1><blockquote>\n<p>在Java8版本以前，Interface接口中所有的方法都是<code>抽象方法</code>和<code>常量</code></p>\n</blockquote>\n<h1 id=\"Java8\"><a href=\"#Java8\" class=\"headerlink\" title=\"Java8\"></a>Java8</h1><p>Java8接口相关的可以看之前的一篇文章<a href=\"http://hellomypastor.net/2017/12/21/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Interface%EF%BC%89/\">Java8新特性系列（Interface）</a></p>\n<h2 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h2><blockquote>\n<p>在Java8中Interface支持<code>静态成员</code>，成员默认是<code>public final static</code>的，可以在类外直接调用。</p>\n</blockquote>\n<h2 id=\"default函数\"><a href=\"#default函数\" class=\"headerlink\" title=\"default函数\"></a>default函数</h2><blockquote>\n<p>在Java8中，Interface中支持函数有实现，只要在函数前加上<code>default</code>关键字即可，如下：</p>\n</blockquote>\n<h2 id=\"static函数\"><a href=\"#static函数\" class=\"headerlink\" title=\"static函数\"></a>static函数</h2><blockquote>\n<p>在Java8中允许Interface定义<code>static</code>方法，这允许API设计者在接口中定义像getInstance一样的静态工具方法，这样就能够使得API简洁而精练。</p>\n</blockquote>\n<h2 id=\"FunctionalInterface注解\"><a href=\"#FunctionalInterface注解\" class=\"headerlink\" title=\"@FunctionalInterface注解\"></a>@FunctionalInterface注解</h2><ul>\n<li>什么是<code>函数式接口</code>？</li>\n</ul>\n<blockquote>\n<p>函数式接口其实本质上还是一个接口，但是它是一种特殊的接口：SAM类型的接口（Single Abstract Method）。定义了这种类型的接口，使得以其为参数的方法，可以在调用时，使用一个<code>Lambda</code>表达式作为参数。<code>@FunctionalInterface</code>注解能帮我们检测Interface是否是函数式接口，但是这个注解<strong>是非必须的，不加也不会报错</strong>。</p>\n</blockquote>\n<ul>\n<li>函数式接口的作用？</li>\n</ul>\n<blockquote>\n<p>函数式接口，可以在调用时，使用一个lambda表达式作为参数。</p>\n</blockquote>\n<p>Java8中的Interface扩展了Java8之前的接口，更像是一个抽象类。</p>","more":"<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中Interface更加灵活强大，支持私有方法，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p><strong>Support for private methods in interfaces</strong> was briefly in consideration for inclusion in Java SE 8 as part of the effort to add support for Lambda Expressions, but was withdrawn to enable better focus on higher priority tasks for Java SE 8. It is now proposed that support for private interface methods be undertaken thereby enabling non abstract methods of an interface to share code between them.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.java9;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">MyInterface</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">defaultMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        privateMethod();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;defaultMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">staticMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;staticMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">privateMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;privateMethod&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口中的私有方法供内部调用，不会暴露给实现类。</p>\n</blockquote>"},{"title":"Java9新特性系列（深入理解模块化）","date":"2018-02-10T14:28:43.000Z","_content":"前两篇文章介绍了Java9新特性系列`JDK与JRE`以及`模块化系统: Jigsaw->Modularity`，本篇我们将深入理解模块化。\n# 模块化如何体现？\n如下图所示，Jdk8与Jdk9的目录结构，这个在之前的jdk与jre的文章已经提及。\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2af83ec?w=807&h=560&f=png&s=19820)\n\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e292d073?w=1240&h=445&f=png&s=44939)\n\n从上面两张图对比可以发现：\nJDK8:\n在Jdk8中有两个重要的jar，即rt.jar与tools.jar：\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2b74006?w=988&h=36&f=png&s=13928)\n\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e29267ed?w=1020&h=30&f=png&s=15027)\n\n在Jdk8中有jre，在jre/lib目录中有一个rt.jar（大小约64M），即rutime，提供了运行环境所用到的一些类库；在lib目录有一个tools.jar（大小约17M），是java中最基本的包，里面包含了从java中最重要的lang包到各种高级功能如可视化swing的包。\n\nJDK9：\nJDK9中没有jre，没有rt.jar，没有tools.jar，都是一个一个模块\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2bbd5f7?w=1240&h=531&f=png&s=478335)\n\n总结：Java8其实是一个单体模式，一个简单的HelloWorld，都需要100多M的JRE环境，Java9引入模块后，模块之间依赖关系更加清晰，只需引用需要的模块。\n\n<!--more-->\n\n# 模块化的安全？\n+ public不再意味着Accessible：\n`requires`：指明对其它模块的依赖\n`exports`：控制着哪些包可以被其它模块访问到。所有不被导出的包默认都被封装在模块里面。\n所以说先有模块的可读性，进一步才是模块内的可访问性（public）。\n\n+ 模块的间接（Transitive）引用：\n比如A模块requires了java.logging模块，B模块requires了A：\n如果没有用transitive关键字，那么B模块还需要引入java.logging模块：\n\n```java\nmodule a_module {\n    requires java.logging;\n}\nmodule b_module {\n    requires java.logging;\n    requires a_module;\n}\n```\n如果使用了transitive关键字，那么B模块就不需要引入java.logging模块：\n\n```java\nmodule a_module {\n    requires java.logging;\n}\nmodule b_module {\n    requires a_module;\n}\n```\n\n# module与maven/gradle是什么关系？\n模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：\n\nMaven 有两个主要的特征：依赖管理和构建管理。\n依赖管理即可以决定库中的版本并从仓库中下载下来。\n构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。\n\nModule是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。\n\n总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。\n具体可参考StackOverflow上的一篇问答：[Project Jigsaw vs Maven on StackOverflow](https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven)\n\n# 模块化之后如何打包？\n+ Jlink：\nJLink是将Module打包的工具，打包后的文件非常精简。\n使用如下：\n\n```shell\n./jlink --module-path ../jmods/ --add-modules java.sql --output /Users/shipeipei/Desktop/xxx\n```\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e463adb4?w=1240&h=28&f=png&s=31588)\n执行脚本后，在桌面生成了xxx文件夹，整个文件夹其实就是一个裁剪后的jdk，大小为49.2M：\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c8477213e8?w=1240&h=663&f=png&s=251851)\n\n# 模块化的原理？\n\n1、将系统内部类进行模块化\n\n2、将ClassLoader分级：\n将ClassLoader分为三个级别：\n+ Bootstrap Loader具有最高优先级和权限，主要是核心的系统类；\n+ Platform Loader用于扩展的一些系统类，例如SQL,XML等；\n+ Application Loader主要用于应用程序的Loader。\n\n在这三个级别的Loader下面有一个统一Module管理，用于控制和管理模块间的依赖关系，可读性，可访问性等。","source":"_posts/java9-module-analysis.md","raw":"title: Java9新特性系列（深入理解模块化）\ndate: 2018-02-10 22:28:43\ncategories: Java\ntags: [Java,Java9新特性]\n---\n前两篇文章介绍了Java9新特性系列`JDK与JRE`以及`模块化系统: Jigsaw->Modularity`，本篇我们将深入理解模块化。\n# 模块化如何体现？\n如下图所示，Jdk8与Jdk9的目录结构，这个在之前的jdk与jre的文章已经提及。\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2af83ec?w=807&h=560&f=png&s=19820)\n\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e292d073?w=1240&h=445&f=png&s=44939)\n\n从上面两张图对比可以发现：\nJDK8:\n在Jdk8中有两个重要的jar，即rt.jar与tools.jar：\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2b74006?w=988&h=36&f=png&s=13928)\n\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e29267ed?w=1020&h=30&f=png&s=15027)\n\n在Jdk8中有jre，在jre/lib目录中有一个rt.jar（大小约64M），即rutime，提供了运行环境所用到的一些类库；在lib目录有一个tools.jar（大小约17M），是java中最基本的包，里面包含了从java中最重要的lang包到各种高级功能如可视化swing的包。\n\nJDK9：\nJDK9中没有jre，没有rt.jar，没有tools.jar，都是一个一个模块\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2bbd5f7?w=1240&h=531&f=png&s=478335)\n\n总结：Java8其实是一个单体模式，一个简单的HelloWorld，都需要100多M的JRE环境，Java9引入模块后，模块之间依赖关系更加清晰，只需引用需要的模块。\n\n<!--more-->\n\n# 模块化的安全？\n+ public不再意味着Accessible：\n`requires`：指明对其它模块的依赖\n`exports`：控制着哪些包可以被其它模块访问到。所有不被导出的包默认都被封装在模块里面。\n所以说先有模块的可读性，进一步才是模块内的可访问性（public）。\n\n+ 模块的间接（Transitive）引用：\n比如A模块requires了java.logging模块，B模块requires了A：\n如果没有用transitive关键字，那么B模块还需要引入java.logging模块：\n\n```java\nmodule a_module {\n    requires java.logging;\n}\nmodule b_module {\n    requires java.logging;\n    requires a_module;\n}\n```\n如果使用了transitive关键字，那么B模块就不需要引入java.logging模块：\n\n```java\nmodule a_module {\n    requires java.logging;\n}\nmodule b_module {\n    requires a_module;\n}\n```\n\n# module与maven/gradle是什么关系？\n模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：\n\nMaven 有两个主要的特征：依赖管理和构建管理。\n依赖管理即可以决定库中的版本并从仓库中下载下来。\n构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。\n\nModule是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。\n\n总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。\n具体可参考StackOverflow上的一篇问答：[Project Jigsaw vs Maven on StackOverflow](https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven)\n\n# 模块化之后如何打包？\n+ Jlink：\nJLink是将Module打包的工具，打包后的文件非常精简。\n使用如下：\n\n```shell\n./jlink --module-path ../jmods/ --add-modules java.sql --output /Users/shipeipei/Desktop/xxx\n```\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e463adb4?w=1240&h=28&f=png&s=31588)\n执行脚本后，在桌面生成了xxx文件夹，整个文件夹其实就是一个裁剪后的jdk，大小为49.2M：\n![](https://user-gold-cdn.xitu.io/2018/2/10/1617f5c8477213e8?w=1240&h=663&f=png&s=251851)\n\n# 模块化的原理？\n\n1、将系统内部类进行模块化\n\n2、将ClassLoader分级：\n将ClassLoader分为三个级别：\n+ Bootstrap Loader具有最高优先级和权限，主要是核心的系统类；\n+ Platform Loader用于扩展的一些系统类，例如SQL,XML等；\n+ Application Loader主要用于应用程序的Loader。\n\n在这三个级别的Loader下面有一个统一Module管理，用于控制和管理模块间的依赖关系，可读性，可访问性等。","slug":"java9-module-analysis","published":1,"updated":"2025-03-07T13:26:47.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2l001wrz5m7uim4l3v","content":"<p>前两篇文章介绍了Java9新特性系列<code>JDK与JRE</code>以及<code>模块化系统: Jigsaw-&gt;Modularity</code>，本篇我们将深入理解模块化。</p>\n<h1 id=\"模块化如何体现？\"><a href=\"#模块化如何体现？\" class=\"headerlink\" title=\"模块化如何体现？\"></a>模块化如何体现？</h1><p>如下图所示，Jdk8与Jdk9的目录结构，这个在之前的jdk与jre的文章已经提及。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2af83ec?w=807&h=560&f=png&s=19820\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e292d073?w=1240&h=445&f=png&s=44939\"></p>\n<p>从上面两张图对比可以发现：<br>JDK8:<br>在Jdk8中有两个重要的jar，即rt.jar与tools.jar：<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2b74006?w=988&h=36&f=png&s=13928\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e29267ed?w=1020&h=30&f=png&s=15027\"></p>\n<p>在Jdk8中有jre，在jre&#x2F;lib目录中有一个rt.jar（大小约64M），即rutime，提供了运行环境所用到的一些类库；在lib目录有一个tools.jar（大小约17M），是java中最基本的包，里面包含了从java中最重要的lang包到各种高级功能如可视化swing的包。</p>\n<p>JDK9：<br>JDK9中没有jre，没有rt.jar，没有tools.jar，都是一个一个模块<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2bbd5f7?w=1240&h=531&f=png&s=478335\"></p>\n<p>总结：Java8其实是一个单体模式，一个简单的HelloWorld，都需要100多M的JRE环境，Java9引入模块后，模块之间依赖关系更加清晰，只需引用需要的模块。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"模块化的安全？\"><a href=\"#模块化的安全？\" class=\"headerlink\" title=\"模块化的安全？\"></a>模块化的安全？</h1><ul>\n<li><p>public不再意味着Accessible：<br><code>requires</code>：指明对其它模块的依赖<br><code>exports</code>：控制着哪些包可以被其它模块访问到。所有不被导出的包默认都被封装在模块里面。<br>所以说先有模块的可读性，进一步才是模块内的可访问性（public）。</p>\n</li>\n<li><p>模块的间接（Transitive）引用：<br>比如A模块requires了java.logging模块，B模块requires了A：<br>如果没有用transitive关键字，那么B模块还需要引入java.logging模块：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> a_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">module</span> b_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> a_module;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果使用了transitive关键字，那么B模块就不需要引入java.logging模块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> a_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">module</span> b_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> a_module;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"module与maven-x2F-gradle是什么关系？\"><a href=\"#module与maven-x2F-gradle是什么关系？\" class=\"headerlink\" title=\"module与maven&#x2F;gradle是什么关系？\"></a>module与maven&#x2F;gradle是什么关系？</h1><p>模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：</p>\n<p>Maven 有两个主要的特征：依赖管理和构建管理。<br>依赖管理即可以决定库中的版本并从仓库中下载下来。<br>构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。</p>\n<p>Module是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。</p>\n<p>总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。<br>具体可参考StackOverflow上的一篇问答：<a href=\"https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven\">Project Jigsaw vs Maven on StackOverflow</a></p>\n<h1 id=\"模块化之后如何打包？\"><a href=\"#模块化之后如何打包？\" class=\"headerlink\" title=\"模块化之后如何打包？\"></a>模块化之后如何打包？</h1><ul>\n<li>Jlink：<br>JLink是将Module打包的工具，打包后的文件非常精简。<br>使用如下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./jlink --module-path ../jmods/ --add-modules java.sql --output /Users/shipeipei/Desktop/xxx</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e463adb4?w=1240&h=28&f=png&s=31588\"><br>执行脚本后，在桌面生成了xxx文件夹，整个文件夹其实就是一个裁剪后的jdk，大小为49.2M：<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c8477213e8?w=1240&h=663&f=png&s=251851\"></p>\n<h1 id=\"模块化的原理？\"><a href=\"#模块化的原理？\" class=\"headerlink\" title=\"模块化的原理？\"></a>模块化的原理？</h1><p>1、将系统内部类进行模块化</p>\n<p>2、将ClassLoader分级：<br>将ClassLoader分为三个级别：</p>\n<ul>\n<li>Bootstrap Loader具有最高优先级和权限，主要是核心的系统类；</li>\n<li>Platform Loader用于扩展的一些系统类，例如SQL,XML等；</li>\n<li>Application Loader主要用于应用程序的Loader。</li>\n</ul>\n<p>在这三个级别的Loader下面有一个统一Module管理，用于控制和管理模块间的依赖关系，可读性，可访问性等。</p>\n","site":{"data":{}},"excerpt":"<p>前两篇文章介绍了Java9新特性系列<code>JDK与JRE</code>以及<code>模块化系统: Jigsaw-&gt;Modularity</code>，本篇我们将深入理解模块化。</p>\n<h1 id=\"模块化如何体现？\"><a href=\"#模块化如何体现？\" class=\"headerlink\" title=\"模块化如何体现？\"></a>模块化如何体现？</h1><p>如下图所示，Jdk8与Jdk9的目录结构，这个在之前的jdk与jre的文章已经提及。<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2af83ec?w=807&h=560&f=png&s=19820\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e292d073?w=1240&h=445&f=png&s=44939\"></p>\n<p>从上面两张图对比可以发现：<br>JDK8:<br>在Jdk8中有两个重要的jar，即rt.jar与tools.jar：<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2b74006?w=988&h=36&f=png&s=13928\"></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e29267ed?w=1020&h=30&f=png&s=15027\"></p>\n<p>在Jdk8中有jre，在jre&#x2F;lib目录中有一个rt.jar（大小约64M），即rutime，提供了运行环境所用到的一些类库；在lib目录有一个tools.jar（大小约17M），是java中最基本的包，里面包含了从java中最重要的lang包到各种高级功能如可视化swing的包。</p>\n<p>JDK9：<br>JDK9中没有jre，没有rt.jar，没有tools.jar，都是一个一个模块<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e2bbd5f7?w=1240&h=531&f=png&s=478335\"></p>\n<p>总结：Java8其实是一个单体模式，一个简单的HelloWorld，都需要100多M的JRE环境，Java9引入模块后，模块之间依赖关系更加清晰，只需引用需要的模块。</p>","more":"<h1 id=\"模块化的安全？\"><a href=\"#模块化的安全？\" class=\"headerlink\" title=\"模块化的安全？\"></a>模块化的安全？</h1><ul>\n<li><p>public不再意味着Accessible：<br><code>requires</code>：指明对其它模块的依赖<br><code>exports</code>：控制着哪些包可以被其它模块访问到。所有不被导出的包默认都被封装在模块里面。<br>所以说先有模块的可读性，进一步才是模块内的可访问性（public）。</p>\n</li>\n<li><p>模块的间接（Transitive）引用：<br>比如A模块requires了java.logging模块，B模块requires了A：<br>如果没有用transitive关键字，那么B模块还需要引入java.logging模块：</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> a_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">module</span> b_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> a_module;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果使用了transitive关键字，那么B模块就不需要引入java.logging模块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> a_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.logging;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">module</span> b_module &#123;</span><br><span class=\"line\">    <span class=\"keyword\">requires</span> a_module;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"module与maven-x2F-gradle是什么关系？\"><a href=\"#module与maven-x2F-gradle是什么关系？\" class=\"headerlink\" title=\"module与maven&#x2F;gradle是什么关系？\"></a>module与maven&#x2F;gradle是什么关系？</h1><p>模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：</p>\n<p>Maven 有两个主要的特征：依赖管理和构建管理。<br>依赖管理即可以决定库中的版本并从仓库中下载下来。<br>构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。</p>\n<p>Module是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。</p>\n<p>总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。<br>具体可参考StackOverflow上的一篇问答：<a href=\"https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven\">Project Jigsaw vs Maven on StackOverflow</a></p>\n<h1 id=\"模块化之后如何打包？\"><a href=\"#模块化之后如何打包？\" class=\"headerlink\" title=\"模块化之后如何打包？\"></a>模块化之后如何打包？</h1><ul>\n<li>Jlink：<br>JLink是将Module打包的工具，打包后的文件非常精简。<br>使用如下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./jlink --module-path ../jmods/ --add-modules java.sql --output /Users/shipeipei/Desktop/xxx</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c7e463adb4?w=1240&h=28&f=png&s=31588\"><br>执行脚本后，在桌面生成了xxx文件夹，整个文件夹其实就是一个裁剪后的jdk，大小为49.2M：<br><img src=\"https://user-gold-cdn.xitu.io/2018/2/10/1617f5c8477213e8?w=1240&h=663&f=png&s=251851\"></p>\n<h1 id=\"模块化的原理？\"><a href=\"#模块化的原理？\" class=\"headerlink\" title=\"模块化的原理？\"></a>模块化的原理？</h1><p>1、将系统内部类进行模块化</p>\n<p>2、将ClassLoader分级：<br>将ClassLoader分为三个级别：</p>\n<ul>\n<li>Bootstrap Loader具有最高优先级和权限，主要是核心的系统类；</li>\n<li>Platform Loader用于扩展的一些系统类，例如SQL,XML等；</li>\n<li>Application Loader主要用于应用程序的Loader。</li>\n</ul>\n<p>在这三个级别的Loader下面有一个统一Module管理，用于控制和管理模块间的依赖关系，可读性，可访问性等。</p>"},{"title":"Java9新特性系列（模块化系统: Jigsaw->Modularity）","date":"2018-01-31T15:08:33.000Z","_content":"# 模块化的前时代\n`Ant时代`\n相信大家对Ant都不陌生，Ant是任务型的，定义了一系列的任务dir／compile／jar等等，缺点是操作文件\n`Maven时代`\nMaven／Gradle相对于Ant，增加了groupId／artifactId，版本管理，依赖管理\n`OSGI时代`\nOSGI用的比较少，估计大家比较陌生，其实我们用的Eclipse及插件都是OSGI编译的\n\n>那么问题来了：当代码库越来越大，怎么管理类库交叉依赖，以及类重复的问题呢？\n\n<!--more-->\n# 产生背景及意义\n+ 谈到Java9大家往往第一个想到的就是Jigsaw项目。众所周知，Java已经发展超过20年(95年最初发布)，Java和相关生态在不断丰富的同时也越来越暴露出一些问题:\n    + `Java运行环境的膨胀和臃肿`。每次JVM启动的时候，至少会有30~60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去(而模块化可以根据模块的需要加载程序运行需要的class)\n    + `当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长`。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效率的提升\n    + `很难真正地对代码进行封装, 而系统并没有对不同部分(也就是JAR文件)之间的依赖关系有个明确的概念`。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。\n    + `类路径本身也存在问题`: 你怎么知晓所有需要的JAR都已经有了, 或者是不是会有重复的项呢?\n\n+ 同时，由于兼容性等各方面的掣肘，对Java进行大刀阔斧的革新越来越困难，Jigsaw从Java7阶段就开始筹备，Java8阶段进行了大量工作，`终于在Java9里落地，一种千呼万唤始出来的意味`。\n\n+ Jigsaw项目(后期更名为Modularity)的工作量和难度大大超出了初始规划。JSR376 Java平台模块化系统(JPMS,Java Platform Module System)作为Jigsaw项目的核心, 其主体部分被分解成6个JEP(JDK Enhancement Proposals)。\n\n+ 作为Java9平台最大的一个特性，随着Java平台模块化系统的落地，开发人员无需再为不断膨胀的 Java平台苦恼，例如，您可以使用**`jlink`工具，根据需要定制运行时环境**。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。\n\n+ 本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，**`模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏`**。\n\n# 设计理念\n`模块独立，化繁为简`\n模块化(以 Java 平台模块系统的形式)将JDK分成一组模块，可以在编译时，运行时或者构建时进行组合。\n\n# 实现目标\n+ 主要目的在于减少内存的开销\n+ 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的\n开发和维护\n+ 改进Java SE平台，使其可以适应不同大小的计算设备\n+ 改进其安全性，可维护性，提高性能","source":"_posts/java9-module-jigsaw-modularity）.md","raw":"title: 'Java9新特性系列（模块化系统: Jigsaw->Modularity）'\ndate: 2018-01-31 23:08:33\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# 模块化的前时代\n`Ant时代`\n相信大家对Ant都不陌生，Ant是任务型的，定义了一系列的任务dir／compile／jar等等，缺点是操作文件\n`Maven时代`\nMaven／Gradle相对于Ant，增加了groupId／artifactId，版本管理，依赖管理\n`OSGI时代`\nOSGI用的比较少，估计大家比较陌生，其实我们用的Eclipse及插件都是OSGI编译的\n\n>那么问题来了：当代码库越来越大，怎么管理类库交叉依赖，以及类重复的问题呢？\n\n<!--more-->\n# 产生背景及意义\n+ 谈到Java9大家往往第一个想到的就是Jigsaw项目。众所周知，Java已经发展超过20年(95年最初发布)，Java和相关生态在不断丰富的同时也越来越暴露出一些问题:\n    + `Java运行环境的膨胀和臃肿`。每次JVM启动的时候，至少会有30~60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去(而模块化可以根据模块的需要加载程序运行需要的class)\n    + `当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长`。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效率的提升\n    + `很难真正地对代码进行封装, 而系统并没有对不同部分(也就是JAR文件)之间的依赖关系有个明确的概念`。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。\n    + `类路径本身也存在问题`: 你怎么知晓所有需要的JAR都已经有了, 或者是不是会有重复的项呢?\n\n+ 同时，由于兼容性等各方面的掣肘，对Java进行大刀阔斧的革新越来越困难，Jigsaw从Java7阶段就开始筹备，Java8阶段进行了大量工作，`终于在Java9里落地，一种千呼万唤始出来的意味`。\n\n+ Jigsaw项目(后期更名为Modularity)的工作量和难度大大超出了初始规划。JSR376 Java平台模块化系统(JPMS,Java Platform Module System)作为Jigsaw项目的核心, 其主体部分被分解成6个JEP(JDK Enhancement Proposals)。\n\n+ 作为Java9平台最大的一个特性，随着Java平台模块化系统的落地，开发人员无需再为不断膨胀的 Java平台苦恼，例如，您可以使用**`jlink`工具，根据需要定制运行时环境**。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。\n\n+ 本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，**`模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏`**。\n\n# 设计理念\n`模块独立，化繁为简`\n模块化(以 Java 平台模块系统的形式)将JDK分成一组模块，可以在编译时，运行时或者构建时进行组合。\n\n# 实现目标\n+ 主要目的在于减少内存的开销\n+ 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的\n开发和维护\n+ 改进Java SE平台，使其可以适应不同大小的计算设备\n+ 改进其安全性，可维护性，提高性能","slug":"java9-module-jigsaw-modularity）","published":1,"updated":"2025-03-07T13:26:47.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2m0020rz5m5zimbtz4","content":"<h1 id=\"模块化的前时代\"><a href=\"#模块化的前时代\" class=\"headerlink\" title=\"模块化的前时代\"></a>模块化的前时代</h1><p><code>Ant时代</code><br>相信大家对Ant都不陌生，Ant是任务型的，定义了一系列的任务dir／compile／jar等等，缺点是操作文件<br><code>Maven时代</code><br>Maven／Gradle相对于Ant，增加了groupId／artifactId，版本管理，依赖管理<br><code>OSGI时代</code><br>OSGI用的比较少，估计大家比较陌生，其实我们用的Eclipse及插件都是OSGI编译的</p>\n<blockquote>\n<p>那么问题来了：当代码库越来越大，怎么管理类库交叉依赖，以及类重复的问题呢？</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"产生背景及意义\"><a href=\"#产生背景及意义\" class=\"headerlink\" title=\"产生背景及意义\"></a>产生背景及意义</h1><ul>\n<li><p>谈到Java9大家往往第一个想到的就是Jigsaw项目。众所周知，Java已经发展超过20年(95年最初发布)，Java和相关生态在不断丰富的同时也越来越暴露出一些问题:</p>\n<ul>\n<li><code>Java运行环境的膨胀和臃肿</code>。每次JVM启动的时候，至少会有30~60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去(而模块化可以根据模块的需要加载程序运行需要的class)</li>\n<li><code>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长</code>。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效率的提升</li>\n<li><code>很难真正地对代码进行封装, 而系统并没有对不同部分(也就是JAR文件)之间的依赖关系有个明确的概念</code>。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。</li>\n<li><code>类路径本身也存在问题</code>: 你怎么知晓所有需要的JAR都已经有了, 或者是不是会有重复的项呢?</li>\n</ul>\n</li>\n<li><p>同时，由于兼容性等各方面的掣肘，对Java进行大刀阔斧的革新越来越困难，Jigsaw从Java7阶段就开始筹备，Java8阶段进行了大量工作，<code>终于在Java9里落地，一种千呼万唤始出来的意味</code>。</p>\n</li>\n<li><p>Jigsaw项目(后期更名为Modularity)的工作量和难度大大超出了初始规划。JSR376 Java平台模块化系统(JPMS,Java Platform Module System)作为Jigsaw项目的核心, 其主体部分被分解成6个JEP(JDK Enhancement Proposals)。</p>\n</li>\n<li><p>作为Java9平台最大的一个特性，随着Java平台模块化系统的落地，开发人员无需再为不断膨胀的 Java平台苦恼，例如，您可以使用**<code>jlink</code>工具，根据需要定制运行时环境**。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。</p>\n</li>\n<li><p>本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，**<code>模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏</code>**。</p>\n</li>\n</ul>\n<h1 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h1><p><code>模块独立，化繁为简</code><br>模块化(以 Java 平台模块系统的形式)将JDK分成一组模块，可以在编译时，运行时或者构建时进行组合。</p>\n<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><ul>\n<li>主要目的在于减少内存的开销</li>\n<li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的<br>开发和维护</li>\n<li>改进Java SE平台，使其可以适应不同大小的计算设备</li>\n<li>改进其安全性，可维护性，提高性能</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"模块化的前时代\"><a href=\"#模块化的前时代\" class=\"headerlink\" title=\"模块化的前时代\"></a>模块化的前时代</h1><p><code>Ant时代</code><br>相信大家对Ant都不陌生，Ant是任务型的，定义了一系列的任务dir／compile／jar等等，缺点是操作文件<br><code>Maven时代</code><br>Maven／Gradle相对于Ant，增加了groupId／artifactId，版本管理，依赖管理<br><code>OSGI时代</code><br>OSGI用的比较少，估计大家比较陌生，其实我们用的Eclipse及插件都是OSGI编译的</p>\n<blockquote>\n<p>那么问题来了：当代码库越来越大，怎么管理类库交叉依赖，以及类重复的问题呢？</p>\n</blockquote>","more":"<h1 id=\"产生背景及意义\"><a href=\"#产生背景及意义\" class=\"headerlink\" title=\"产生背景及意义\"></a>产生背景及意义</h1><ul>\n<li><p>谈到Java9大家往往第一个想到的就是Jigsaw项目。众所周知，Java已经发展超过20年(95年最初发布)，Java和相关生态在不断丰富的同时也越来越暴露出一些问题:</p>\n<ul>\n<li><code>Java运行环境的膨胀和臃肿</code>。每次JVM启动的时候，至少会有30~60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去(而模块化可以根据模块的需要加载程序运行需要的class)</li>\n<li><code>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的增长</code>。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了Java开发和运行效率的提升</li>\n<li><code>很难真正地对代码进行封装, 而系统并没有对不同部分(也就是JAR文件)之间的依赖关系有个明确的概念</code>。每一个公共类都可以被类路径之下任何其它的公共类所访问到，这样就会导致无意中使用了并不想被公开访问的API。</li>\n<li><code>类路径本身也存在问题</code>: 你怎么知晓所有需要的JAR都已经有了, 或者是不是会有重复的项呢?</li>\n</ul>\n</li>\n<li><p>同时，由于兼容性等各方面的掣肘，对Java进行大刀阔斧的革新越来越困难，Jigsaw从Java7阶段就开始筹备，Java8阶段进行了大量工作，<code>终于在Java9里落地，一种千呼万唤始出来的意味</code>。</p>\n</li>\n<li><p>Jigsaw项目(后期更名为Modularity)的工作量和难度大大超出了初始规划。JSR376 Java平台模块化系统(JPMS,Java Platform Module System)作为Jigsaw项目的核心, 其主体部分被分解成6个JEP(JDK Enhancement Proposals)。</p>\n</li>\n<li><p>作为Java9平台最大的一个特性，随着Java平台模块化系统的落地，开发人员无需再为不断膨胀的 Java平台苦恼，例如，您可以使用**<code>jlink</code>工具，根据需要定制运行时环境**。这对于拥有大量镜像的容器应用场景或复杂依赖关系的大型应用等，都具有非常重要的意义。</p>\n</li>\n<li><p>本质上讲，模块(module)的概念，其实就是package外再裹一层，也就是说，用模块来管理各个package，通过声明某个package暴露，不声明默认就是隐藏。因此，**<code>模块化使得代码组织上更安全，因为它可以指定哪些部分可以暴露，哪些部分隐藏</code>**。</p>\n</li>\n</ul>\n<h1 id=\"设计理念\"><a href=\"#设计理念\" class=\"headerlink\" title=\"设计理念\"></a>设计理念</h1><p><code>模块独立，化繁为简</code><br>模块化(以 Java 平台模块系统的形式)将JDK分成一组模块，可以在编译时，运行时或者构建时进行组合。</p>\n<h1 id=\"实现目标\"><a href=\"#实现目标\" class=\"headerlink\" title=\"实现目标\"></a>实现目标</h1><ul>\n<li>主要目的在于减少内存的开销</li>\n<li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的<br>开发和维护</li>\n<li>改进Java SE平台，使其可以适应不同大小的计算设备</li>\n<li>改进其安全性，可维护性，提高性能</li>\n</ul>"},{"title":"Java9新特性系列（module&maven&starter）","date":"2018-02-11T14:30:38.000Z","_content":"上篇已经深入分析了[Java9中的模块化](http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/)，有读者又提到了module与starter是什么关系？本篇将进行分析。\n\n>首先先回顾下module与maven/gradle的关系：\n\n\n# module与maven/gradle是什么关系？\n\n模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：\n\nMaven 有两个主要的特征：依赖管理和构建管理。\n依赖管理即可以决定库中的版本并从仓库中下载下来。\n构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。\n\nModule是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。\n\n总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。\n具体可参考StackOverflow上的一篇问答：[Project Jigsaw vs Maven on StackOverflow](https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven)\n\n<!--more-->\n\n>说到starter，如果用过SpringBoot的开发者可能很熟悉，Starter主要用来简化依赖用的。\n\n\n# Starter是什么？\n**Starter主要用来简化依赖用的**\n+ Starter前时代\n\n在Starter之前做MVC时要引入日志组件，比如log4j，那么需要找到依赖的log4j的版本，有的时候版本不匹配也会出现问题，因为我们也不知道依赖什么版本，那么Starter就应运而生。\n\n+ Starter\n\n我们要在SpringBoot中引入WebMVC的支持时，我们只需引入这个模块spring-boot-starter-web，有了Starter之后，log4j就自动引入了，也不用关心版本这些问题，将这个模块如果解压包出来会发现里面什么都没有，只定义了一些POM依赖，所以说Starter的作用主要是简化依赖。\n\n+ SpringBoot Starters\n\n`《Spring Boot in Action》`的附录B列出了SpringBoot Starters的内容：\n\n| Starter(Group ID: org.springframework.boot) | 传递依赖 | \n| ------------- |-------------|\n| spring-boot-starter-web | org.springframework.boot:spring-boot-starter<br>org.springframework.boot:spring-boot-starter-tomcat<br>org.springframework.boot:spring-boot-starter-validation<br>com.fasterxml.jackson.core:jackson-databind<br>org.springframework:spring-web<br>org.springframework:spring-webmvc |\n| spring-boot-starter-log4j2 |org.apache.logging.log4j:log4j-slf4j-impl<br>org.apache.logging.log4j:log4j-api<br>org.apache.logging.log4j:log4j-core<br>org.slf4j:jcl-over-slf4j<br>org.slf4j:jul-to-slf4j |\n|...|....|\n\n# 如何定义自己的Starter？\n+ 基于已有starter进行扩展（pom.xml）\n```xml\n<!-- 依赖管理 -->\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>1.5.2.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n<!-- 添加依赖 -->\n<dependencies>\n    <!-- 自动配置依赖 -->\n    <dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-autoconfigure</artifactId> \n        <version>1.5.2.RELEASE</version>  \n    </dependency>  \n    <dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-configuration-processor</artifactId>  \n        <version>1.5.2.RELEASE</version>  \n        <optional>true</optional>  \n    </dependency> \n</dependencies>\n```\n+ 定义自动配置配置类\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix=\"dog.proterties\")\npublic class DogProperties {\n    private String name;\n    private int age;\n    //set、get\n}\n```\n\n```java\npackage net.hellomypastor.springboot.starter;\n\npublic class DogService {\n    private DogProperties dogProperties;\n\n    public DogService() {\n\n    }\n\n    public DogService(DogProperties dogProperties) {\n        this.dogProperties = dogProperties;\n    }\n\n    public String getDogName() {\n        return dogProperties.getName();\n    }\n\n    public int getDogAge() {\n        return dogProperties.getAge();\n    }\n}\n```\n\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableConfigurationProperties(DogProperties.class)\n@ConditionalOnClass(DogService.class)\n@ConditionalOnProperty(prefix=\"dog.proterties\", value=\"enabled\", matchIfMissing=true)\npublic class DogAutoConfiguration {\n    @Autowired\n    private DogProperties dogProperties;\n\n    @Bean\n    @ConditionalOnMissingBean(DogService.class)\n    public DogService personService() {\n        DogService dogService = new DogService(dogProperties);\n        return dogService;\n    }\n}\n\n```\n+ 修改META-INF/spring.factories\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=net.hellomypastor.configure.DogAutoConfiguration\n```\n+ 打包\n>spring官方说明定义starter时最好是按`*-spring-boot-starter`的格式进行命名\n```shell\nmvn clean install\n```\n+ 使用\n\n将上述starter作为依赖，并配置application.properties：\n```properties\ndog.properties.name=dog2018\ndog.properties.age=1\n```\n那么在类中只要注入DogService就能获取到配置的值：\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/dog\")\npublic class DogController {\n    @Autowired\n    private DogService dogService;\n\n    @GetMapping(\"name\")\n    public String getDogName() {\n        return dogService.getDogName();\n    }\n\n    @GetMapping(\"age\")\n    public int getDogAge() {\n        return dogService.getDogAge();\n    }\n}\n```\n测试请求结果：\n```xml\nhttp:127.0.0.1:8080/starterdemo/dog/name\n结果：dog2018\nhttp:127.0.0.1:8080/starterdemo/dog/age\n结果：1\n```\n\n>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具`JShell`，敬请期待～","source":"_posts/java9-module-maven-starter.md","raw":"title: Java9新特性系列（module&maven&starter）\ndate: 2018-02-11 22:30:38\ncategories: Java\ntags: [Java,Java9新特性]\n---\n上篇已经深入分析了[Java9中的模块化](http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/)，有读者又提到了module与starter是什么关系？本篇将进行分析。\n\n>首先先回顾下module与maven/gradle的关系：\n\n\n# module与maven/gradle是什么关系？\n\n模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：\n\nMaven 有两个主要的特征：依赖管理和构建管理。\n依赖管理即可以决定库中的版本并从仓库中下载下来。\n构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。\n\nModule是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。\n\n总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。\n具体可参考StackOverflow上的一篇问答：[Project Jigsaw vs Maven on StackOverflow](https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven)\n\n<!--more-->\n\n>说到starter，如果用过SpringBoot的开发者可能很熟悉，Starter主要用来简化依赖用的。\n\n\n# Starter是什么？\n**Starter主要用来简化依赖用的**\n+ Starter前时代\n\n在Starter之前做MVC时要引入日志组件，比如log4j，那么需要找到依赖的log4j的版本，有的时候版本不匹配也会出现问题，因为我们也不知道依赖什么版本，那么Starter就应运而生。\n\n+ Starter\n\n我们要在SpringBoot中引入WebMVC的支持时，我们只需引入这个模块spring-boot-starter-web，有了Starter之后，log4j就自动引入了，也不用关心版本这些问题，将这个模块如果解压包出来会发现里面什么都没有，只定义了一些POM依赖，所以说Starter的作用主要是简化依赖。\n\n+ SpringBoot Starters\n\n`《Spring Boot in Action》`的附录B列出了SpringBoot Starters的内容：\n\n| Starter(Group ID: org.springframework.boot) | 传递依赖 | \n| ------------- |-------------|\n| spring-boot-starter-web | org.springframework.boot:spring-boot-starter<br>org.springframework.boot:spring-boot-starter-tomcat<br>org.springframework.boot:spring-boot-starter-validation<br>com.fasterxml.jackson.core:jackson-databind<br>org.springframework:spring-web<br>org.springframework:spring-webmvc |\n| spring-boot-starter-log4j2 |org.apache.logging.log4j:log4j-slf4j-impl<br>org.apache.logging.log4j:log4j-api<br>org.apache.logging.log4j:log4j-core<br>org.slf4j:jcl-over-slf4j<br>org.slf4j:jul-to-slf4j |\n|...|....|\n\n# 如何定义自己的Starter？\n+ 基于已有starter进行扩展（pom.xml）\n```xml\n<!-- 依赖管理 -->\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>1.5.2.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n<!-- 添加依赖 -->\n<dependencies>\n    <!-- 自动配置依赖 -->\n    <dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-autoconfigure</artifactId> \n        <version>1.5.2.RELEASE</version>  \n    </dependency>  \n    <dependency>  \n        <groupId>org.springframework.boot</groupId>  \n        <artifactId>spring-boot-configuration-processor</artifactId>  \n        <version>1.5.2.RELEASE</version>  \n        <optional>true</optional>  \n    </dependency> \n</dependencies>\n```\n+ 定义自动配置配置类\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\n@ConfigurationProperties(prefix=\"dog.proterties\")\npublic class DogProperties {\n    private String name;\n    private int age;\n    //set、get\n}\n```\n\n```java\npackage net.hellomypastor.springboot.starter;\n\npublic class DogService {\n    private DogProperties dogProperties;\n\n    public DogService() {\n\n    }\n\n    public DogService(DogProperties dogProperties) {\n        this.dogProperties = dogProperties;\n    }\n\n    public String getDogName() {\n        return dogProperties.getName();\n    }\n\n    public int getDogAge() {\n        return dogProperties.getAge();\n    }\n}\n```\n\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnClass;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableConfigurationProperties(DogProperties.class)\n@ConditionalOnClass(DogService.class)\n@ConditionalOnProperty(prefix=\"dog.proterties\", value=\"enabled\", matchIfMissing=true)\npublic class DogAutoConfiguration {\n    @Autowired\n    private DogProperties dogProperties;\n\n    @Bean\n    @ConditionalOnMissingBean(DogService.class)\n    public DogService personService() {\n        DogService dogService = new DogService(dogProperties);\n        return dogService;\n    }\n}\n\n```\n+ 修改META-INF/spring.factories\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=net.hellomypastor.configure.DogAutoConfiguration\n```\n+ 打包\n>spring官方说明定义starter时最好是按`*-spring-boot-starter`的格式进行命名\n```shell\nmvn clean install\n```\n+ 使用\n\n将上述starter作为依赖，并配置application.properties：\n```properties\ndog.properties.name=dog2018\ndog.properties.age=1\n```\n那么在类中只要注入DogService就能获取到配置的值：\n```java\npackage net.hellomypastor.springboot.starter;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/dog\")\npublic class DogController {\n    @Autowired\n    private DogService dogService;\n\n    @GetMapping(\"name\")\n    public String getDogName() {\n        return dogService.getDogName();\n    }\n\n    @GetMapping(\"age\")\n    public int getDogAge() {\n        return dogService.getDogAge();\n    }\n}\n```\n测试请求结果：\n```xml\nhttp:127.0.0.1:8080/starterdemo/dog/name\n结果：dog2018\nhttp:127.0.0.1:8080/starterdemo/dog/age\n结果：1\n```\n\n>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具`JShell`，敬请期待～","slug":"java9-module-maven-starter","published":1,"updated":"2025-03-07T13:26:47.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2n0023rz5mc2sn09vm","content":"<p>上篇已经深入分析了<a href=\"http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/\">Java9中的模块化</a>，有读者又提到了module与starter是什么关系？本篇将进行分析。</p>\n<blockquote>\n<p>首先先回顾下module与maven&#x2F;gradle的关系：</p>\n</blockquote>\n<h1 id=\"module与maven-x2F-gradle是什么关系？\"><a href=\"#module与maven-x2F-gradle是什么关系？\" class=\"headerlink\" title=\"module与maven&#x2F;gradle是什么关系？\"></a>module与maven&#x2F;gradle是什么关系？</h1><p>模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：</p>\n<p>Maven 有两个主要的特征：依赖管理和构建管理。<br>依赖管理即可以决定库中的版本并从仓库中下载下来。<br>构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。</p>\n<p>Module是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。</p>\n<p>总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。<br>具体可参考StackOverflow上的一篇问答：<a href=\"https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven\">Project Jigsaw vs Maven on StackOverflow</a></p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>说到starter，如果用过SpringBoot的开发者可能很熟悉，Starter主要用来简化依赖用的。</p>\n</blockquote>\n<h1 id=\"Starter是什么？\"><a href=\"#Starter是什么？\" class=\"headerlink\" title=\"Starter是什么？\"></a>Starter是什么？</h1><p><strong>Starter主要用来简化依赖用的</strong></p>\n<ul>\n<li>Starter前时代</li>\n</ul>\n<p>在Starter之前做MVC时要引入日志组件，比如log4j，那么需要找到依赖的log4j的版本，有的时候版本不匹配也会出现问题，因为我们也不知道依赖什么版本，那么Starter就应运而生。</p>\n<ul>\n<li>Starter</li>\n</ul>\n<p>我们要在SpringBoot中引入WebMVC的支持时，我们只需引入这个模块spring-boot-starter-web，有了Starter之后，log4j就自动引入了，也不用关心版本这些问题，将这个模块如果解压包出来会发现里面什么都没有，只定义了一些POM依赖，所以说Starter的作用主要是简化依赖。</p>\n<ul>\n<li>SpringBoot Starters</li>\n</ul>\n<p><code>《Spring Boot in Action》</code>的附录B列出了SpringBoot Starters的内容：</p>\n<table>\n<thead>\n<tr>\n<th>Starter(Group ID: org.springframework.boot)</th>\n<th>传递依赖</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>spring-boot-starter-web</td>\n<td>org.springframework.boot:spring-boot-starter<br>org.springframework.boot:spring-boot-starter-tomcat<br>org.springframework.boot:spring-boot-starter-validation<br>com.fasterxml.jackson.core:jackson-databind<br>org.springframework:spring-web<br>org.springframework:spring-webmvc</td>\n</tr>\n<tr>\n<td>spring-boot-starter-log4j2</td>\n<td>org.apache.logging.log4j:log4j-slf4j-impl<br>org.apache.logging.log4j:log4j-api<br>org.apache.logging.log4j:log4j-core<br>org.slf4j:jcl-over-slf4j<br>org.slf4j:jul-to-slf4j</td>\n</tr>\n<tr>\n<td>…</td>\n<td>….</td>\n</tr>\n</tbody></table>\n<h1 id=\"如何定义自己的Starter？\"><a href=\"#如何定义自己的Starter？\" class=\"headerlink\" title=\"如何定义自己的Starter？\"></a>如何定义自己的Starter？</h1><ul>\n<li>基于已有starter进行扩展（pom.xml）<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖管理 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 添加依赖 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自动配置依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>定义自动配置配置类<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix=&quot;dog.proterties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogProperties</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"comment\">//set、get</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogProperties dogProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DogService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DogService</span><span class=\"params\">(DogProperties dogProperties)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dogProperties = dogProperties;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getDogName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogProperties.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getDogAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogProperties.getAge();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(DogProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(DogService.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty(prefix=&quot;dog.proterties&quot;, value=&quot;enabled&quot;, matchIfMissing=true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogAutoConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogProperties dogProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(DogService.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DogService <span class=\"title function_\">personService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DogService</span> <span class=\"variable\">dogService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DogService</span>(dogProperties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改META-INF&#x2F;spring.factories<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">net.hellomypastor.configure.DogAutoConfiguration</span></span><br></pre></td></tr></table></figure></li>\n<li>打包<blockquote>\n<p>spring官方说明定义starter时最好是按<code>*-spring-boot-starter</code>的格式进行命名</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean install</span><br></pre></td></tr></table></figure></li>\n<li>使用</li>\n</ul>\n<p>将上述starter作为依赖，并配置application.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dog.properties.name</span>=<span class=\"string\">dog2018</span></span><br><span class=\"line\"><span class=\"attr\">dog.properties.age</span>=<span class=\"string\">1</span></span><br></pre></td></tr></table></figure>\n<p>那么在类中只要注入DogService就能获取到配置的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/dog&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogService dogService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;name&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getDogName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService.getDogName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;age&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getDogAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService.getDogAge();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试请求结果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:127.0.0.1:8080/starterdemo/dog/name</span><br><span class=\"line\">结果：dog2018</span><br><span class=\"line\">http:127.0.0.1:8080/starterdemo/dog/age</span><br><span class=\"line\">结果：1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具<code>JShell</code>，敬请期待～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>上篇已经深入分析了<a href=\"http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/\">Java9中的模块化</a>，有读者又提到了module与starter是什么关系？本篇将进行分析。</p>\n<blockquote>\n<p>首先先回顾下module与maven&#x2F;gradle的关系：</p>\n</blockquote>\n<h1 id=\"module与maven-x2F-gradle是什么关系？\"><a href=\"#module与maven-x2F-gradle是什么关系？\" class=\"headerlink\" title=\"module与maven&#x2F;gradle是什么关系？\"></a>module与maven&#x2F;gradle是什么关系？</h1><p>模块化的依赖关系，很容易让人联想到mven和gradle，这个在上篇中也提及，后来有读者也提出module和maven是什么关系？解答如下：</p>\n<p>Maven 有两个主要的特征：依赖管理和构建管理。<br>依赖管理即可以决定库中的版本并从仓库中下载下来。<br>构建管理即管理开发过程中的任务，包括初始化、编译、测试、打包等。</p>\n<p>Module是系统内置用于表述组件之间的关系，对于版本的管理还是处于最原始的状体，管理一种强制的依赖关系。</p>\n<p>总结一下：Maven还是主要负责构建管理，Modules 对于像Maven这样的构建工具（build tools）来说扮演的是辅助补充的角色。因为这些构建工具在构建时建立的依赖关系图谱和他们版本可以根据Module来创建，Module强制确定了module和artifacts之间的依赖关系，而Maven对于依赖并非是强制的。<br>具体可参考StackOverflow上的一篇问答：<a href=\"https://stackoverflow.com/questions/39844602/project-jigsaw-vs-maven\">Project Jigsaw vs Maven on StackOverflow</a></p>","more":"<blockquote>\n<p>说到starter，如果用过SpringBoot的开发者可能很熟悉，Starter主要用来简化依赖用的。</p>\n</blockquote>\n<h1 id=\"Starter是什么？\"><a href=\"#Starter是什么？\" class=\"headerlink\" title=\"Starter是什么？\"></a>Starter是什么？</h1><p><strong>Starter主要用来简化依赖用的</strong></p>\n<ul>\n<li>Starter前时代</li>\n</ul>\n<p>在Starter之前做MVC时要引入日志组件，比如log4j，那么需要找到依赖的log4j的版本，有的时候版本不匹配也会出现问题，因为我们也不知道依赖什么版本，那么Starter就应运而生。</p>\n<ul>\n<li>Starter</li>\n</ul>\n<p>我们要在SpringBoot中引入WebMVC的支持时，我们只需引入这个模块spring-boot-starter-web，有了Starter之后，log4j就自动引入了，也不用关心版本这些问题，将这个模块如果解压包出来会发现里面什么都没有，只定义了一些POM依赖，所以说Starter的作用主要是简化依赖。</p>\n<ul>\n<li>SpringBoot Starters</li>\n</ul>\n<p><code>《Spring Boot in Action》</code>的附录B列出了SpringBoot Starters的内容：</p>\n<table>\n<thead>\n<tr>\n<th>Starter(Group ID: org.springframework.boot)</th>\n<th>传递依赖</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>spring-boot-starter-web</td>\n<td>org.springframework.boot:spring-boot-starter<br>org.springframework.boot:spring-boot-starter-tomcat<br>org.springframework.boot:spring-boot-starter-validation<br>com.fasterxml.jackson.core:jackson-databind<br>org.springframework:spring-web<br>org.springframework:spring-webmvc</td>\n</tr>\n<tr>\n<td>spring-boot-starter-log4j2</td>\n<td>org.apache.logging.log4j:log4j-slf4j-impl<br>org.apache.logging.log4j:log4j-api<br>org.apache.logging.log4j:log4j-core<br>org.slf4j:jcl-over-slf4j<br>org.slf4j:jul-to-slf4j</td>\n</tr>\n<tr>\n<td>…</td>\n<td>….</td>\n</tr>\n</tbody></table>\n<h1 id=\"如何定义自己的Starter？\"><a href=\"#如何定义自己的Starter？\" class=\"headerlink\" title=\"如何定义自己的Starter？\"></a>如何定义自己的Starter？</h1><ul>\n<li>基于已有starter进行扩展（pom.xml）<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 依赖管理 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 添加依赖 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自动配置依赖 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>定义自动配置配置类<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix=&quot;dog.proterties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogProperties</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"comment\">//set、get</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogProperties dogProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DogService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DogService</span><span class=\"params\">(DogProperties dogProperties)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dogProperties = dogProperties;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getDogName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogProperties.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getDogAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogProperties.getAge();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties(DogProperties.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass(DogService.class)</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty(prefix=&quot;dog.proterties&quot;, value=&quot;enabled&quot;, matchIfMissing=true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogAutoConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogProperties dogProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConditionalOnMissingBean(DogService.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DogService <span class=\"title function_\">personService</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DogService</span> <span class=\"variable\">dogService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DogService</span>(dogProperties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改META-INF&#x2F;spring.factories<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=\"string\">net.hellomypastor.configure.DogAutoConfiguration</span></span><br></pre></td></tr></table></figure></li>\n<li>打包<blockquote>\n<p>spring官方说明定义starter时最好是按<code>*-spring-boot-starter</code>的格式进行命名</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean install</span><br></pre></td></tr></table></figure></li>\n<li>使用</li>\n</ul>\n<p>将上述starter作为依赖，并配置application.properties：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dog.properties.name</span>=<span class=\"string\">dog2018</span></span><br><span class=\"line\"><span class=\"attr\">dog.properties.age</span>=<span class=\"string\">1</span></span><br></pre></td></tr></table></figure>\n<p>那么在类中只要注入DogService就能获取到配置的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> net.hellomypastor.springboot.starter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/dog&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DogController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DogService dogService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;name&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getDogName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService.getDogName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;age&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getDogAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dogService.getDogAge();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试请求结果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:127.0.0.1:8080/starterdemo/dog/name</span><br><span class=\"line\">结果：dog2018</span><br><span class=\"line\">http:127.0.0.1:8080/starterdemo/dog/age</span><br><span class=\"line\">结果：1</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具<code>JShell</code>，敬请期待～</p>\n</blockquote>"},{"title":"Java9新特性系列（module&spi）","date":"2018-02-13T14:32:30.000Z","_content":"上两篇已经深入分析了[Java9新特性系列（深入理解模块化）](http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/)，以及[Java9新特性系列（module&maven&starter）](http://hellomypastor.net/2018/02/11/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88module-maven-starter%EF%BC%89/)，有读者又提到了与模块化相关的`spi`，本篇将进行分析。\n# SPI是什么？\n提到SPI呢，就不得不提一下API：\n\nAPI：Application Programming Interface，即应用程序编程接口，在程序外部进行调用\n\nSPI：Service Provider Interface，服务提供商接口\n\n# SPI核心思想是什么？\n我们知道，一个系统中会有很多模块，比如数据库模块、日志模块、调度模块、各种业务模块等等，每一类的模块都有很多种实现，\n数据库可以用mysql、oracle等，日志可以用log4j、logback等，那么对于不同的场景有不同的选型，如何能做到可插拔呢，那就是SPI了。\n>可插拔原则可以理解为系统与插件的关系，系统提供了一些接口，第三方插件进行实现。\n\n面向接口编程，不绑定实现，为了在模块装配的时候不在代码中动态去指定具体的实现，就需要去发现具体的实现，即服务发现，其实就类似于回调，只不过回调的时候需要找到具体的实现，spi就帮我们做了去寻找实现的工作。\n>这一思想在模块化设计中尤为重要。\n\n# SPI实现方式？\nSPI具体的实现方式分两种：\n+ 应用系统自身提供默认实现\n+ 第三方提供实现\n\n<!--more-->\n\n# SPI有什么例子呢？\n>下面我们就以jdk中的jdbc模块儿进行分析：\n\n```java\npackage java.sql;\n\nimport java.util.logging.Logger;\n\npublic interface Driver {\n    Connection connect(String url, java.util.Properties info)\n        throws SQLException;\n    \n    boolean acceptsURL(String url) throws SQLException;\n    \n    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)\n                         throws SQLException;\n    \n    int getMajorVersion();\n    \n    int getMinorVersion();\n    \n    boolean jdbcCompliant();\n    \n    public Logger getParentLogger() throws SQLFeatureNotSupportedException;\n}\n```\n>我们可以看到，java.sql.Driver接口定义了每个实现必须实现的一些方法，接下来我们就看具体的实现：\n\n+ mysql\n\nMETA-INF/services/java.sql.Driver\n\n```\ncom.mysql.jdbc.Driver\ncom.mysql.fabric.jdbc.FabricMySQLDriver\n```\n在这个文件中指定了具体的实现\n\n+ oracle\n\nMETA-INF/services/java.sql.Driver\n\n```\noracle.jdbc.OracleDriver\n```\n>在JDBC4以前，我们还需要使用比如Class.forName(\"com.mysql.jdbc.Driver\")的方式来装载驱动。<br><br>如上图所示：<br>JDBC也基于spi的机制来发现驱动提供商了，可以通过`META-INF/services/java.sql.Driver`文件里指定实现类的方式来暴露驱动提供者。<br><br>其中，`META-INF/services/`是固定的，`java.sql.Driver`为接口对应的`package`，文件中为具体的实现类。\n\n# SPI如何被框架发现呢？\n>框架可以使用java提供的java.util.ServiceLoader类得到SPI的实现。我们来看下java.sql.DriverManager中是如何去发现的：\n\n```java\nprivate static void loadInitialDrivers() {\n    ...\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            // 获取具体的实现类\n            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n            Iterator<Driver> driversIterator = loadedDrivers.iterator();\n            try{\n                while(driversIterator.hasNext()) {\n                    driversIterator.next();\n                }\n            } catch(Throwable t) {\n                // Do nothing\n            }\n            return null;\n        }\n    });\n    \n    ...\n    \n    for (String aDriver : driversList) {\n        try {\n            println(\"DriverManager.Initialize: loading \" + aDriver);\n            Class.forName(aDriver, true,\n                    ClassLoader.getSystemClassLoader());\n        } catch (Exception ex) {\n            println(\"DriverManager.Initialize: load failed: \" + ex);\n        }\n    }\n}\n```\n>使用`ServiceLoader<XXX> loadedDrivers = ServiceLoader.load(XXX.class);`，实际上就是到具体的路径下读取文件内容。\n\n# SPI应用\n用过阿里`Dubbo`的开发者都知道，Dubbo对JDK中SPI进行了扩展和改进，这个在以后dubbo相关的文章中再进行介绍~\n\n\n>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具`JShell`，敬请期待～","source":"_posts/java9-module-spi.md","raw":"title: Java9新特性系列（module&spi）\ndate: 2018-02-13 22:32:30\ncategories: Java\ntags: [Java,Java9新特性]\n---\n上两篇已经深入分析了[Java9新特性系列（深入理解模块化）](http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/)，以及[Java9新特性系列（module&maven&starter）](http://hellomypastor.net/2018/02/11/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88module-maven-starter%EF%BC%89/)，有读者又提到了与模块化相关的`spi`，本篇将进行分析。\n# SPI是什么？\n提到SPI呢，就不得不提一下API：\n\nAPI：Application Programming Interface，即应用程序编程接口，在程序外部进行调用\n\nSPI：Service Provider Interface，服务提供商接口\n\n# SPI核心思想是什么？\n我们知道，一个系统中会有很多模块，比如数据库模块、日志模块、调度模块、各种业务模块等等，每一类的模块都有很多种实现，\n数据库可以用mysql、oracle等，日志可以用log4j、logback等，那么对于不同的场景有不同的选型，如何能做到可插拔呢，那就是SPI了。\n>可插拔原则可以理解为系统与插件的关系，系统提供了一些接口，第三方插件进行实现。\n\n面向接口编程，不绑定实现，为了在模块装配的时候不在代码中动态去指定具体的实现，就需要去发现具体的实现，即服务发现，其实就类似于回调，只不过回调的时候需要找到具体的实现，spi就帮我们做了去寻找实现的工作。\n>这一思想在模块化设计中尤为重要。\n\n# SPI实现方式？\nSPI具体的实现方式分两种：\n+ 应用系统自身提供默认实现\n+ 第三方提供实现\n\n<!--more-->\n\n# SPI有什么例子呢？\n>下面我们就以jdk中的jdbc模块儿进行分析：\n\n```java\npackage java.sql;\n\nimport java.util.logging.Logger;\n\npublic interface Driver {\n    Connection connect(String url, java.util.Properties info)\n        throws SQLException;\n    \n    boolean acceptsURL(String url) throws SQLException;\n    \n    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)\n                         throws SQLException;\n    \n    int getMajorVersion();\n    \n    int getMinorVersion();\n    \n    boolean jdbcCompliant();\n    \n    public Logger getParentLogger() throws SQLFeatureNotSupportedException;\n}\n```\n>我们可以看到，java.sql.Driver接口定义了每个实现必须实现的一些方法，接下来我们就看具体的实现：\n\n+ mysql\n\nMETA-INF/services/java.sql.Driver\n\n```\ncom.mysql.jdbc.Driver\ncom.mysql.fabric.jdbc.FabricMySQLDriver\n```\n在这个文件中指定了具体的实现\n\n+ oracle\n\nMETA-INF/services/java.sql.Driver\n\n```\noracle.jdbc.OracleDriver\n```\n>在JDBC4以前，我们还需要使用比如Class.forName(\"com.mysql.jdbc.Driver\")的方式来装载驱动。<br><br>如上图所示：<br>JDBC也基于spi的机制来发现驱动提供商了，可以通过`META-INF/services/java.sql.Driver`文件里指定实现类的方式来暴露驱动提供者。<br><br>其中，`META-INF/services/`是固定的，`java.sql.Driver`为接口对应的`package`，文件中为具体的实现类。\n\n# SPI如何被框架发现呢？\n>框架可以使用java提供的java.util.ServiceLoader类得到SPI的实现。我们来看下java.sql.DriverManager中是如何去发现的：\n\n```java\nprivate static void loadInitialDrivers() {\n    ...\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            // 获取具体的实现类\n            ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);\n            Iterator<Driver> driversIterator = loadedDrivers.iterator();\n            try{\n                while(driversIterator.hasNext()) {\n                    driversIterator.next();\n                }\n            } catch(Throwable t) {\n                // Do nothing\n            }\n            return null;\n        }\n    });\n    \n    ...\n    \n    for (String aDriver : driversList) {\n        try {\n            println(\"DriverManager.Initialize: loading \" + aDriver);\n            Class.forName(aDriver, true,\n                    ClassLoader.getSystemClassLoader());\n        } catch (Exception ex) {\n            println(\"DriverManager.Initialize: load failed: \" + ex);\n        }\n    }\n}\n```\n>使用`ServiceLoader<XXX> loadedDrivers = ServiceLoader.load(XXX.class);`，实际上就是到具体的路径下读取文件内容。\n\n# SPI应用\n用过阿里`Dubbo`的开发者都知道，Dubbo对JDK中SPI进行了扩展和改进，这个在以后dubbo相关的文章中再进行介绍~\n\n\n>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具`JShell`，敬请期待～","slug":"java9-module-spi","published":1,"updated":"2025-03-07T13:26:47.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2n0027rz5m23sq4216","content":"<p>上两篇已经深入分析了<a href=\"http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/\">Java9新特性系列（深入理解模块化）</a>，以及<a href=\"http://hellomypastor.net/2018/02/11/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88module-maven-starter%EF%BC%89/\">Java9新特性系列（module&amp;maven&amp;starter）</a>，有读者又提到了与模块化相关的<code>spi</code>，本篇将进行分析。</p>\n<h1 id=\"SPI是什么？\"><a href=\"#SPI是什么？\" class=\"headerlink\" title=\"SPI是什么？\"></a>SPI是什么？</h1><p>提到SPI呢，就不得不提一下API：</p>\n<p>API：Application Programming Interface，即应用程序编程接口，在程序外部进行调用</p>\n<p>SPI：Service Provider Interface，服务提供商接口</p>\n<h1 id=\"SPI核心思想是什么？\"><a href=\"#SPI核心思想是什么？\" class=\"headerlink\" title=\"SPI核心思想是什么？\"></a>SPI核心思想是什么？</h1><p>我们知道，一个系统中会有很多模块，比如数据库模块、日志模块、调度模块、各种业务模块等等，每一类的模块都有很多种实现，<br>数据库可以用mysql、oracle等，日志可以用log4j、logback等，那么对于不同的场景有不同的选型，如何能做到可插拔呢，那就是SPI了。</p>\n<blockquote>\n<p>可插拔原则可以理解为系统与插件的关系，系统提供了一些接口，第三方插件进行实现。</p>\n</blockquote>\n<p>面向接口编程，不绑定实现，为了在模块装配的时候不在代码中动态去指定具体的实现，就需要去发现具体的实现，即服务发现，其实就类似于回调，只不过回调的时候需要找到具体的实现，spi就帮我们做了去寻找实现的工作。</p>\n<blockquote>\n<p>这一思想在模块化设计中尤为重要。</p>\n</blockquote>\n<h1 id=\"SPI实现方式？\"><a href=\"#SPI实现方式？\" class=\"headerlink\" title=\"SPI实现方式？\"></a>SPI实现方式？</h1><p>SPI具体的实现方式分两种：</p>\n<ul>\n<li>应用系统自身提供默认实现</li>\n<li>第三方提供实现</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"SPI有什么例子呢？\"><a href=\"#SPI有什么例子呢？\" class=\"headerlink\" title=\"SPI有什么例子呢？\"></a>SPI有什么例子呢？</h1><blockquote>\n<p>下面我们就以jdk中的jdbc模块儿进行分析：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.sql;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Driver</span> &#123;</span><br><span class=\"line\">    Connection <span class=\"title function_\">connect</span><span class=\"params\">(String url, java.util.Properties info)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsURL</span><span class=\"params\">(String url)</span> <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)</span><br><span class=\"line\">                         <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">getMajorVersion</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">getMinorVersion</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">jdbcCompliant</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Logger <span class=\"title function_\">getParentLogger</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLFeatureNotSupportedException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们可以看到，java.sql.Driver接口定义了每个实现必须实现的一些方法，接下来我们就看具体的实现：</p>\n</blockquote>\n<ul>\n<li>mysql</li>\n</ul>\n<p>META-INF&#x2F;services&#x2F;java.sql.Driver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.mysql.jdbc.Driver</span><br><span class=\"line\">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure>\n<p>在这个文件中指定了具体的实现</p>\n<ul>\n<li>oracle</li>\n</ul>\n<p>META-INF&#x2F;services&#x2F;java.sql.Driver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oracle.jdbc.OracleDriver</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在JDBC4以前，我们还需要使用比如Class.forName(“com.mysql.jdbc.Driver”)的方式来装载驱动。<br><br>如上图所示：<br>JDBC也基于spi的机制来发现驱动提供商了，可以通过<code>META-INF/services/java.sql.Driver</code>文件里指定实现类的方式来暴露驱动提供者。<br><br>其中，<code>META-INF/services/</code>是固定的，<code>java.sql.Driver</code>为接口对应的<code>package</code>，文件中为具体的实现类。</p>\n</blockquote>\n<h1 id=\"SPI如何被框架发现呢？\"><a href=\"#SPI如何被框架发现呢？\" class=\"headerlink\" title=\"SPI如何被框架发现呢？\"></a>SPI如何被框架发现呢？</h1><blockquote>\n<p>框架可以使用java提供的java.util.ServiceLoader类得到SPI的实现。我们来看下java.sql.DriverManager中是如何去发现的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInitialDrivers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    AccessController.doPrivileged(<span class=\"keyword\">new</span> <span class=\"title class_\">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Void <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取具体的实现类</span></span><br><span class=\"line\">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class=\"line\">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(driversIterator.hasNext()) &#123;</span><br><span class=\"line\">                    driversIterator.next();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(Throwable t) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Do nothing</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String aDriver : driversList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            println(<span class=\"string\">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class=\"line\">            Class.forName(aDriver, <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    ClassLoader.getSystemClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用<code>ServiceLoader&lt;XXX&gt; loadedDrivers = ServiceLoader.load(XXX.class);</code>，实际上就是到具体的路径下读取文件内容。</p>\n</blockquote>\n<h1 id=\"SPI应用\"><a href=\"#SPI应用\" class=\"headerlink\" title=\"SPI应用\"></a>SPI应用</h1><p>用过阿里<code>Dubbo</code>的开发者都知道，Dubbo对JDK中SPI进行了扩展和改进，这个在以后dubbo相关的文章中再进行介绍~</p>\n<blockquote>\n<p>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具<code>JShell</code>，敬请期待～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>上两篇已经深入分析了<a href=\"http://hellomypastor.net/2018/02/10/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89/\">Java9新特性系列（深入理解模块化）</a>，以及<a href=\"http://hellomypastor.net/2018/02/11/Java9%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%EF%BC%88module-maven-starter%EF%BC%89/\">Java9新特性系列（module&amp;maven&amp;starter）</a>，有读者又提到了与模块化相关的<code>spi</code>，本篇将进行分析。</p>\n<h1 id=\"SPI是什么？\"><a href=\"#SPI是什么？\" class=\"headerlink\" title=\"SPI是什么？\"></a>SPI是什么？</h1><p>提到SPI呢，就不得不提一下API：</p>\n<p>API：Application Programming Interface，即应用程序编程接口，在程序外部进行调用</p>\n<p>SPI：Service Provider Interface，服务提供商接口</p>\n<h1 id=\"SPI核心思想是什么？\"><a href=\"#SPI核心思想是什么？\" class=\"headerlink\" title=\"SPI核心思想是什么？\"></a>SPI核心思想是什么？</h1><p>我们知道，一个系统中会有很多模块，比如数据库模块、日志模块、调度模块、各种业务模块等等，每一类的模块都有很多种实现，<br>数据库可以用mysql、oracle等，日志可以用log4j、logback等，那么对于不同的场景有不同的选型，如何能做到可插拔呢，那就是SPI了。</p>\n<blockquote>\n<p>可插拔原则可以理解为系统与插件的关系，系统提供了一些接口，第三方插件进行实现。</p>\n</blockquote>\n<p>面向接口编程，不绑定实现，为了在模块装配的时候不在代码中动态去指定具体的实现，就需要去发现具体的实现，即服务发现，其实就类似于回调，只不过回调的时候需要找到具体的实现，spi就帮我们做了去寻找实现的工作。</p>\n<blockquote>\n<p>这一思想在模块化设计中尤为重要。</p>\n</blockquote>\n<h1 id=\"SPI实现方式？\"><a href=\"#SPI实现方式？\" class=\"headerlink\" title=\"SPI实现方式？\"></a>SPI实现方式？</h1><p>SPI具体的实现方式分两种：</p>\n<ul>\n<li>应用系统自身提供默认实现</li>\n<li>第三方提供实现</li>\n</ul>","more":"<h1 id=\"SPI有什么例子呢？\"><a href=\"#SPI有什么例子呢？\" class=\"headerlink\" title=\"SPI有什么例子呢？\"></a>SPI有什么例子呢？</h1><blockquote>\n<p>下面我们就以jdk中的jdbc模块儿进行分析：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.sql;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Driver</span> &#123;</span><br><span class=\"line\">    Connection <span class=\"title function_\">connect</span><span class=\"params\">(String url, java.util.Properties info)</span></span><br><span class=\"line\">        <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsURL</span><span class=\"params\">(String url)</span> <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)</span><br><span class=\"line\">                         <span class=\"keyword\">throws</span> SQLException;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">getMajorVersion</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">getMinorVersion</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">jdbcCompliant</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Logger <span class=\"title function_\">getParentLogger</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLFeatureNotSupportedException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们可以看到，java.sql.Driver接口定义了每个实现必须实现的一些方法，接下来我们就看具体的实现：</p>\n</blockquote>\n<ul>\n<li>mysql</li>\n</ul>\n<p>META-INF&#x2F;services&#x2F;java.sql.Driver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.mysql.jdbc.Driver</span><br><span class=\"line\">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure>\n<p>在这个文件中指定了具体的实现</p>\n<ul>\n<li>oracle</li>\n</ul>\n<p>META-INF&#x2F;services&#x2F;java.sql.Driver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oracle.jdbc.OracleDriver</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在JDBC4以前，我们还需要使用比如Class.forName(“com.mysql.jdbc.Driver”)的方式来装载驱动。<br><br>如上图所示：<br>JDBC也基于spi的机制来发现驱动提供商了，可以通过<code>META-INF/services/java.sql.Driver</code>文件里指定实现类的方式来暴露驱动提供者。<br><br>其中，<code>META-INF/services/</code>是固定的，<code>java.sql.Driver</code>为接口对应的<code>package</code>，文件中为具体的实现类。</p>\n</blockquote>\n<h1 id=\"SPI如何被框架发现呢？\"><a href=\"#SPI如何被框架发现呢？\" class=\"headerlink\" title=\"SPI如何被框架发现呢？\"></a>SPI如何被框架发现呢？</h1><blockquote>\n<p>框架可以使用java提供的java.util.ServiceLoader类得到SPI的实现。我们来看下java.sql.DriverManager中是如何去发现的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadInitialDrivers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    AccessController.doPrivileged(<span class=\"keyword\">new</span> <span class=\"title class_\">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Void <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取具体的实现类</span></span><br><span class=\"line\">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class=\"line\">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(driversIterator.hasNext()) &#123;</span><br><span class=\"line\">                    driversIterator.next();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(Throwable t) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Do nothing</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String aDriver : driversList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            println(<span class=\"string\">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class=\"line\">            Class.forName(aDriver, <span class=\"literal\">true</span>,</span><br><span class=\"line\">                    ClassLoader.getSystemClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用<code>ServiceLoader&lt;XXX&gt; loadedDrivers = ServiceLoader.load(XXX.class);</code>，实际上就是到具体的路径下读取文件内容。</p>\n</blockquote>\n<h1 id=\"SPI应用\"><a href=\"#SPI应用\" class=\"headerlink\" title=\"SPI应用\"></a>SPI应用</h1><p>用过阿里<code>Dubbo</code>的开发者都知道，Dubbo对JDK中SPI进行了扩展和改进，这个在以后dubbo相关的文章中再进行介绍~</p>\n<blockquote>\n<p>好了，本期就讲到这里，下期我们讲讲Java9中到另一个新工具<code>JShell</code>，敬请期待～</p>\n</blockquote>"},{"title":"Java9新特性系列（Java9新特性系列（Stream改进））","date":"2018-02-27T14:22:32.000Z","_content":"# Java8的Stream\n\n在Java8中，一个比较大的变化就是流（Stream），具体可以看之前的一篇文章：[Java8新特性系列（Stream）](http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/)\n\n<!--more-->\n\n# Java9的Stream\n\nJava9中Stream增加了4个方法，分别是：\n\n+ `takeWhile`：在有序的Stream中，takeWhile返回从开头开始的尽量多的元素\n\n```java\ndefault Stream<T> takeWhile(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate);\n    // Reuses the unordered spliterator, which, when encounter is present,\n    // is safe to use as long as it configured not to split\n    return StreamSupport.stream(\n        new WhileOps.UnorderedWhileSpliterator.OfRef.Taking<>(spliterator(), true, predicate),\n            isParallel()).onClose(this::close);\n}\n```\n\n+ `dropWhile`：与`takeWhile`相反\n\n```java\ndefault Stream<T> dropWhile(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate);\n    // Reuses the unordered spliterator, which, when encounter is present,\n    // is safe to use as long as it configured not to split\n    return StreamSupport.stream(\n        new WhileOps.UnorderedWhileSpliterator.OfRef.Dropping<>(spliterator(), true, predicate),\n            isParallel()).onClose(this::close);\n}\n```\n\n+ ofNullable：可以创建一个单元素Stream，可以为null\n\n```java\npublic static<T> Stream<T> ofNullable(T t) {\n    return t == null ? Stream.empty()\n         : StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n```\n\n+ iterate\n\n```java\npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n    Objects.requireNonNull(f);\n    Spliterator<T> spliterator = new Spliterators.AbstractSpliterator<>(Long.MAX_VALUE,\n    Spliterator.ORDERED | Spliterator.IMMUTABLE) {\n        T prev;\n        boolean started;\n\n        @Override\n        public boolean tryAdvance(Consumer<? super T> action) {\n            Objects.requireNonNull(action);\n            T t;\n            if (started)\n                t = f.apply(prev);\n            else {\n                t = seed;\n                started = true;\n            }\n            action.accept(prev = t);\n            return true;\n        }\n    };\n    return StreamSupport.stream(spliterator, false);\n}\n```\n\n除了对 Stream 本身的扩展，Optional和Stream之间的结合也得到了改进，可以将optional对象转化为stream对象：\n\n```java\nList<String> list = new ArrayList<>() {{\n    add(\"a\");add(\"b\");add(\"c\");\n}};\nOptional<List<String>> optional = Optional.ofNullable(list);\nStream<List<String>> stream = optional.stream();\nstream.flatMap(x -> x.stream()).forEach(System.out::println);\n```\n\n# 使用举例\n\n+ takeWhile\n\n```java\nList<Integer> list = Arrays.asList(1, 4, 5, 2, 3, 6, 7, 8, 9, 10);\nlist.stream().takeWhile(x -> x < 5).forEach(System.out::println);\n```\n>输出：<br>1<br>4\n\n+ dropWhile\n\n```java\nList<Integer> list = Arrays.asList(1, 4, 5, 2, 3, 6, 7, 8, 9, 10);\nlist.stream().dropWhile(x -> x < 5).forEach(System.out::println);\n```\n>输出：<br>5<br>2<br>3<br>6<br>7<br>8<br>9<br>10\n\n+ ofNullable\n\n```java\nStream<String> stream = Stream.of(\"\", null);\nSystem.out.println(stream.count());\n\nStream<String> stream = Stream.of(null);\nSystem.out.println(stream.count());//会抛空指针异常\n\nStream<String> stream = Stream.ofNullable(null);\nSystem.out.println(stream.count());\n```\n>输出：<br>2<br>0\n\n+ iterate\n\n```java\n//java8\nStream.iterate(1, i -> i + 1).limit(5).forEach(System.out::println);\n\n//java9\nStream.iterate(1, i -> i < 6, i -> i + 1).forEach(System.out::println);\n```\n>输出：<br>1<br>2<br>3<br>4<br>5","source":"_posts/java9-stream.md","raw":"title: Java9新特性系列（Java9新特性系列（Stream改进））\ndate: 2018-02-27 22:22:32\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java8的Stream\n\n在Java8中，一个比较大的变化就是流（Stream），具体可以看之前的一篇文章：[Java8新特性系列（Stream）](http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/)\n\n<!--more-->\n\n# Java9的Stream\n\nJava9中Stream增加了4个方法，分别是：\n\n+ `takeWhile`：在有序的Stream中，takeWhile返回从开头开始的尽量多的元素\n\n```java\ndefault Stream<T> takeWhile(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate);\n    // Reuses the unordered spliterator, which, when encounter is present,\n    // is safe to use as long as it configured not to split\n    return StreamSupport.stream(\n        new WhileOps.UnorderedWhileSpliterator.OfRef.Taking<>(spliterator(), true, predicate),\n            isParallel()).onClose(this::close);\n}\n```\n\n+ `dropWhile`：与`takeWhile`相反\n\n```java\ndefault Stream<T> dropWhile(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate);\n    // Reuses the unordered spliterator, which, when encounter is present,\n    // is safe to use as long as it configured not to split\n    return StreamSupport.stream(\n        new WhileOps.UnorderedWhileSpliterator.OfRef.Dropping<>(spliterator(), true, predicate),\n            isParallel()).onClose(this::close);\n}\n```\n\n+ ofNullable：可以创建一个单元素Stream，可以为null\n\n```java\npublic static<T> Stream<T> ofNullable(T t) {\n    return t == null ? Stream.empty()\n         : StreamSupport.stream(new Streams.StreamBuilderImpl<>(t), false);\n}\n```\n\n+ iterate\n\n```java\npublic static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f) {\n    Objects.requireNonNull(f);\n    Spliterator<T> spliterator = new Spliterators.AbstractSpliterator<>(Long.MAX_VALUE,\n    Spliterator.ORDERED | Spliterator.IMMUTABLE) {\n        T prev;\n        boolean started;\n\n        @Override\n        public boolean tryAdvance(Consumer<? super T> action) {\n            Objects.requireNonNull(action);\n            T t;\n            if (started)\n                t = f.apply(prev);\n            else {\n                t = seed;\n                started = true;\n            }\n            action.accept(prev = t);\n            return true;\n        }\n    };\n    return StreamSupport.stream(spliterator, false);\n}\n```\n\n除了对 Stream 本身的扩展，Optional和Stream之间的结合也得到了改进，可以将optional对象转化为stream对象：\n\n```java\nList<String> list = new ArrayList<>() {{\n    add(\"a\");add(\"b\");add(\"c\");\n}};\nOptional<List<String>> optional = Optional.ofNullable(list);\nStream<List<String>> stream = optional.stream();\nstream.flatMap(x -> x.stream()).forEach(System.out::println);\n```\n\n# 使用举例\n\n+ takeWhile\n\n```java\nList<Integer> list = Arrays.asList(1, 4, 5, 2, 3, 6, 7, 8, 9, 10);\nlist.stream().takeWhile(x -> x < 5).forEach(System.out::println);\n```\n>输出：<br>1<br>4\n\n+ dropWhile\n\n```java\nList<Integer> list = Arrays.asList(1, 4, 5, 2, 3, 6, 7, 8, 9, 10);\nlist.stream().dropWhile(x -> x < 5).forEach(System.out::println);\n```\n>输出：<br>5<br>2<br>3<br>6<br>7<br>8<br>9<br>10\n\n+ ofNullable\n\n```java\nStream<String> stream = Stream.of(\"\", null);\nSystem.out.println(stream.count());\n\nStream<String> stream = Stream.of(null);\nSystem.out.println(stream.count());//会抛空指针异常\n\nStream<String> stream = Stream.ofNullable(null);\nSystem.out.println(stream.count());\n```\n>输出：<br>2<br>0\n\n+ iterate\n\n```java\n//java8\nStream.iterate(1, i -> i + 1).limit(5).forEach(System.out::println);\n\n//java9\nStream.iterate(1, i -> i < 6, i -> i + 1).forEach(System.out::println);\n```\n>输出：<br>1<br>2<br>3<br>4<br>5","slug":"java9-stream","published":1,"updated":"2025-03-07T13:26:47.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2p002arz5mcr5g4usg","content":"<h1 id=\"Java8的Stream\"><a href=\"#Java8的Stream\" class=\"headerlink\" title=\"Java8的Stream\"></a>Java8的Stream</h1><p>在Java8中，一个比较大的变化就是流（Stream），具体可以看之前的一篇文章：<a href=\"http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/\">Java8新特性系列（Stream）</a></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9的Stream\"><a href=\"#Java9的Stream\" class=\"headerlink\" title=\"Java9的Stream\"></a>Java9的Stream</h1><p>Java9中Stream增加了4个方法，分别是：</p>\n<ul>\n<li><code>takeWhile</code>：在有序的Stream中，takeWhile返回从开头开始的尽量多的元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;T&gt; <span class=\"title function_\">takeWhile</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"comment\">// Reuses the unordered spliterator, which, when encounter is present,</span></span><br><span class=\"line\">    <span class=\"comment\">// is safe to use as long as it configured not to split</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">WhileOps</span>.UnorderedWhileSpliterator.OfRef.Taking&lt;&gt;(spliterator(), <span class=\"literal\">true</span>, predicate),</span><br><span class=\"line\">            isParallel()).onClose(<span class=\"built_in\">this</span>::close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>dropWhile</code>：与<code>takeWhile</code>相反</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;T&gt; <span class=\"title function_\">dropWhile</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"comment\">// Reuses the unordered spliterator, which, when encounter is present,</span></span><br><span class=\"line\">    <span class=\"comment\">// is safe to use as long as it configured not to split</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">WhileOps</span>.UnorderedWhileSpliterator.OfRef.Dropping&lt;&gt;(spliterator(), <span class=\"literal\">true</span>, predicate),</span><br><span class=\"line\">            isParallel()).onClose(<span class=\"built_in\">this</span>::close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ofNullable：可以创建一个单元素Stream，可以为null</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">ofNullable</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t == <span class=\"literal\">null</span> ? Stream.empty()</span><br><span class=\"line\">         : StreamSupport.stream(<span class=\"keyword\">new</span> <span class=\"title class_\">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>iterate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">iterate</span><span class=\"params\">(<span class=\"keyword\">final</span> T seed, <span class=\"keyword\">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(f);</span><br><span class=\"line\">    Spliterator&lt;T&gt; spliterator = <span class=\"keyword\">new</span> <span class=\"title class_\">Spliterators</span>.AbstractSpliterator&lt;&gt;(Long.MAX_VALUE,</span><br><span class=\"line\">    Spliterator.ORDERED | Spliterator.IMMUTABLE) &#123;</span><br><span class=\"line\">        T prev;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> started;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAdvance</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">            Objects.requireNonNull(action);</span><br><span class=\"line\">            T t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (started)</span><br><span class=\"line\">                t = f.apply(prev);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                t = seed;</span><br><span class=\"line\">                started = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            action.accept(prev = t);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了对 Stream 本身的扩展，Optional和Stream之间的结合也得到了改进，可以将optional对象转化为stream对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>);add(<span class=\"string\">&quot;b&quot;</span>);add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;;</span><br><span class=\"line\">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class=\"line\">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class=\"line\">stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><ul>\n<li>takeWhile</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">list.stream().takeWhile(x -&gt; x &lt; <span class=\"number\">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>1<br>4</p>\n</blockquote>\n<ul>\n<li>dropWhile</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">list.stream().dropWhile(x -&gt; x &lt; <span class=\"number\">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>5<br>2<br>3<br>6<br>7<br>8<br>9<br>10</p>\n</blockquote>\n<ul>\n<li>ofNullable</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());<span class=\"comment\">//会抛空指针异常</span></span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.ofNullable(<span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>2<br>0</p>\n</blockquote>\n<ul>\n<li>iterate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java8</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">1</span>, i -&gt; i + <span class=\"number\">1</span>).limit(<span class=\"number\">5</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//java9</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">1</span>, i -&gt; i &lt; <span class=\"number\">6</span>, i -&gt; i + <span class=\"number\">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>1<br>2<br>3<br>4<br>5</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java8的Stream\"><a href=\"#Java8的Stream\" class=\"headerlink\" title=\"Java8的Stream\"></a>Java8的Stream</h1><p>在Java8中，一个比较大的变化就是流（Stream），具体可以看之前的一篇文章：<a href=\"http://hellomypastor.net/2017/12/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88Stream%EF%BC%89/\">Java8新特性系列（Stream）</a></p>","more":"<h1 id=\"Java9的Stream\"><a href=\"#Java9的Stream\" class=\"headerlink\" title=\"Java9的Stream\"></a>Java9的Stream</h1><p>Java9中Stream增加了4个方法，分别是：</p>\n<ul>\n<li><code>takeWhile</code>：在有序的Stream中，takeWhile返回从开头开始的尽量多的元素</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;T&gt; <span class=\"title function_\">takeWhile</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"comment\">// Reuses the unordered spliterator, which, when encounter is present,</span></span><br><span class=\"line\">    <span class=\"comment\">// is safe to use as long as it configured not to split</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">WhileOps</span>.UnorderedWhileSpliterator.OfRef.Taking&lt;&gt;(spliterator(), <span class=\"literal\">true</span>, predicate),</span><br><span class=\"line\">            isParallel()).onClose(<span class=\"built_in\">this</span>::close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>dropWhile</code>：与<code>takeWhile</code>相反</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> Stream&lt;T&gt; <span class=\"title function_\">dropWhile</span><span class=\"params\">(Predicate&lt;? <span class=\"built_in\">super</span> T&gt; predicate)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(predicate);</span><br><span class=\"line\">    <span class=\"comment\">// Reuses the unordered spliterator, which, when encounter is present,</span></span><br><span class=\"line\">    <span class=\"comment\">// is safe to use as long as it configured not to split</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">WhileOps</span>.UnorderedWhileSpliterator.OfRef.Dropping&lt;&gt;(spliterator(), <span class=\"literal\">true</span>, predicate),</span><br><span class=\"line\">            isParallel()).onClose(<span class=\"built_in\">this</span>::close);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ofNullable：可以创建一个单元素Stream，可以为null</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">ofNullable</span><span class=\"params\">(T t)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t == <span class=\"literal\">null</span> ? Stream.empty()</span><br><span class=\"line\">         : StreamSupport.stream(<span class=\"keyword\">new</span> <span class=\"title class_\">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>iterate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span>&lt;T&gt; Stream&lt;T&gt; <span class=\"title function_\">iterate</span><span class=\"params\">(<span class=\"keyword\">final</span> T seed, <span class=\"keyword\">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class=\"line\">    Objects.requireNonNull(f);</span><br><span class=\"line\">    Spliterator&lt;T&gt; spliterator = <span class=\"keyword\">new</span> <span class=\"title class_\">Spliterators</span>.AbstractSpliterator&lt;&gt;(Long.MAX_VALUE,</span><br><span class=\"line\">    Spliterator.ORDERED | Spliterator.IMMUTABLE) &#123;</span><br><span class=\"line\">        T prev;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> started;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAdvance</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span> &#123;</span><br><span class=\"line\">            Objects.requireNonNull(action);</span><br><span class=\"line\">            T t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (started)</span><br><span class=\"line\">                t = f.apply(prev);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                t = seed;</span><br><span class=\"line\">                started = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            action.accept(prev = t);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> StreamSupport.stream(spliterator, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了对 Stream 本身的扩展，Optional和Stream之间的结合也得到了改进，可以将optional对象转化为stream对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class=\"line\">    add(<span class=\"string\">&quot;a&quot;</span>);add(<span class=\"string\">&quot;b&quot;</span>);add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">&#125;&#125;;</span><br><span class=\"line\">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class=\"line\">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class=\"line\">stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><ul>\n<li>takeWhile</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">list.stream().takeWhile(x -&gt; x &lt; <span class=\"number\">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>1<br>4</p>\n</blockquote>\n<ul>\n<li>dropWhile</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">list.stream().dropWhile(x -&gt; x &lt; <span class=\"number\">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>5<br>2<br>3<br>6<br>7<br>8<br>9<br>10</p>\n</blockquote>\n<ul>\n<li>ofNullable</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());<span class=\"comment\">//会抛空指针异常</span></span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.ofNullable(<span class=\"literal\">null</span>);</span><br><span class=\"line\">System.out.println(stream.count());</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>2<br>0</p>\n</blockquote>\n<ul>\n<li>iterate</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java8</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">1</span>, i -&gt; i + <span class=\"number\">1</span>).limit(<span class=\"number\">5</span>).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//java9</span></span><br><span class=\"line\">Stream.iterate(<span class=\"number\">1</span>, i -&gt; i &lt; <span class=\"number\">6</span>, i -&gt; i + <span class=\"number\">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>输出：<br>1<br>2<br>3<br>4<br>5</p>\n</blockquote>"},{"title":"Java9新特性系列（try-with-resources改进）","date":"2018-02-22T14:13:56.000Z","_content":"# Java7前时代的try\n>在Java7版本以前，try的使用方法如下（流等资源的关闭在finally中进行，否则会导致资源泄漏）：\n\n```java\npublic static void main(String[] args) {\n    InputStreamReader reader = null;\n    try {\n        reader = new InputStreamReader(System.in);\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (reader != null) {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n# Java7\nJava7中，可以实现资源的自动关闭，但前提是资源必须要在try的子语句中进行初始化，否则编译会报错：\n\n```java\npublic static void main(String[] args) {\n    try (InputStreamReader reader = new InputStreamReader(System.in)) {\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\nJava7中出了try作了改进，catch也同样作了改进：\n+ Java7之前\n\n```java\ntry {\n    //逻辑代码\n    ...\n} catch (IOException ex) {\n    logger.log(ex);\n} catch (SQLException ex) {\n    logger.log(ex);\n}\n...\n```\n\n+ Java7及Java7以上\n\n```java\ntry {\n    //逻辑代码\n    ...\n} catch (IOException | SQLException ex) {\n    logger.log(ex);\n}\n...\n```\n>catch子语句中ex默认是final的，在catch语句块中不能改变ex，否则会编译报错。\n\n<!--more-->\n\n# Java9\nJava9中try更加灵活强大，支持在try子语句外部定义resource，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>Allow effectively-final variables to be used as resources in the try-with-resources statement. The final version of try-with-resources statement in Java SE 7 requires a fresh variable to be declared for each resource being managed by the statement. This was a change from earlier iterations of the feature. The public review draft of JSR 334 discusses the rationale for the change from the early draft review version of try-with-resource which allowed an expression managed by the statement. **The JSR 334 expert group was in favor of an additional refinement of try-with-resources: if the resource is referenced by a final or effectively final variable, a try-with-resources statement can manage the resource without a new variable being declared.** This restricted expression being managed by a try-with-resources statement avoids the semantic issues which motivated removing general expression support. At the time the expert group settled on this refinement, there was insufficient time in the release schedule to accommodate the change.\n\n```java\npublic static void main(String[] args) {\n    InputStreamReader reader = new InputStreamReader(System.in);\n    try (reader) {\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n>如果放在try子语句中，那么reader默认是final的，不可以重新赋值，如果重新赋值，那么编译会报错：`Variable used as a try-with-resource resource should be final or effectively final.`","source":"_posts/java9-try-with-resources.md","raw":"title: Java9新特性系列（try-with-resources改进）\ndate: 2018-02-22 22:13:56\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java7前时代的try\n>在Java7版本以前，try的使用方法如下（流等资源的关闭在finally中进行，否则会导致资源泄漏）：\n\n```java\npublic static void main(String[] args) {\n    InputStreamReader reader = null;\n    try {\n        reader = new InputStreamReader(System.in);\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        if (reader != null) {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n# Java7\nJava7中，可以实现资源的自动关闭，但前提是资源必须要在try的子语句中进行初始化，否则编译会报错：\n\n```java\npublic static void main(String[] args) {\n    try (InputStreamReader reader = new InputStreamReader(System.in)) {\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\nJava7中出了try作了改进，catch也同样作了改进：\n+ Java7之前\n\n```java\ntry {\n    //逻辑代码\n    ...\n} catch (IOException ex) {\n    logger.log(ex);\n} catch (SQLException ex) {\n    logger.log(ex);\n}\n...\n```\n\n+ Java7及Java7以上\n\n```java\ntry {\n    //逻辑代码\n    ...\n} catch (IOException | SQLException ex) {\n    logger.log(ex);\n}\n...\n```\n>catch子语句中ex默认是final的，在catch语句块中不能改变ex，否则会编译报错。\n\n<!--more-->\n\n# Java9\nJava9中try更加灵活强大，支持在try子语句外部定义resource，[官方Feature](http://openjdk.java.net/jeps/213)给出了如下说明：\n>Allow effectively-final variables to be used as resources in the try-with-resources statement. The final version of try-with-resources statement in Java SE 7 requires a fresh variable to be declared for each resource being managed by the statement. This was a change from earlier iterations of the feature. The public review draft of JSR 334 discusses the rationale for the change from the early draft review version of try-with-resource which allowed an expression managed by the statement. **The JSR 334 expert group was in favor of an additional refinement of try-with-resources: if the resource is referenced by a final or effectively final variable, a try-with-resources statement can manage the resource without a new variable being declared.** This restricted expression being managed by a try-with-resources statement avoids the semantic issues which motivated removing general expression support. At the time the expert group settled on this refinement, there was insufficient time in the release schedule to accommodate the change.\n\n```java\npublic static void main(String[] args) {\n    InputStreamReader reader = new InputStreamReader(System.in);\n    try (reader) {\n        ...\n        reader.read();\n        ...\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n>如果放在try子语句中，那么reader默认是final的，不可以重新赋值，如果重新赋值，那么编译会报错：`Variable used as a try-with-resource resource should be final or effectively final.`","slug":"java9-try-with-resources","published":1,"updated":"2025-03-07T13:26:47.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2q002erz5mccdg0b4s","content":"<h1 id=\"Java7前时代的try\"><a href=\"#Java7前时代的try\" class=\"headerlink\" title=\"Java7前时代的try\"></a>Java7前时代的try</h1><blockquote>\n<p>在Java7版本以前，try的使用方法如下（流等资源的关闭在finally中进行，否则会导致资源泄漏）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        reader = <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reader != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                reader.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java7\"><a href=\"#Java7\" class=\"headerlink\" title=\"Java7\"></a>Java7</h1><p>Java7中，可以实现资源的自动关闭，但前提是资源必须要在try的子语句中进行初始化，否则编译会报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (<span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java7中出了try作了改进，catch也同样作了改进：</p>\n<ul>\n<li>Java7之前</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//逻辑代码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SQLException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java7及Java7以上</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//逻辑代码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException | SQLException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>catch子语句中ex默认是final的，在catch语句块中不能改变ex，否则会编译报错。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中try更加灵活强大，支持在try子语句外部定义resource，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p>Allow effectively-final variables to be used as resources in the try-with-resources statement. The final version of try-with-resources statement in Java SE 7 requires a fresh variable to be declared for each resource being managed by the statement. This was a change from earlier iterations of the feature. The public review draft of JSR 334 discusses the rationale for the change from the early draft review version of try-with-resource which allowed an expression managed by the statement. <strong>The JSR 334 expert group was in favor of an additional refinement of try-with-resources: if the resource is referenced by a final or effectively final variable, a try-with-resources statement can manage the resource without a new variable being declared.</strong> This restricted expression being managed by a try-with-resources statement avoids the semantic issues which motivated removing general expression support. At the time the expert group settled on this refinement, there was insufficient time in the release schedule to accommodate the change.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (reader) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果放在try子语句中，那么reader默认是final的，不可以重新赋值，如果重新赋值，那么编译会报错：<code>Variable used as a try-with-resource resource should be final or effectively final.</code></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java7前时代的try\"><a href=\"#Java7前时代的try\" class=\"headerlink\" title=\"Java7前时代的try\"></a>Java7前时代的try</h1><blockquote>\n<p>在Java7版本以前，try的使用方法如下（流等资源的关闭在finally中进行，否则会导致资源泄漏）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        reader = <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reader != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                reader.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java7\"><a href=\"#Java7\" class=\"headerlink\" title=\"Java7\"></a>Java7</h1><p>Java7中，可以实现资源的自动关闭，但前提是资源必须要在try的子语句中进行初始化，否则编译会报错：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (<span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in)) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java7中出了try作了改进，catch也同样作了改进：</p>\n<ul>\n<li>Java7之前</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//逻辑代码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SQLException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java7及Java7以上</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//逻辑代码</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException | SQLException ex) &#123;</span><br><span class=\"line\">    logger.log(ex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>catch子语句中ex默认是final的，在catch语句块中不能改变ex，否则会编译报错。</p>\n</blockquote>","more":"<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p>Java9中try更加灵活强大，支持在try子语句外部定义resource，<a href=\"http://openjdk.java.net/jeps/213\">官方Feature</a>给出了如下说明：</p>\n<blockquote>\n<p>Allow effectively-final variables to be used as resources in the try-with-resources statement. The final version of try-with-resources statement in Java SE 7 requires a fresh variable to be declared for each resource being managed by the statement. This was a change from earlier iterations of the feature. The public review draft of JSR 334 discusses the rationale for the change from the early draft review version of try-with-resource which allowed an expression managed by the statement. <strong>The JSR 334 expert group was in favor of an additional refinement of try-with-resources: if the resource is referenced by a final or effectively final variable, a try-with-resources statement can manage the resource without a new variable being declared.</strong> This restricted expression being managed by a try-with-resources statement avoids the semantic issues which motivated removing general expression support. At the time the expert group settled on this refinement, there was insufficient time in the release schedule to accommodate the change.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">InputStreamReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (reader) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        reader.read();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果放在try子语句中，那么reader默认是final的，不可以重新赋值，如果重新赋值，那么编译会报错：<code>Variable used as a try-with-resource resource should be final or effectively final.</code></p>\n</blockquote>"},{"title":"Java9新特性系列（String改进）","date":"2018-02-24T14:18:01.000Z","_content":"# Java9前时代\n\n在Java9之前，String的源码如下：\n\n```java\npackage java.lang;\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n    ...\n}\n```\n可以看到，String的内部是一个char数组，每个字符占2个字节（16位）。\n\n<!--more-->\n\n# Java9\n\n[官方Feature](http://openjdk.java.net/jeps/254)给出了如下说明：\n+ 产生背景：\n\n>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.\n\n大量数据表明，String对象占用了主要的堆使用，而且，大部分的字符串对象只包含Latin-1字符，这样的字符只需要一个字节的存储空间，因此此类字符串对象的内部char数组中的一半空间将被闲置。所以，Java9中对String对存储结构进行了改进：\n\n+ 描述：\n\n>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\n\nString改成了byte数组，再加上编码标记，就节约了不少空间。\n\nJava9中String源码如下：\n```java\npackage java.lang;\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n    ...\n}\n```\n\n>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.\n\n与String相关对比如`AbstractStringBuilder`、`StringBuilder`、`StringBuffer`也将有相同的实现，不知道在3月份即将发布的Java10中实现呢，期待～","source":"_posts/java9-string.md","raw":"title: Java9新特性系列（String改进）\ndate: 2018-02-24 22:18:01\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java9前时代\n\n在Java9之前，String的源码如下：\n\n```java\npackage java.lang;\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n    ...\n}\n```\n可以看到，String的内部是一个char数组，每个字符占2个字节（16位）。\n\n<!--more-->\n\n# Java9\n\n[官方Feature](http://openjdk.java.net/jeps/254)给出了如下说明：\n+ 产生背景：\n\n>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.\n\n大量数据表明，String对象占用了主要的堆使用，而且，大部分的字符串对象只包含Latin-1字符，这样的字符只需要一个字节的存储空间，因此此类字符串对象的内部char数组中的一半空间将被闲置。所以，Java9中对String对存储结构进行了改进：\n\n+ 描述：\n\n>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.\n\nString改成了byte数组，再加上编码标记，就节约了不少空间。\n\nJava9中String源码如下：\n```java\npackage java.lang;\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n    ...\n}\n```\n\n>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM's intrinsic string operations.\n\n与String相关对比如`AbstractStringBuilder`、`StringBuilder`、`StringBuffer`也将有相同的实现，不知道在3月份即将发布的Java10中实现呢，期待～","slug":"java9-string","published":1,"updated":"2025-03-07T13:26:47.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2q002hrz5md7l79wp7","content":"<h1 id=\"Java9前时代\"><a href=\"#Java9前时代\" class=\"headerlink\" title=\"Java9前时代\"></a>Java9前时代</h1><p>在Java9之前，String的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span> value[];</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，String的内部是一个char数组，每个字符占2个字节（16位）。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p><a href=\"http://openjdk.java.net/jeps/254\">官方Feature</a>给出了如下说明：</p>\n<ul>\n<li>产生背景：</li>\n</ul>\n<blockquote>\n<p>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p>\n</blockquote>\n<p>大量数据表明，String对象占用了主要的堆使用，而且，大部分的字符串对象只包含Latin-1字符，这样的字符只需要一个字节的存储空间，因此此类字符串对象的内部char数组中的一半空间将被闲置。所以，Java9中对String对存储结构进行了改进：</p>\n<ul>\n<li>描述：</li>\n</ul>\n<blockquote>\n<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>\n</blockquote>\n<p>String改成了byte数组，再加上编码标记，就节约了不少空间。</p>\n<p>Java9中String源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value is used for character storage.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@implNote</span> This field is trusted by the VM, and is a subject to</span></span><br><span class=\"line\"><span class=\"comment\">     * constant folding if String instance is constant. Overwriting this</span></span><br><span class=\"line\"><span class=\"comment\">     * field after construction will cause problems.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Additionally, it is marked with &#123;<span class=\"doctag\">@link</span> Stable&#125; to trust the contents</span></span><br><span class=\"line\"><span class=\"comment\">     * of the array. No other facility in JDK provides this functionality (yet).</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> Stable&#125; is safe here, because value is never null.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Stable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">byte</span>[] value;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>\n</blockquote>\n<p>与String相关对比如<code>AbstractStringBuilder</code>、<code>StringBuilder</code>、<code>StringBuffer</code>也将有相同的实现，不知道在3月份即将发布的Java10中实现呢，期待～</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java9前时代\"><a href=\"#Java9前时代\" class=\"headerlink\" title=\"Java9前时代\"></a>Java9前时代</h1><p>在Java9之前，String的源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value is used for character storage. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span> value[];</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，String的内部是一个char数组，每个字符占2个字节（16位）。</p>","more":"<h1 id=\"Java9\"><a href=\"#Java9\" class=\"headerlink\" title=\"Java9\"></a>Java9</h1><p><a href=\"http://openjdk.java.net/jeps/254\">官方Feature</a>给出了如下说明：</p>\n<ul>\n<li>产生背景：</li>\n</ul>\n<blockquote>\n<p>The current implementation of the String class stores characters in a char array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.</p>\n</blockquote>\n<p>大量数据表明，String对象占用了主要的堆使用，而且，大部分的字符串对象只包含Latin-1字符，这样的字符只需要一个字节的存储空间，因此此类字符串对象的内部char数组中的一半空间将被闲置。所以，Java9中对String对存储结构进行了改进：</p>\n<ul>\n<li>描述：</li>\n</ul>\n<blockquote>\n<p>We propose to change the internal representation of the String class from a UTF-16 char array to a byte array plus an encoding-flag field. The new String class will store characters encoded either as ISO-8859-1&#x2F;Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>\n</blockquote>\n<p>String改成了byte数组，再加上编码标记，就节约了不少空间。</p>\n<p>Java9中String源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.lang;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The value is used for character storage.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@implNote</span> This field is trusted by the VM, and is a subject to</span></span><br><span class=\"line\"><span class=\"comment\">     * constant folding if String instance is constant. Overwriting this</span></span><br><span class=\"line\"><span class=\"comment\">     * field after construction will cause problems.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Additionally, it is marked with &#123;<span class=\"doctag\">@link</span> Stable&#125; to trust the contents</span></span><br><span class=\"line\"><span class=\"comment\">     * of the array. No other facility in JDK provides this functionality (yet).</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> Stable&#125; is safe here, because value is never null.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Stable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">byte</span>[] value;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>\n</blockquote>\n<p>与String相关对比如<code>AbstractStringBuilder</code>、<code>StringBuilder</code>、<code>StringBuffer</code>也将有相同的实现，不知道在3月份即将发布的Java10中实现呢，期待～</p>"},{"title":"Java9新特性系列（序）","date":"2018-01-29T15:31:46.000Z","_content":"# Java9的发布\n>经过4次跳票，历经曲折的java 9 终于终于在2017年9月21日发布。\n\n<!--more-->\n# Java 9 中哪些不得不说的新特性?\n\n> Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的REPL工具：jshell，JDK编译工具，Java公共API和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java9是一个庞大的系统工程，完全做了一个整体改变。\n\n具体来讲:\n+ 多版本兼容jar包\n+ 模块化系统\n+ JShell命令\n+ 接口的私有方法\n+ 钻石操作符的使用升级\n+ 语法改进：try语句\n+ 下划线使用限制\n+ String存储结构变更\n+ 便利的集合特性：of()\n+ 增强的Stream API\n+ 多分辨率图像API\n+ 全新的HTTP客户端API\n+ Deprecated的相关API\n+ 智能Java编译工具\n+ 统一的JVM日志系统\n+ Javadoc的HTML 5支持\n+ Javascript引擎升级：Nashorn\n+ Java的动态编译器\n\n# Java语言后续版本的更迭\n>从Java 9这个版本开始，Java 的计划发布周期是 6 个月，下一个Java的主版本将于2018年3月发布，命名为Java18.3，紧接着再过六个月将发布Java18.9。\n\n这意味着java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的(6个月为周期)发布模式，并逐步的将Oracle JDK原商业特性进行开源。\n\n针对企业客户的需求，Oracle将以三年为周期发布长期支持版本(long term support)。\n\n# 如何看待Java9的更新\nJava更快的发布周期意味着开发者将不需要像以前一样为主要发布版本望眼欲穿。这也意味着开发者将可能跳过Java9和它的不成熟的模块化功能，只需要再等待6个月就可以迎来新版本，这将可能解决开发者的纠结。\n\n>oracle理念与小步快跑，快速迭代。","source":"_posts/java9.md","raw":"title: Java9新特性系列（序）\ndate: 2018-01-29 23:31:46\ncategories: Java\ntags: [Java,Java9新特性]\n---\n# Java9的发布\n>经过4次跳票，历经曲折的java 9 终于终于在2017年9月21日发布。\n\n<!--more-->\n# Java 9 中哪些不得不说的新特性?\n\n> Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的REPL工具：jshell，JDK编译工具，Java公共API和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java9是一个庞大的系统工程，完全做了一个整体改变。\n\n具体来讲:\n+ 多版本兼容jar包\n+ 模块化系统\n+ JShell命令\n+ 接口的私有方法\n+ 钻石操作符的使用升级\n+ 语法改进：try语句\n+ 下划线使用限制\n+ String存储结构变更\n+ 便利的集合特性：of()\n+ 增强的Stream API\n+ 多分辨率图像API\n+ 全新的HTTP客户端API\n+ Deprecated的相关API\n+ 智能Java编译工具\n+ 统一的JVM日志系统\n+ Javadoc的HTML 5支持\n+ Javascript引擎升级：Nashorn\n+ Java的动态编译器\n\n# Java语言后续版本的更迭\n>从Java 9这个版本开始，Java 的计划发布周期是 6 个月，下一个Java的主版本将于2018年3月发布，命名为Java18.3，紧接着再过六个月将发布Java18.9。\n\n这意味着java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的(6个月为周期)发布模式，并逐步的将Oracle JDK原商业特性进行开源。\n\n针对企业客户的需求，Oracle将以三年为周期发布长期支持版本(long term support)。\n\n# 如何看待Java9的更新\nJava更快的发布周期意味着开发者将不需要像以前一样为主要发布版本望眼欲穿。这也意味着开发者将可能跳过Java9和它的不成熟的模块化功能，只需要再等待6个月就可以迎来新版本，这将可能解决开发者的纠结。\n\n>oracle理念与小步快跑，快速迭代。","slug":"java9","published":1,"updated":"2025-03-07T13:26:47.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2r002lrz5m2ekuhayq","content":"<h1 id=\"Java9的发布\"><a href=\"#Java9的发布\" class=\"headerlink\" title=\"Java9的发布\"></a>Java9的发布</h1><blockquote>\n<p>经过4次跳票，历经曲折的java 9 终于终于在2017年9月21日发布。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"Java-9-中哪些不得不说的新特性\"><a href=\"#Java-9-中哪些不得不说的新特性\" class=\"headerlink\" title=\"Java 9 中哪些不得不说的新特性?\"></a>Java 9 中哪些不得不说的新特性?</h1><blockquote>\n<p>Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的REPL工具：jshell，JDK编译工具，Java公共API和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java9是一个庞大的系统工程，完全做了一个整体改变。</p>\n</blockquote>\n<p>具体来讲:</p>\n<ul>\n<li>多版本兼容jar包</li>\n<li>模块化系统</li>\n<li>JShell命令</li>\n<li>接口的私有方法</li>\n<li>钻石操作符的使用升级</li>\n<li>语法改进：try语句</li>\n<li>下划线使用限制</li>\n<li>String存储结构变更</li>\n<li>便利的集合特性：of()</li>\n<li>增强的Stream API</li>\n<li>多分辨率图像API</li>\n<li>全新的HTTP客户端API</li>\n<li>Deprecated的相关API</li>\n<li>智能Java编译工具</li>\n<li>统一的JVM日志系统</li>\n<li>Javadoc的HTML 5支持</li>\n<li>Javascript引擎升级：Nashorn</li>\n<li>Java的动态编译器</li>\n</ul>\n<h1 id=\"Java语言后续版本的更迭\"><a href=\"#Java语言后续版本的更迭\" class=\"headerlink\" title=\"Java语言后续版本的更迭\"></a>Java语言后续版本的更迭</h1><blockquote>\n<p>从Java 9这个版本开始，Java 的计划发布周期是 6 个月，下一个Java的主版本将于2018年3月发布，命名为Java18.3，紧接着再过六个月将发布Java18.9。</p>\n</blockquote>\n<p>这意味着java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的(6个月为周期)发布模式，并逐步的将Oracle JDK原商业特性进行开源。</p>\n<p>针对企业客户的需求，Oracle将以三年为周期发布长期支持版本(long term support)。</p>\n<h1 id=\"如何看待Java9的更新\"><a href=\"#如何看待Java9的更新\" class=\"headerlink\" title=\"如何看待Java9的更新\"></a>如何看待Java9的更新</h1><p>Java更快的发布周期意味着开发者将不需要像以前一样为主要发布版本望眼欲穿。这也意味着开发者将可能跳过Java9和它的不成熟的模块化功能，只需要再等待6个月就可以迎来新版本，这将可能解决开发者的纠结。</p>\n<blockquote>\n<p>oracle理念与小步快跑，快速迭代。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Java9的发布\"><a href=\"#Java9的发布\" class=\"headerlink\" title=\"Java9的发布\"></a>Java9的发布</h1><blockquote>\n<p>经过4次跳票，历经曲折的java 9 终于终于在2017年9月21日发布。</p>\n</blockquote>","more":"<h1 id=\"Java-9-中哪些不得不说的新特性\"><a href=\"#Java-9-中哪些不得不说的新特性\" class=\"headerlink\" title=\"Java 9 中哪些不得不说的新特性?\"></a>Java 9 中哪些不得不说的新特性?</h1><blockquote>\n<p>Java9提供了超过150项新功能特性，包括备受期待的模块化系统、可交互的REPL工具：jshell，JDK编译工具，Java公共API和私有代码，以及安全增强、扩展提升、性能管理改善等。可以说Java9是一个庞大的系统工程，完全做了一个整体改变。</p>\n</blockquote>\n<p>具体来讲:</p>\n<ul>\n<li>多版本兼容jar包</li>\n<li>模块化系统</li>\n<li>JShell命令</li>\n<li>接口的私有方法</li>\n<li>钻石操作符的使用升级</li>\n<li>语法改进：try语句</li>\n<li>下划线使用限制</li>\n<li>String存储结构变更</li>\n<li>便利的集合特性：of()</li>\n<li>增强的Stream API</li>\n<li>多分辨率图像API</li>\n<li>全新的HTTP客户端API</li>\n<li>Deprecated的相关API</li>\n<li>智能Java编译工具</li>\n<li>统一的JVM日志系统</li>\n<li>Javadoc的HTML 5支持</li>\n<li>Javascript引擎升级：Nashorn</li>\n<li>Java的动态编译器</li>\n</ul>\n<h1 id=\"Java语言后续版本的更迭\"><a href=\"#Java语言后续版本的更迭\" class=\"headerlink\" title=\"Java语言后续版本的更迭\"></a>Java语言后续版本的更迭</h1><blockquote>\n<p>从Java 9这个版本开始，Java 的计划发布周期是 6 个月，下一个Java的主版本将于2018年3月发布，命名为Java18.3，紧接着再过六个月将发布Java18.9。</p>\n</blockquote>\n<p>这意味着java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的(6个月为周期)发布模式，并逐步的将Oracle JDK原商业特性进行开源。</p>\n<p>针对企业客户的需求，Oracle将以三年为周期发布长期支持版本(long term support)。</p>\n<h1 id=\"如何看待Java9的更新\"><a href=\"#如何看待Java9的更新\" class=\"headerlink\" title=\"如何看待Java9的更新\"></a>如何看待Java9的更新</h1><p>Java更快的发布周期意味着开发者将不需要像以前一样为主要发布版本望眼欲穿。这也意味着开发者将可能跳过Java9和它的不成熟的模块化功能，只需要再等待6个月就可以迎来新版本，这将可能解决开发者的纠结。</p>\n<blockquote>\n<p>oracle理念与小步快跑，快速迭代。</p>\n</blockquote>"},{"title":"JDK集合源码剖析（集合框架）","date":"2018-10-16T13:04:32.000Z","_content":"\b集合对于\b使用Java的人来说就好像是日常三餐一样，熟悉且必不可少。集合是Java中\b重要的知识点，虽然我们平时都用到\b它，但是我们真的了解什么场景下用什么集合类吗？哪些是有序的？哪些是无序的？哪些是线程安全的？哪些是线程不安全的？...本系列将从源码的角度来分析集合框架，知其然，同时知其所以然，下面开始我们的探索之旅～\n\nJava集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。\n\nJava集合类的整体框架如下：\n\n![](jdk-collection/jdk-collection.png)\n\n<!--more-->\n\n从上图中可以看出，集合类主要分为两大类：`Collection`和`Map`。\n\nCollection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。\n\n`List`接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为`ArrayList`和`LinkedList`，另外还有不常用的`Vector`。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。\n\n`Set`接口通常表示一个集合，其中的元素不允许重复（通过`hashcode`和`equals`函数保证），常用实现类有`HashSet`和`TreeSet`，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了`SortedSet`接口，因此是有序的集合（集合中的元素要实现`Comparable`接口，并覆写`Compartor`函数才行）。\n\n我们看到，抽象类`AbstractCollection`、`AbstractList`和`AbstractSet`分别实现了`Collection`、`List`和`Set`接口，这就是在Java集合框架中用的很多的`适配器设计模式`，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。\n\n`Map`是一个映射接口，其中的每个元素都是一个`key-value键值对`，同样抽象类`AbstractMap`通过适配器模式实现了Map接口中的大部分函数，`TreeMap`、`HashMap`、`WeakHashMap`等实现类都通过继承`AbstractMap`来实现，另外，不常用的`HashTable`直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。\n\n`Iterator`是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了`iterator()`函数，它返回一个Iterator对象，用来遍历集合，`ListIterator`则专门用来遍历List。而`Enumeration`则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。\n\n`Arrays`和`Collections`是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了`Arrays.Copyof()`方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选`Concurrent`并发包下的对应的集合类。\n\n说明：本文图片为作者自己重新画的，便于自己理解，其余转载自：[兰亭风雨](http://blog.csdn.net/ns_code/article/details/35564663)\n","source":"_posts/jdk-collection.md","raw":"title: JDK集合源码剖析（集合框架）\ndate: 2018-10-16 21:04:32\ncategories: JDK集合\ntags: [JDK集合]\n---\n\b集合对于\b使用Java的人来说就好像是日常三餐一样，熟悉且必不可少。集合是Java中\b重要的知识点，虽然我们平时都用到\b它，但是我们真的了解什么场景下用什么集合类吗？哪些是有序的？哪些是无序的？哪些是线程安全的？哪些是线程不安全的？...本系列将从源码的角度来分析集合框架，知其然，同时知其所以然，下面开始我们的探索之旅～\n\nJava集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。\n\nJava集合类的整体框架如下：\n\n![](jdk-collection/jdk-collection.png)\n\n<!--more-->\n\n从上图中可以看出，集合类主要分为两大类：`Collection`和`Map`。\n\nCollection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。\n\n`List`接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为`ArrayList`和`LinkedList`，另外还有不常用的`Vector`。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。\n\n`Set`接口通常表示一个集合，其中的元素不允许重复（通过`hashcode`和`equals`函数保证），常用实现类有`HashSet`和`TreeSet`，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了`SortedSet`接口，因此是有序的集合（集合中的元素要实现`Comparable`接口，并覆写`Compartor`函数才行）。\n\n我们看到，抽象类`AbstractCollection`、`AbstractList`和`AbstractSet`分别实现了`Collection`、`List`和`Set`接口，这就是在Java集合框架中用的很多的`适配器设计模式`，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。\n\n`Map`是一个映射接口，其中的每个元素都是一个`key-value键值对`，同样抽象类`AbstractMap`通过适配器模式实现了Map接口中的大部分函数，`TreeMap`、`HashMap`、`WeakHashMap`等实现类都通过继承`AbstractMap`来实现，另外，不常用的`HashTable`直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。\n\n`Iterator`是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了`iterator()`函数，它返回一个Iterator对象，用来遍历集合，`ListIterator`则专门用来遍历List。而`Enumeration`则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。\n\n`Arrays`和`Collections`是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了`Arrays.Copyof()`方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选`Concurrent`并发包下的对应的集合类。\n\n说明：本文图片为作者自己重新画的，便于自己理解，其余转载自：[兰亭风雨](http://blog.csdn.net/ns_code/article/details/35564663)\n","slug":"jdk-collection","published":1,"updated":"2025-03-07T13:26:47.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2r002orz5m5fwdg190","content":"<p>\b集合对于\b使用Java的人来说就好像是日常三餐一样，熟悉且必不可少。集合是Java中\b重要的知识点，虽然我们平时都用到\b它，但是我们真的了解什么场景下用什么集合类吗？哪些是有序的？哪些是无序的？哪些是线程安全的？哪些是线程不安全的？…本系列将从源码的角度来分析集合框架，知其然，同时知其所以然，下面开始我们的探索之旅～</p>\n<p>Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p>\n<p>Java集合类的整体框架如下：</p>\n<p><img src=\"/jdk-collection/jdk-collection.png\"></p>\n<span id=\"more\"></span>\n\n<p>从上图中可以看出，集合类主要分为两大类：<code>Collection</code>和<code>Map</code>。</p>\n<p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>\n<p><code>List</code>接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为<code>ArrayList</code>和<code>LinkedList</code>，另外还有不常用的<code>Vector</code>。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>\n<p><code>Set</code>接口通常表示一个集合，其中的元素不允许重复（通过<code>hashcode</code>和<code>equals</code>函数保证），常用实现类有<code>HashSet</code>和<code>TreeSet</code>，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了<code>SortedSet</code>接口，因此是有序的集合（集合中的元素要实现<code>Comparable</code>接口，并覆写<code>Compartor</code>函数才行）。</p>\n<p>我们看到，抽象类<code>AbstractCollection</code>、<code>AbstractList</code>和<code>AbstractSet</code>分别实现了<code>Collection</code>、<code>List</code>和<code>Set</code>接口，这就是在Java集合框架中用的很多的<code>适配器设计模式</code>，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>\n<p><code>Map</code>是一个映射接口，其中的每个元素都是一个<code>key-value键值对</code>，同样抽象类<code>AbstractMap</code>通过适配器模式实现了Map接口中的大部分函数，<code>TreeMap</code>、<code>HashMap</code>、<code>WeakHashMap</code>等实现类都通过继承<code>AbstractMap</code>来实现，另外，不常用的<code>HashTable</code>直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>\n<p><code>Iterator</code>是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了<code>iterator()</code>函数，它返回一个Iterator对象，用来遍历集合，<code>ListIterator</code>则专门用来遍历List。而<code>Enumeration</code>则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>\n<p><code>Arrays</code>和<code>Collections</code>是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了<code>Arrays.Copyof()</code>方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选<code>Concurrent</code>并发包下的对应的集合类。</p>\n<p>说明：本文图片为作者自己重新画的，便于自己理解，其余转载自：<a href=\"http://blog.csdn.net/ns_code/article/details/35564663\">兰亭风雨</a></p>\n","site":{"data":{}},"excerpt":"<p>\b集合对于\b使用Java的人来说就好像是日常三餐一样，熟悉且必不可少。集合是Java中\b重要的知识点，虽然我们平时都用到\b它，但是我们真的了解什么场景下用什么集合类吗？哪些是有序的？哪些是无序的？哪些是线程安全的？哪些是线程不安全的？…本系列将从源码的角度来分析集合框架，知其然，同时知其所以然，下面开始我们的探索之旅～</p>\n<p>Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p>\n<p>Java集合类的整体框架如下：</p>\n<p><img src=\"/jdk-collection/jdk-collection.png\"></p>","more":"<p>从上图中可以看出，集合类主要分为两大类：<code>Collection</code>和<code>Map</code>。</p>\n<p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>\n<p><code>List</code>接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为<code>ArrayList</code>和<code>LinkedList</code>，另外还有不常用的<code>Vector</code>。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>\n<p><code>Set</code>接口通常表示一个集合，其中的元素不允许重复（通过<code>hashcode</code>和<code>equals</code>函数保证），常用实现类有<code>HashSet</code>和<code>TreeSet</code>，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了<code>SortedSet</code>接口，因此是有序的集合（集合中的元素要实现<code>Comparable</code>接口，并覆写<code>Compartor</code>函数才行）。</p>\n<p>我们看到，抽象类<code>AbstractCollection</code>、<code>AbstractList</code>和<code>AbstractSet</code>分别实现了<code>Collection</code>、<code>List</code>和<code>Set</code>接口，这就是在Java集合框架中用的很多的<code>适配器设计模式</code>，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>\n<p><code>Map</code>是一个映射接口，其中的每个元素都是一个<code>key-value键值对</code>，同样抽象类<code>AbstractMap</code>通过适配器模式实现了Map接口中的大部分函数，<code>TreeMap</code>、<code>HashMap</code>、<code>WeakHashMap</code>等实现类都通过继承<code>AbstractMap</code>来实现，另外，不常用的<code>HashTable</code>直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>\n<p><code>Iterator</code>是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了<code>iterator()</code>函数，它返回一个Iterator对象，用来遍历集合，<code>ListIterator</code>则专门用来遍历List。而<code>Enumeration</code>则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>\n<p><code>Arrays</code>和<code>Collections</code>是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了<code>Arrays.Copyof()</code>方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选<code>Concurrent</code>并发包下的对应的集合类。</p>\n<p>说明：本文图片为作者自己重新画的，便于自己理解，其余转载自：<a href=\"http://blog.csdn.net/ns_code/article/details/35564663\">兰亭风雨</a></p>"},{"title":"Stream.peek() method in Java 8 vs Java 9","date":"2018-10-17T12:42:16.000Z","_content":"最近从 `Oracle Jdk8` 切换到 `OpenJdk 10` 后，遇到了一个诡异的问题，通过 Debug 排查后发现原来是 `Stream.peek()` 方法在搞鬼，特此记录下，以防后续使用 `Java 9及以上` 版本时再次犯同样的错误。\n\n示例代码如下：\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new ArrayList<>() {{\n        add(\"a\");\n        add(\"b\");\n        add(\"c\");\n    }};\n\n    list.stream().peek(System.out::println).count();\n}\n```\n\n在 `Java 8` 中，输出应如下：\n\n```java\na\nb\nc\n```\n\n切换到 `Java 9` 后，没有任何输出!!!\n\n突然有点怀疑人生的感觉-_-#\n\n<!--more-->\n\n于是就去 `StackOverFlow\b` （如果你不知道的话，赶紧去访问看看～）问答网站上搜索，发现也有人出现一样的问题：[Stream.peek() method in Java 8 vs Java 9](https://stackoverflow.com/questions/48221783/stream-peek-method-in-java-8-vs-java-9)\n\n\b针对以上问题，分析如下：\n\n#### Stream.peek() 方法介绍\n\n生成一个包含原 `Stream` 的所有元素的新 Stream，同时会提供一个消费函数（ `Consumer` 实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；\n\n代码定义如下：\n\n```java\nStream<T> peek(Consumer<? super T> action);\n```\n\n示意图如下：\n\n![](https://user-gold-cdn.xitu.io/2018/10/17/166821db0803fcbd?w=403&h=212&f=jpeg&s=33878)\n\n#### Java 9 中 Stream.peek() 不执行的原因\n\n`Javadoc\b` 关于 `Stream` 说明如下：\n\n>A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, `a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation`. This means that `side-effects of behavioral parameters may not always be executed` and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count() operation. For more detail, see the side-effects section of the stream package documentation.)\n\n`Javadoc\b` 关于 `count()` 说明如下：\n>API Note:<br>\n`An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source`. In such cases no source elements will be traversed and `no intermediate operations will be evaluated`. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. \n\n从 `Javadoc` 中可以知道，当 `List` 的元素个数没有变化时，没必要执行 `map` 和 `peek` 方法，而且\b`终止操作`为 `count()`，元素个数没有变化时，也没必要执行 `map` 和 `peek` 方法，除非使用能影响元素个数的一些方法，如 `filter` 和 `distinct`，所以在 `Java 9` 中使用\b `Stream.peek()` 与 `Stream.map()` 方法要注意使用场景，否则方法是不会执行的。\n\n`Javadoc` 中还有一段说明，`peek()` 方法主要用于 `debug`：\n\n>API Note <br>This method exists mainly to `support debugging`, where you want to see the elements as they flow past a certain point in a pipeline.","source":"_posts/stream-peek-method-in-java-8-vs-java-9.md","raw":"title: Stream.peek() method in Java 8 vs Java 9\ndate: 2018-10-17 20:42:16\ncategories: Java\ntags: [Java,Java9新特性]\n---\n最近从 `Oracle Jdk8` 切换到 `OpenJdk 10` 后，遇到了一个诡异的问题，通过 Debug 排查后发现原来是 `Stream.peek()` 方法在搞鬼，特此记录下，以防后续使用 `Java 9及以上` 版本时再次犯同样的错误。\n\n示例代码如下：\n\n```java\npublic static void main(String[] args) {\n    List<String> list = new ArrayList<>() {{\n        add(\"a\");\n        add(\"b\");\n        add(\"c\");\n    }};\n\n    list.stream().peek(System.out::println).count();\n}\n```\n\n在 `Java 8` 中，输出应如下：\n\n```java\na\nb\nc\n```\n\n切换到 `Java 9` 后，没有任何输出!!!\n\n突然有点怀疑人生的感觉-_-#\n\n<!--more-->\n\n于是就去 `StackOverFlow\b` （如果你不知道的话，赶紧去访问看看～）问答网站上搜索，发现也有人出现一样的问题：[Stream.peek() method in Java 8 vs Java 9](https://stackoverflow.com/questions/48221783/stream-peek-method-in-java-8-vs-java-9)\n\n\b针对以上问题，分析如下：\n\n#### Stream.peek() 方法介绍\n\n生成一个包含原 `Stream` 的所有元素的新 Stream，同时会提供一个消费函数（ `Consumer` 实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；\n\n代码定义如下：\n\n```java\nStream<T> peek(Consumer<? super T> action);\n```\n\n示意图如下：\n\n![](https://user-gold-cdn.xitu.io/2018/10/17/166821db0803fcbd?w=403&h=212&f=jpeg&s=33878)\n\n#### Java 9 中 Stream.peek() 不执行的原因\n\n`Javadoc\b` 关于 `Stream` 说明如下：\n\n>A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, `a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation`. This means that `side-effects of behavioral parameters may not always be executed` and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count() operation. For more detail, see the side-effects section of the stream package documentation.)\n\n`Javadoc\b` 关于 `count()` 说明如下：\n>API Note:<br>\n`An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source`. In such cases no source elements will be traversed and `no intermediate operations will be evaluated`. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. \n\n从 `Javadoc` 中可以知道，当 `List` 的元素个数没有变化时，没必要执行 `map` 和 `peek` 方法，而且\b`终止操作`为 `count()`，元素个数没有变化时，也没必要执行 `map` 和 `peek` 方法，除非使用能影响元素个数的一些方法，如 `filter` 和 `distinct`，所以在 `Java 9` 中使用\b `Stream.peek()` 与 `Stream.map()` 方法要注意使用场景，否则方法是不会执行的。\n\n`Javadoc` 中还有一段说明，`peek()` 方法主要用于 `debug`：\n\n>API Note <br>This method exists mainly to `support debugging`, where you want to see the elements as they flow past a certain point in a pipeline.","slug":"stream-peek-method-in-java-8-vs-java-9","published":1,"updated":"2025-03-07T13:26:47.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2u002srz5m6jbf301g","content":"<p>最近从 <code>Oracle Jdk8</code> 切换到 <code>OpenJdk 10</code> 后，遇到了一个诡异的问题，通过 Debug 排查后发现原来是 <code>Stream.peek()</code> 方法在搞鬼，特此记录下，以防后续使用 <code>Java 9及以上</code> 版本时再次犯同样的错误。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class=\"line\">        add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream().peek(System.out::println).count();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Java 8</code> 中，输出应如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br></pre></td></tr></table></figure>\n\n<p>切换到 <code>Java 9</code> 后，没有任何输出!!!</p>\n<p>突然有点怀疑人生的感觉-_-#</p>\n<span id=\"more\"></span>\n\n<p>于是就去 <code>StackOverFlow\b</code> （如果你不知道的话，赶紧去访问看看～）问答网站上搜索，发现也有人出现一样的问题：<a href=\"https://stackoverflow.com/questions/48221783/stream-peek-method-in-java-8-vs-java-9\">Stream.peek() method in Java 8 vs Java 9</a></p>\n<p>\b针对以上问题，分析如下：</p>\n<h4 id=\"Stream-peek-方法介绍\"><a href=\"#Stream-peek-方法介绍\" class=\"headerlink\" title=\"Stream.peek() 方法介绍\"></a>Stream.peek() 方法介绍</h4><p>生成一个包含原 <code>Stream</code> 的所有元素的新 Stream，同时会提供一个消费函数（ <code>Consumer</code> 实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p>\n<p>代码定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">peek</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示意图如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/17/166821db0803fcbd?w=403&h=212&f=jpeg&s=33878\"></p>\n<h4 id=\"Java-9-中-Stream-peek-不执行的原因\"><a href=\"#Java-9-中-Stream-peek-不执行的原因\" class=\"headerlink\" title=\"Java 9 中 Stream.peek() 不执行的原因\"></a>Java 9 中 Stream.peek() 不执行的原因</h4><p><code>Javadoc\b</code> 关于 <code>Stream</code> 说明如下：</p>\n<blockquote>\n<p>A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, <code>a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation</code>. This means that <code>side-effects of behavioral parameters may not always be executed</code> and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count() operation. For more detail, see the side-effects section of the stream package documentation.)</p>\n</blockquote>\n<p><code>Javadoc\b</code> 关于 <code>count()</code> 说明如下：</p>\n<blockquote>\n<p>API Note:<br><br><code>An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source</code>. In such cases no source elements will be traversed and <code>no intermediate operations will be evaluated</code>. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. </p>\n</blockquote>\n<p>从 <code>Javadoc</code> 中可以知道，当 <code>List</code> 的元素个数没有变化时，没必要执行 <code>map</code> 和 <code>peek</code> 方法，而且\b<code>终止操作</code>为 <code>count()</code>，元素个数没有变化时，也没必要执行 <code>map</code> 和 <code>peek</code> 方法，除非使用能影响元素个数的一些方法，如 <code>filter</code> 和 <code>distinct</code>，所以在 <code>Java 9</code> 中使用\b <code>Stream.peek()</code> 与 <code>Stream.map()</code> 方法要注意使用场景，否则方法是不会执行的。</p>\n<p><code>Javadoc</code> 中还有一段说明，<code>peek()</code> 方法主要用于 <code>debug</code>：</p>\n<blockquote>\n<p>API Note <br>This method exists mainly to <code>support debugging</code>, where you want to see the elements as they flow past a certain point in a pipeline.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>最近从 <code>Oracle Jdk8</code> 切换到 <code>OpenJdk 10</code> 后，遇到了一个诡异的问题，通过 Debug 排查后发现原来是 <code>Stream.peek()</code> 方法在搞鬼，特此记录下，以防后续使用 <code>Java 9及以上</code> 版本时再次犯同样的错误。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class=\"line\">        add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">        add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">        add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    list.stream().peek(System.out::println).count();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Java 8</code> 中，输出应如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a</span><br><span class=\"line\">b</span><br><span class=\"line\">c</span><br></pre></td></tr></table></figure>\n\n<p>切换到 <code>Java 9</code> 后，没有任何输出!!!</p>\n<p>突然有点怀疑人生的感觉-_-#</p>","more":"<p>于是就去 <code>StackOverFlow\b</code> （如果你不知道的话，赶紧去访问看看～）问答网站上搜索，发现也有人出现一样的问题：<a href=\"https://stackoverflow.com/questions/48221783/stream-peek-method-in-java-8-vs-java-9\">Stream.peek() method in Java 8 vs Java 9</a></p>\n<p>\b针对以上问题，分析如下：</p>\n<h4 id=\"Stream-peek-方法介绍\"><a href=\"#Stream-peek-方法介绍\" class=\"headerlink\" title=\"Stream.peek() 方法介绍\"></a>Stream.peek() 方法介绍</h4><p>生成一个包含原 <code>Stream</code> 的所有元素的新 Stream，同时会提供一个消费函数（ <code>Consumer</code> 实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p>\n<p>代码定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;T&gt; <span class=\"title function_\">peek</span><span class=\"params\">(Consumer&lt;? <span class=\"built_in\">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>示意图如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/10/17/166821db0803fcbd?w=403&h=212&f=jpeg&s=33878\"></p>\n<h4 id=\"Java-9-中-Stream-peek-不执行的原因\"><a href=\"#Java-9-中-Stream-peek-不执行的原因\" class=\"headerlink\" title=\"Java 9 中 Stream.peek() 不执行的原因\"></a>Java 9 中 Stream.peek() 不执行的原因</h4><p><code>Javadoc\b</code> 关于 <code>Stream</code> 说明如下：</p>\n<blockquote>\n<p>A stream implementation is permitted significant latitude in optimizing the computation of the result. For example, <code>a stream implementation is free to elide operations (or entire stages) from a stream pipeline -- and therefore elide invocation of behavioral parameters -- if it can prove that it would not affect the result of the computation</code>. This means that <code>side-effects of behavioral parameters may not always be executed</code> and should not be relied upon, unless otherwise specified (such as by the terminal operations forEach and forEachOrdered). (For a specific example of such an optimization, see the API note documented on the count() operation. For more detail, see the side-effects section of the stream package documentation.)</p>\n</blockquote>\n<p><code>Javadoc\b</code> 关于 <code>count()</code> 说明如下：</p>\n<blockquote>\n<p>API Note:<br><br><code>An implementation may choose to not execute the stream pipeline (either sequentially or in parallel) if it is capable of computing the count directly from the stream source</code>. In such cases no source elements will be traversed and <code>no intermediate operations will be evaluated</code>. Behavioral parameters with side-effects, which are strongly discouraged except for harmless cases such as debugging, may be affected. </p>\n</blockquote>\n<p>从 <code>Javadoc</code> 中可以知道，当 <code>List</code> 的元素个数没有变化时，没必要执行 <code>map</code> 和 <code>peek</code> 方法，而且\b<code>终止操作</code>为 <code>count()</code>，元素个数没有变化时，也没必要执行 <code>map</code> 和 <code>peek</code> 方法，除非使用能影响元素个数的一些方法，如 <code>filter</code> 和 <code>distinct</code>，所以在 <code>Java 9</code> 中使用\b <code>Stream.peek()</code> 与 <code>Stream.map()</code> 方法要注意使用场景，否则方法是不会执行的。</p>\n<p><code>Javadoc</code> 中还有一段说明，<code>peek()</code> 方法主要用于 <code>debug</code>：</p>\n<blockquote>\n<p>API Note <br>This method exists mainly to <code>support debugging</code>, where you want to see the elements as they flow past a certain point in a pipeline.</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git入门介绍）","date":"2018-03-05T23:45:21.000Z","_content":"# VCS\n\n版本控制系统（version control system）,是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。用的比较多的如svn，git等。\n\n# DVCS\n\n分布式版本控制系统（Distributed Version Control System），软件开发过程中，要解决多人协作的问题，需要有一个版本控制系统，用来合并和管理多人对同一个项目的开发和修改。版本控制有两种方式，一种是集中式版本控制系统，顾名思义，是把代码的管理和同步放在同一个服务器端来进行，如CVS，SVN，由于有完善的权限系统，以及统一的服务端，适合商业软件的开发；而分布式版本控制系统，则相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。\n\n# Git\n\nGit是一款免费的、开源的分布式版本控制系统，旨在快速高效地处理无论规模大小的任何软件工程。Git很容易学习，且小步快走，有着闪电般的性能。它超越了SCM工具，比如SVN、CVS、Perforce、ClearCase等，具体体现在方便的本地分支管理、方便的暂存区、并行工作流等。\n\n每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。\n\n>Git 是由“Linux之父” Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了Git。\n\n<!--more-->\n\n# Git与Svn的区别\n\nGit是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。\n\n# Git的优势\n\n+ 快速：无论是pull代码，还是拉分支，都很快\n+ 离线工作：Git可以让你在本地做所有操作，提交代码，查看历史，合并，创建分支等等\n+ 回退：你可以用revert、reset来回退代码，甚至可以恢复已经删除的提交\n+ 保持工作独立：版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者\n+ 分布式版本库，无单点故障\n+ 元数据方式存储内容：所有版本信息：标签、分支、版本记录等位于`.git`目录中\n\n# 系列内容\n\n本系列内容将用`示例图`的方式来讲解`git相关命令的执行过程`，并分享一些`实战经验`，比如`分支策略`，以及日常使用中遇到的问题。","source":"_posts/如何克服解决Git冲突的恐惧症？（Git入门介绍）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git入门介绍）\ndate: 2018-03-06 07:45:21\ncategories: Git\ntags: [Git]\n---\n# VCS\n\n版本控制系统（version control system）,是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。用的比较多的如svn，git等。\n\n# DVCS\n\n分布式版本控制系统（Distributed Version Control System），软件开发过程中，要解决多人协作的问题，需要有一个版本控制系统，用来合并和管理多人对同一个项目的开发和修改。版本控制有两种方式，一种是集中式版本控制系统，顾名思义，是把代码的管理和同步放在同一个服务器端来进行，如CVS，SVN，由于有完善的权限系统，以及统一的服务端，适合商业软件的开发；而分布式版本控制系统，则相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。\n\n# Git\n\nGit是一款免费的、开源的分布式版本控制系统，旨在快速高效地处理无论规模大小的任何软件工程。Git很容易学习，且小步快走，有着闪电般的性能。它超越了SCM工具，比如SVN、CVS、Perforce、ClearCase等，具体体现在方便的本地分支管理、方便的暂存区、并行工作流等。\n\n每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。\n\n>Git 是由“Linux之父” Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了Git。\n\n<!--more-->\n\n# Git与Svn的区别\n\nGit是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。\n\n# Git的优势\n\n+ 快速：无论是pull代码，还是拉分支，都很快\n+ 离线工作：Git可以让你在本地做所有操作，提交代码，查看历史，合并，创建分支等等\n+ 回退：你可以用revert、reset来回退代码，甚至可以恢复已经删除的提交\n+ 保持工作独立：版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者\n+ 分布式版本库，无单点故障\n+ 元数据方式存储内容：所有版本信息：标签、分支、版本记录等位于`.git`目录中\n\n# 系列内容\n\n本系列内容将用`示例图`的方式来讲解`git相关命令的执行过程`，并分享一些`实战经验`，比如`分支策略`，以及日常使用中遇到的问题。","slug":"如何克服解决Git冲突的恐惧症？（Git入门介绍）","published":1,"updated":"2025-03-07T13:26:47.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2u002wrz5mb99z5vbi","content":"<h1 id=\"VCS\"><a href=\"#VCS\" class=\"headerlink\" title=\"VCS\"></a>VCS</h1><p>版本控制系统（version control system）,是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。用的比较多的如svn，git等。</p>\n<h1 id=\"DVCS\"><a href=\"#DVCS\" class=\"headerlink\" title=\"DVCS\"></a>DVCS</h1><p>分布式版本控制系统（Distributed Version Control System），软件开发过程中，要解决多人协作的问题，需要有一个版本控制系统，用来合并和管理多人对同一个项目的开发和修改。版本控制有两种方式，一种是集中式版本控制系统，顾名思义，是把代码的管理和同步放在同一个服务器端来进行，如CVS，SVN，由于有完善的权限系统，以及统一的服务端，适合商业软件的开发；而分布式版本控制系统，则相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。</p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><p>Git是一款免费的、开源的分布式版本控制系统，旨在快速高效地处理无论规模大小的任何软件工程。Git很容易学习，且小步快走，有着闪电般的性能。它超越了SCM工具，比如SVN、CVS、Perforce、ClearCase等，具体体现在方便的本地分支管理、方便的暂存区、并行工作流等。</p>\n<p>每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。</p>\n<blockquote>\n<p>Git 是由“Linux之父” Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了Git。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Git与Svn的区别\"><a href=\"#Git与Svn的区别\" class=\"headerlink\" title=\"Git与Svn的区别\"></a>Git与Svn的区别</h1><p>Git是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。</p>\n<h1 id=\"Git的优势\"><a href=\"#Git的优势\" class=\"headerlink\" title=\"Git的优势\"></a>Git的优势</h1><ul>\n<li>快速：无论是pull代码，还是拉分支，都很快</li>\n<li>离线工作：Git可以让你在本地做所有操作，提交代码，查看历史，合并，创建分支等等</li>\n<li>回退：你可以用revert、reset来回退代码，甚至可以恢复已经删除的提交</li>\n<li>保持工作独立：版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者</li>\n<li>分布式版本库，无单点故障</li>\n<li>元数据方式存储内容：所有版本信息：标签、分支、版本记录等位于<code>.git</code>目录中</li>\n</ul>\n<h1 id=\"系列内容\"><a href=\"#系列内容\" class=\"headerlink\" title=\"系列内容\"></a>系列内容</h1><p>本系列内容将用<code>示例图</code>的方式来讲解<code>git相关命令的执行过程</code>，并分享一些<code>实战经验</code>，比如<code>分支策略</code>，以及日常使用中遇到的问题。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"VCS\"><a href=\"#VCS\" class=\"headerlink\" title=\"VCS\"></a>VCS</h1><p>版本控制系统（version control system）,是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。用的比较多的如svn，git等。</p>\n<h1 id=\"DVCS\"><a href=\"#DVCS\" class=\"headerlink\" title=\"DVCS\"></a>DVCS</h1><p>分布式版本控制系统（Distributed Version Control System），软件开发过程中，要解决多人协作的问题，需要有一个版本控制系统，用来合并和管理多人对同一个项目的开发和修改。版本控制有两种方式，一种是集中式版本控制系统，顾名思义，是把代码的管理和同步放在同一个服务器端来进行，如CVS，SVN，由于有完善的权限系统，以及统一的服务端，适合商业软件的开发；而分布式版本控制系统，则相当于把集中式版本控制系统的服务端和客户端都交给参与开发的客户端来保管，只有需要不同开发者合并代码时，才需要一个中转站来完成。</p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><p>Git是一款免费的、开源的分布式版本控制系统，旨在快速高效地处理无论规模大小的任何软件工程。Git很容易学习，且小步快走，有着闪电般的性能。它超越了SCM工具，比如SVN、CVS、Perforce、ClearCase等，具体体现在方便的本地分支管理、方便的暂存区、并行工作流等。</p>\n<p>每一个 Git克隆 都是一个完整的文件库，含有全部历史记录和修订追踪能力，不依赖于网络连接或中心服务器。其最大特色就是“分支”及“合并”操作非常快速、简便。</p>\n<blockquote>\n<p>Git 是由“Linux之父” Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了Git。</p>\n</blockquote>","more":"<h1 id=\"Git与Svn的区别\"><a href=\"#Git与Svn的区别\" class=\"headerlink\" title=\"Git与Svn的区别\"></a>Git与Svn的区别</h1><p>Git是分布式SCM，而SVN是基于服务器的，也就是说每个开发者本地都有一套git库，每个人维护自己的版本（或者合并其他人的版本），而SVN是每个人写完代码后都及时的checkin到服务器上，进行合并。</p>\n<h1 id=\"Git的优势\"><a href=\"#Git的优势\" class=\"headerlink\" title=\"Git的优势\"></a>Git的优势</h1><ul>\n<li>快速：无论是pull代码，还是拉分支，都很快</li>\n<li>离线工作：Git可以让你在本地做所有操作，提交代码，查看历史，合并，创建分支等等</li>\n<li>回退：你可以用revert、reset来回退代码，甚至可以恢复已经删除的提交</li>\n<li>保持工作独立：版本库是自己的，回滚历史、反复提交、归并分支并不会影响到其他开发者</li>\n<li>分布式版本库，无单点故障</li>\n<li>元数据方式存储内容：所有版本信息：标签、分支、版本记录等位于<code>.git</code>目录中</li>\n</ul>\n<h1 id=\"系列内容\"><a href=\"#系列内容\" class=\"headerlink\" title=\"系列内容\"></a>系列内容</h1><p>本系列内容将用<code>示例图</code>的方式来讲解<code>git相关命令的执行过程</code>，并分享一些<code>实战经验</code>，比如<code>分支策略</code>，以及日常使用中遇到的问题。</p>"},{"title":"如何克服解决Git冲突的恐惧症？（Git分支策略）","date":"2018-03-12T23:50:25.000Z","_content":">git默认的是master分支，试想下，如果所有的开发都在master分支，想起来都比较混乱，那么有没有比较科学的分支策略呢？本篇将介绍git的分支策略，听我慢慢道来～\n\n# 分支分类\n\n正常分支：\n\n+ master：主分支\n+ develop：开发分支\n\n临时分支：\n\n+ feature：功能分支\n+ release：预发布分支\n+ fixbug：修补bug分支\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/162100f7945bace0?w=840&h=885&f=png&s=121275)\n\n<!--more-->\n\n# 主分支\n\n首先，代码库应该有一个、且仅有一个主分支。\n\n所有提供给用户使用的正式版本，都在这个主分支上发布。\n\nGit主分支的名字，默认叫做Master。\n\n它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。\n\n# 开发分支\n\n主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。\n\n这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行\"合并\"（merge）。\n\nGit创建Develop分支的命令：\n    \n```java\ngit checkout -b develop master\n```\n    \n将Develop分支发布到Master分支的命令：\n\n```java\n# 切换到Master分支\ngit checkout master\n# 对Develop分支进行合并\ngit merge --no-ff develop\n```\n\n# 功能分支\n\n功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。\n\n功能分支的名字，可以采用feature-*的形式命名。\n\nGit创建一个功能分支：\n\n```java\ngit checkout -b feature-x develop\n```\n\n开发完成后，将功能分支合并到develop分支： \n\n```java\ngit checkout develop\ngit merge --no-ff feature-x\n```\n\n删除feature分支：\n```java\ngit branch -d feature-x\n```\n\n# 预发布分支\n\n预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。\n\n预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。\n\n它的命名，可以采用release-*的形式。\n\nGit创建一个预发布分支：\n\n```java\ngit checkout -b release-1.2 develop\n```\n\n确认没有问题后，合并到master分支：   \n\n```java\ngit checkout master\ngit merge --no-ff release-1.2\n# 对合并生成的新节点，做一个标签\ngit tag -a 1.2\n```\n\n再合并到develop分支：\n\n```java\ngit checkout develop\ngit merge --no-ff release-1.2\n```\n\n最后，删除预发布分支：\n\n```java\ngit branch -d release-1.2\n```\n\n# 修补bug分支\n\n软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。\n\n修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。\n\nGit创建一个修补bug分支：\n\n```java\ngit checkout -b fixbug-0.1 master\n```\n\n修补结束后，合并到master分支：  \n\n```java\ngit checkout master\ngit merge --no-ff fixbug-0.1\ngit tag -a 0.1.1\n```\n\n再合并到develop分支：\n\n```java\ngit checkout develop\ngit merge --no-ff fixbug-0.1\n```\n\n最后，删除\"修补bug分支\"：\n\n```java\ngit branch -d fixbug-0.1\n```\n\n# 多人协作的工作模式\n\n首先，可以试图用git push origin branch-name推送自己的修改；\n\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n\n如果合并有冲突，则解决冲突，并在本地提交；\n\n没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！\n\n如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。\n\n>这就是多人协作的工作模式，一旦熟悉了，就非常简单。","source":"_posts/如何克服解决Git冲突的恐惧症？（Git分支策略）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git分支策略）\ndate: 2018-03-13 07:50:25\ncategories: Git\ntags: [Git]\n---\n>git默认的是master分支，试想下，如果所有的开发都在master分支，想起来都比较混乱，那么有没有比较科学的分支策略呢？本篇将介绍git的分支策略，听我慢慢道来～\n\n# 分支分类\n\n正常分支：\n\n+ master：主分支\n+ develop：开发分支\n\n临时分支：\n\n+ feature：功能分支\n+ release：预发布分支\n+ fixbug：修补bug分支\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/162100f7945bace0?w=840&h=885&f=png&s=121275)\n\n<!--more-->\n\n# 主分支\n\n首先，代码库应该有一个、且仅有一个主分支。\n\n所有提供给用户使用的正式版本，都在这个主分支上发布。\n\nGit主分支的名字，默认叫做Master。\n\n它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。\n\n# 开发分支\n\n主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。\n\n这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行\"合并\"（merge）。\n\nGit创建Develop分支的命令：\n    \n```java\ngit checkout -b develop master\n```\n    \n将Develop分支发布到Master分支的命令：\n\n```java\n# 切换到Master分支\ngit checkout master\n# 对Develop分支进行合并\ngit merge --no-ff develop\n```\n\n# 功能分支\n\n功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。\n\n功能分支的名字，可以采用feature-*的形式命名。\n\nGit创建一个功能分支：\n\n```java\ngit checkout -b feature-x develop\n```\n\n开发完成后，将功能分支合并到develop分支： \n\n```java\ngit checkout develop\ngit merge --no-ff feature-x\n```\n\n删除feature分支：\n```java\ngit branch -d feature-x\n```\n\n# 预发布分支\n\n预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。\n\n预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。\n\n它的命名，可以采用release-*的形式。\n\nGit创建一个预发布分支：\n\n```java\ngit checkout -b release-1.2 develop\n```\n\n确认没有问题后，合并到master分支：   \n\n```java\ngit checkout master\ngit merge --no-ff release-1.2\n# 对合并生成的新节点，做一个标签\ngit tag -a 1.2\n```\n\n再合并到develop分支：\n\n```java\ngit checkout develop\ngit merge --no-ff release-1.2\n```\n\n最后，删除预发布分支：\n\n```java\ngit branch -d release-1.2\n```\n\n# 修补bug分支\n\n软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。\n\n修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。\n\nGit创建一个修补bug分支：\n\n```java\ngit checkout -b fixbug-0.1 master\n```\n\n修补结束后，合并到master分支：  \n\n```java\ngit checkout master\ngit merge --no-ff fixbug-0.1\ngit tag -a 0.1.1\n```\n\n再合并到develop分支：\n\n```java\ngit checkout develop\ngit merge --no-ff fixbug-0.1\n```\n\n最后，删除\"修补bug分支\"：\n\n```java\ngit branch -d fixbug-0.1\n```\n\n# 多人协作的工作模式\n\n首先，可以试图用git push origin branch-name推送自己的修改；\n\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n\n如果合并有冲突，则解决冲突，并在本地提交；\n\n没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！\n\n如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。\n\n>这就是多人协作的工作模式，一旦熟悉了，就非常简单。","slug":"如何克服解决Git冲突的恐惧症？（Git分支策略）","published":1,"updated":"2025-03-07T13:26:47.258Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2v0030rz5mela2h86n","content":"<blockquote>\n<p>git默认的是master分支，试想下，如果所有的开发都在master分支，想起来都比较混乱，那么有没有比较科学的分支策略呢？本篇将介绍git的分支策略，听我慢慢道来～</p>\n</blockquote>\n<h1 id=\"分支分类\"><a href=\"#分支分类\" class=\"headerlink\" title=\"分支分类\"></a>分支分类</h1><p>正常分支：</p>\n<ul>\n<li>master：主分支</li>\n<li>develop：开发分支</li>\n</ul>\n<p>临时分支：</p>\n<ul>\n<li>feature：功能分支</li>\n<li>release：预发布分支</li>\n<li>fixbug：修补bug分支</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/162100f7945bace0?w=840&h=885&f=png&s=121275\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"主分支\"><a href=\"#主分支\" class=\"headerlink\" title=\"主分支\"></a>主分支</h1><p>首先，代码库应该有一个、且仅有一个主分支。</p>\n<p>所有提供给用户使用的正式版本，都在这个主分支上发布。</p>\n<p>Git主分支的名字，默认叫做Master。</p>\n<p>它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>\n<h1 id=\"开发分支\"><a href=\"#开发分支\" class=\"headerlink\" title=\"开发分支\"></a>开发分支</h1><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p>\n<p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>\n<p>Git创建Develop分支的命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b develop master</span><br></pre></td></tr></table></figure>\n<p>将Develop分支发布到Master分支的命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到Master分支</span><br><span class=\"line\">git checkout master</span><br><span class=\"line\"># 对Develop分支进行合并</span><br><span class=\"line\">git merge --no-ff develop</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"功能分支\"><a href=\"#功能分支\" class=\"headerlink\" title=\"功能分支\"></a>功能分支</h1><p>功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p>\n<p>功能分支的名字，可以采用feature-*的形式命名。</p>\n<p>Git创建一个功能分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature-x develop</span><br></pre></td></tr></table></figure>\n\n<p>开发完成后，将功能分支合并到develop分支： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff feature-x</span><br></pre></td></tr></table></figure>\n\n<p>删除feature分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature-x</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"预发布分支\"><a href=\"#预发布分支\" class=\"headerlink\" title=\"预发布分支\"></a>预发布分支</h1><p>预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p>\n<p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。</p>\n<p>它的命名，可以采用release-*的形式。</p>\n<p>Git创建一个预发布分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b release-<span class=\"number\">1.2</span> develop</span><br></pre></td></tr></table></figure>\n\n<p>确认没有问题后，合并到master分支：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-<span class=\"number\">1.2</span></span><br><span class=\"line\"># 对合并生成的新节点，做一个标签</span><br><span class=\"line\">git tag -a <span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<p>再合并到develop分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-<span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，删除预发布分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d release-<span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修补bug分支\"><a href=\"#修补bug分支\" class=\"headerlink\" title=\"修补bug分支\"></a>修补bug分支</h1><p>软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p>\n<p>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>\n<p>Git创建一个修补bug分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b fixbug-<span class=\"number\">0.1</span> master</span><br></pre></td></tr></table></figure>\n\n<p>修补结束后，合并到master分支：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff fixbug-<span class=\"number\">0.1</span></span><br><span class=\"line\">git tag -a <span class=\"number\">0.1</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n<p>再合并到develop分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff fixbug-<span class=\"number\">0.1</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，删除”修补bug分支”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d fixbug-<span class=\"number\">0.1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"多人协作的工作模式\"><a href=\"#多人协作的工作模式\" class=\"headerlink\" title=\"多人协作的工作模式\"></a>多人协作的工作模式</h1><p>首先，可以试图用git push origin branch-name推送自己的修改；</p>\n<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>\n<p>如果合并有冲突，则解决冲突，并在本地提交；</p>\n<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>\n<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin&#x2F;branch-name。</p>\n<blockquote>\n<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>git默认的是master分支，试想下，如果所有的开发都在master分支，想起来都比较混乱，那么有没有比较科学的分支策略呢？本篇将介绍git的分支策略，听我慢慢道来～</p>\n</blockquote>\n<h1 id=\"分支分类\"><a href=\"#分支分类\" class=\"headerlink\" title=\"分支分类\"></a>分支分类</h1><p>正常分支：</p>\n<ul>\n<li>master：主分支</li>\n<li>develop：开发分支</li>\n</ul>\n<p>临时分支：</p>\n<ul>\n<li>feature：功能分支</li>\n<li>release：预发布分支</li>\n<li>fixbug：修补bug分支</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/162100f7945bace0?w=840&h=885&f=png&s=121275\"></p>","more":"<h1 id=\"主分支\"><a href=\"#主分支\" class=\"headerlink\" title=\"主分支\"></a>主分支</h1><p>首先，代码库应该有一个、且仅有一个主分支。</p>\n<p>所有提供给用户使用的正式版本，都在这个主分支上发布。</p>\n<p>Git主分支的名字，默认叫做Master。</p>\n<p>它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>\n<h1 id=\"开发分支\"><a href=\"#开发分支\" class=\"headerlink\" title=\"开发分支\"></a>开发分支</h1><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p>\n<p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>\n<p>Git创建Develop分支的命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b develop master</span><br></pre></td></tr></table></figure>\n<p>将Develop分支发布到Master分支的命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到Master分支</span><br><span class=\"line\">git checkout master</span><br><span class=\"line\"># 对Develop分支进行合并</span><br><span class=\"line\">git merge --no-ff develop</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"功能分支\"><a href=\"#功能分支\" class=\"headerlink\" title=\"功能分支\"></a>功能分支</h1><p>功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p>\n<p>功能分支的名字，可以采用feature-*的形式命名。</p>\n<p>Git创建一个功能分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b feature-x develop</span><br></pre></td></tr></table></figure>\n\n<p>开发完成后，将功能分支合并到develop分支： </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff feature-x</span><br></pre></td></tr></table></figure>\n\n<p>删除feature分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d feature-x</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"预发布分支\"><a href=\"#预发布分支\" class=\"headerlink\" title=\"预发布分支\"></a>预发布分支</h1><p>预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。</p>\n<p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。</p>\n<p>它的命名，可以采用release-*的形式。</p>\n<p>Git创建一个预发布分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b release-<span class=\"number\">1.2</span> develop</span><br></pre></td></tr></table></figure>\n\n<p>确认没有问题后，合并到master分支：   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-<span class=\"number\">1.2</span></span><br><span class=\"line\"># 对合并生成的新节点，做一个标签</span><br><span class=\"line\">git tag -a <span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<p>再合并到develop分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-<span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，删除预发布分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d release-<span class=\"number\">1.2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修补bug分支\"><a href=\"#修补bug分支\" class=\"headerlink\" title=\"修补bug分支\"></a>修补bug分支</h1><p>软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p>\n<p>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>\n<p>Git创建一个修补bug分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b fixbug-<span class=\"number\">0.1</span> master</span><br></pre></td></tr></table></figure>\n\n<p>修补结束后，合并到master分支：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff fixbug-<span class=\"number\">0.1</span></span><br><span class=\"line\">git tag -a <span class=\"number\">0.1</span><span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n\n<p>再合并到develop分支：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff fixbug-<span class=\"number\">0.1</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，删除”修补bug分支”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d fixbug-<span class=\"number\">0.1</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"多人协作的工作模式\"><a href=\"#多人协作的工作模式\" class=\"headerlink\" title=\"多人协作的工作模式\"></a>多人协作的工作模式</h1><p>首先，可以试图用git push origin branch-name推送自己的修改；</p>\n<p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>\n<p>如果合并有冲突，则解决冲突，并在本地提交；</p>\n<p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>\n<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin&#x2F;branch-name。</p>\n<blockquote>\n<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git四大组件）","date":"2018-03-13T23:51:40.000Z","_content":"# Git存储结构\n\nGit有四大组件，分别是：\n\n+ Tag\n+ Commit\n+ Tree\n+ Blob\n\n当git初始化后，目录下就生成了.git文件夹，存放着与git相关的所有内容，我们看下目录下具体的内容：\n\n![](https://user-gold-cdn.xitu.io/2018/3/9/1620b296506043e3?w=1490&h=874&f=png&s=494715)\n\n所有的组件都存放在objects文件夹中：\n\n![](https://user-gold-cdn.xitu.io/2018/3/9/1620b2ace4e904ad?w=1452&h=314&f=png&s=178039)\n\n<!--more-->\n\n# Blob组件\n\n当我们执行`git add README.md`后，文件夹内容如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d502f8be1603?w=1456&h=514&f=png&s=302898)\n\n我们可以看到，目录中多了83目录，即blog组件，83目录中有文件名是一串UUID的文件，当我们执行git add将文件变为staged状态后，就会在objects目录创建一个组件，组件都是以hash的二进制方式进行存储，组件的名称为文件夹名称+文件名称，所有上面的blob组件的名字即为`83920ba13f0cd4e0046337313c1f0a1cfc676ad4`，这个名字是唯一的。\n\n当修改README.md后再次执行git add，发现，objects目录中又多了一个blob组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d6371d7f7916?w=1454&h=376&f=png&s=269554)\n\n注意：如果两个文件的内容一样的话，执行git add的时候，只会生成一个blob组件，不会是两个。blob组件是在代码提交到Stage区域的时候生成的，而且是以内容来生成一个字节码文件。\n\n可以通过git hash-object来查询文件的hash码：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d68688672f0f?w=1456&h=106&f=png&s=66710)\n\n# Commit组件\n\n刚刚我们已经执行了两次git add，下面我们将变动提交，执行git commit：\n\n```java\ngit commit -m \"init\"\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d7266827a1f5?w=1456&h=550&f=png&s=314371)\n\n可以看到，objects中多了两个文件夹，b6和da，这两个是什么呢？我们先用git log查看下提交日志：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d75440a806cf?w=1446&h=212&f=png&s=118173)\n\n可以看到，commit的id为`da7b2dd822e576db1cfb0e546a9de57fc8cfbe8b`，所以da文件夹为commit组件，那么b6是什么呢？\n\n# Tree组件\n\nb6是tree组件，每次commit时，首先会创建commit组件，然后将涉及的文件信息创建tree组件，我们可以用git cat-file -p命令查看commit组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620ff6716d46157?w=1456&h=240&f=png&s=208015)\n\n可以看到，通过git cat-file -p命令查看commit组件，可以看到tree组件，我们用git cat-file -p来查看tree组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620ffa41e6538bc?w=1454&h=106&f=png&s=99221)\n\n可以看到，tree组件中记录了文件的基本信息。\n\n# 底层运行流程\n\n我们总结下git底层的运行流程：\n\n![](https://user-gold-cdn.xitu.io/2018/3/6/161fb994093dae3b?w=638&h=359&f=jpeg&s=42249)\n\n+ 当我们添加或者修改了文件并且add到stage区之后，会根据文件内容创建不同的blob\n+ 当进行提交之后马上创建一个tree组件把需要的blob组件添加进去，之后再封装到一个commit组件中完成本次提交。\n+ 在将来进行reset的时候可以直接使用git reset --hard xxxxx可以恢复到某个特定的版本\n+ 在reset之后，git会根据这个commit组件的id快速的找到tree组件，然后根据tree找到blob组件，之后对仓库进行还原\n\n>我们看到，git的整个过程都是以hash和二进制进行操作，所以git执行效率非常之高。","source":"_posts/如何克服解决Git冲突的恐惧症？（Git四大组件）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git四大组件）\ndate: 2018-03-14 07:51:40\ncategories: Git\ntags: [Git]\n---\n# Git存储结构\n\nGit有四大组件，分别是：\n\n+ Tag\n+ Commit\n+ Tree\n+ Blob\n\n当git初始化后，目录下就生成了.git文件夹，存放着与git相关的所有内容，我们看下目录下具体的内容：\n\n![](https://user-gold-cdn.xitu.io/2018/3/9/1620b296506043e3?w=1490&h=874&f=png&s=494715)\n\n所有的组件都存放在objects文件夹中：\n\n![](https://user-gold-cdn.xitu.io/2018/3/9/1620b2ace4e904ad?w=1452&h=314&f=png&s=178039)\n\n<!--more-->\n\n# Blob组件\n\n当我们执行`git add README.md`后，文件夹内容如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d502f8be1603?w=1456&h=514&f=png&s=302898)\n\n我们可以看到，目录中多了83目录，即blog组件，83目录中有文件名是一串UUID的文件，当我们执行git add将文件变为staged状态后，就会在objects目录创建一个组件，组件都是以hash的二进制方式进行存储，组件的名称为文件夹名称+文件名称，所有上面的blob组件的名字即为`83920ba13f0cd4e0046337313c1f0a1cfc676ad4`，这个名字是唯一的。\n\n当修改README.md后再次执行git add，发现，objects目录中又多了一个blob组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d6371d7f7916?w=1454&h=376&f=png&s=269554)\n\n注意：如果两个文件的内容一样的话，执行git add的时候，只会生成一个blob组件，不会是两个。blob组件是在代码提交到Stage区域的时候生成的，而且是以内容来生成一个字节码文件。\n\n可以通过git hash-object来查询文件的hash码：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d68688672f0f?w=1456&h=106&f=png&s=66710)\n\n# Commit组件\n\n刚刚我们已经执行了两次git add，下面我们将变动提交，执行git commit：\n\n```java\ngit commit -m \"init\"\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d7266827a1f5?w=1456&h=550&f=png&s=314371)\n\n可以看到，objects中多了两个文件夹，b6和da，这两个是什么呢？我们先用git log查看下提交日志：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620d75440a806cf?w=1446&h=212&f=png&s=118173)\n\n可以看到，commit的id为`da7b2dd822e576db1cfb0e546a9de57fc8cfbe8b`，所以da文件夹为commit组件，那么b6是什么呢？\n\n# Tree组件\n\nb6是tree组件，每次commit时，首先会创建commit组件，然后将涉及的文件信息创建tree组件，我们可以用git cat-file -p命令查看commit组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620ff6716d46157?w=1456&h=240&f=png&s=208015)\n\n可以看到，通过git cat-file -p命令查看commit组件，可以看到tree组件，我们用git cat-file -p来查看tree组件：\n\n![](https://user-gold-cdn.xitu.io/2018/3/10/1620ffa41e6538bc?w=1454&h=106&f=png&s=99221)\n\n可以看到，tree组件中记录了文件的基本信息。\n\n# 底层运行流程\n\n我们总结下git底层的运行流程：\n\n![](https://user-gold-cdn.xitu.io/2018/3/6/161fb994093dae3b?w=638&h=359&f=jpeg&s=42249)\n\n+ 当我们添加或者修改了文件并且add到stage区之后，会根据文件内容创建不同的blob\n+ 当进行提交之后马上创建一个tree组件把需要的blob组件添加进去，之后再封装到一个commit组件中完成本次提交。\n+ 在将来进行reset的时候可以直接使用git reset --hard xxxxx可以恢复到某个特定的版本\n+ 在reset之后，git会根据这个commit组件的id快速的找到tree组件，然后根据tree找到blob组件，之后对仓库进行还原\n\n>我们看到，git的整个过程都是以hash和二进制进行操作，所以git执行效率非常之高。","slug":"如何克服解决Git冲突的恐惧症？（Git四大组件）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2v0033rz5maiyccl52","content":"<h1 id=\"Git存储结构\"><a href=\"#Git存储结构\" class=\"headerlink\" title=\"Git存储结构\"></a>Git存储结构</h1><p>Git有四大组件，分别是：</p>\n<ul>\n<li>Tag</li>\n<li>Commit</li>\n<li>Tree</li>\n<li>Blob</li>\n</ul>\n<p>当git初始化后，目录下就生成了.git文件夹，存放着与git相关的所有内容，我们看下目录下具体的内容：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/9/1620b296506043e3?w=1490&h=874&f=png&s=494715\"></p>\n<p>所有的组件都存放在objects文件夹中：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/9/1620b2ace4e904ad?w=1452&h=314&f=png&s=178039\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"Blob组件\"><a href=\"#Blob组件\" class=\"headerlink\" title=\"Blob组件\"></a>Blob组件</h1><p>当我们执行<code>git add README.md</code>后，文件夹内容如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d502f8be1603?w=1456&h=514&f=png&s=302898\"></p>\n<p>我们可以看到，目录中多了83目录，即blog组件，83目录中有文件名是一串UUID的文件，当我们执行git add将文件变为staged状态后，就会在objects目录创建一个组件，组件都是以hash的二进制方式进行存储，组件的名称为文件夹名称+文件名称，所有上面的blob组件的名字即为<code>83920ba13f0cd4e0046337313c1f0a1cfc676ad4</code>，这个名字是唯一的。</p>\n<p>当修改README.md后再次执行git add，发现，objects目录中又多了一个blob组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d6371d7f7916?w=1454&h=376&f=png&s=269554\"></p>\n<p>注意：如果两个文件的内容一样的话，执行git add的时候，只会生成一个blob组件，不会是两个。blob组件是在代码提交到Stage区域的时候生成的，而且是以内容来生成一个字节码文件。</p>\n<p>可以通过git hash-object来查询文件的hash码：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d68688672f0f?w=1456&h=106&f=png&s=66710\"></p>\n<h1 id=\"Commit组件\"><a href=\"#Commit组件\" class=\"headerlink\" title=\"Commit组件\"></a>Commit组件</h1><p>刚刚我们已经执行了两次git add，下面我们将变动提交，执行git commit：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;init&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d7266827a1f5?w=1456&h=550&f=png&s=314371\"></p>\n<p>可以看到，objects中多了两个文件夹，b6和da，这两个是什么呢？我们先用git log查看下提交日志：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d75440a806cf?w=1446&h=212&f=png&s=118173\"></p>\n<p>可以看到，commit的id为<code>da7b2dd822e576db1cfb0e546a9de57fc8cfbe8b</code>，所以da文件夹为commit组件，那么b6是什么呢？</p>\n<h1 id=\"Tree组件\"><a href=\"#Tree组件\" class=\"headerlink\" title=\"Tree组件\"></a>Tree组件</h1><p>b6是tree组件，每次commit时，首先会创建commit组件，然后将涉及的文件信息创建tree组件，我们可以用git cat-file -p命令查看commit组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620ff6716d46157?w=1456&h=240&f=png&s=208015\"></p>\n<p>可以看到，通过git cat-file -p命令查看commit组件，可以看到tree组件，我们用git cat-file -p来查看tree组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620ffa41e6538bc?w=1454&h=106&f=png&s=99221\"></p>\n<p>可以看到，tree组件中记录了文件的基本信息。</p>\n<h1 id=\"底层运行流程\"><a href=\"#底层运行流程\" class=\"headerlink\" title=\"底层运行流程\"></a>底层运行流程</h1><p>我们总结下git底层的运行流程：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161fb994093dae3b?w=638&h=359&f=jpeg&s=42249\"></p>\n<ul>\n<li>当我们添加或者修改了文件并且add到stage区之后，会根据文件内容创建不同的blob</li>\n<li>当进行提交之后马上创建一个tree组件把需要的blob组件添加进去，之后再封装到一个commit组件中完成本次提交。</li>\n<li>在将来进行reset的时候可以直接使用git reset –hard xxxxx可以恢复到某个特定的版本</li>\n<li>在reset之后，git会根据这个commit组件的id快速的找到tree组件，然后根据tree找到blob组件，之后对仓库进行还原</li>\n</ul>\n<blockquote>\n<p>我们看到，git的整个过程都是以hash和二进制进行操作，所以git执行效率非常之高。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Git存储结构\"><a href=\"#Git存储结构\" class=\"headerlink\" title=\"Git存储结构\"></a>Git存储结构</h1><p>Git有四大组件，分别是：</p>\n<ul>\n<li>Tag</li>\n<li>Commit</li>\n<li>Tree</li>\n<li>Blob</li>\n</ul>\n<p>当git初始化后，目录下就生成了.git文件夹，存放着与git相关的所有内容，我们看下目录下具体的内容：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/9/1620b296506043e3?w=1490&h=874&f=png&s=494715\"></p>\n<p>所有的组件都存放在objects文件夹中：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/9/1620b2ace4e904ad?w=1452&h=314&f=png&s=178039\"></p>","more":"<h1 id=\"Blob组件\"><a href=\"#Blob组件\" class=\"headerlink\" title=\"Blob组件\"></a>Blob组件</h1><p>当我们执行<code>git add README.md</code>后，文件夹内容如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d502f8be1603?w=1456&h=514&f=png&s=302898\"></p>\n<p>我们可以看到，目录中多了83目录，即blog组件，83目录中有文件名是一串UUID的文件，当我们执行git add将文件变为staged状态后，就会在objects目录创建一个组件，组件都是以hash的二进制方式进行存储，组件的名称为文件夹名称+文件名称，所有上面的blob组件的名字即为<code>83920ba13f0cd4e0046337313c1f0a1cfc676ad4</code>，这个名字是唯一的。</p>\n<p>当修改README.md后再次执行git add，发现，objects目录中又多了一个blob组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d6371d7f7916?w=1454&h=376&f=png&s=269554\"></p>\n<p>注意：如果两个文件的内容一样的话，执行git add的时候，只会生成一个blob组件，不会是两个。blob组件是在代码提交到Stage区域的时候生成的，而且是以内容来生成一个字节码文件。</p>\n<p>可以通过git hash-object来查询文件的hash码：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d68688672f0f?w=1456&h=106&f=png&s=66710\"></p>\n<h1 id=\"Commit组件\"><a href=\"#Commit组件\" class=\"headerlink\" title=\"Commit组件\"></a>Commit组件</h1><p>刚刚我们已经执行了两次git add，下面我们将变动提交，执行git commit：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;init&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d7266827a1f5?w=1456&h=550&f=png&s=314371\"></p>\n<p>可以看到，objects中多了两个文件夹，b6和da，这两个是什么呢？我们先用git log查看下提交日志：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620d75440a806cf?w=1446&h=212&f=png&s=118173\"></p>\n<p>可以看到，commit的id为<code>da7b2dd822e576db1cfb0e546a9de57fc8cfbe8b</code>，所以da文件夹为commit组件，那么b6是什么呢？</p>\n<h1 id=\"Tree组件\"><a href=\"#Tree组件\" class=\"headerlink\" title=\"Tree组件\"></a>Tree组件</h1><p>b6是tree组件，每次commit时，首先会创建commit组件，然后将涉及的文件信息创建tree组件，我们可以用git cat-file -p命令查看commit组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620ff6716d46157?w=1456&h=240&f=png&s=208015\"></p>\n<p>可以看到，通过git cat-file -p命令查看commit组件，可以看到tree组件，我们用git cat-file -p来查看tree组件：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/10/1620ffa41e6538bc?w=1454&h=106&f=png&s=99221\"></p>\n<p>可以看到，tree组件中记录了文件的基本信息。</p>\n<h1 id=\"底层运行流程\"><a href=\"#底层运行流程\" class=\"headerlink\" title=\"底层运行流程\"></a>底层运行流程</h1><p>我们总结下git底层的运行流程：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/6/161fb994093dae3b?w=638&h=359&f=jpeg&s=42249\"></p>\n<ul>\n<li>当我们添加或者修改了文件并且add到stage区之后，会根据文件内容创建不同的blob</li>\n<li>当进行提交之后马上创建一个tree组件把需要的blob组件添加进去，之后再封装到一个commit组件中完成本次提交。</li>\n<li>在将来进行reset的时候可以直接使用git reset –hard xxxxx可以恢复到某个特定的版本</li>\n<li>在reset之后，git会根据这个commit组件的id快速的找到tree组件，然后根据tree找到blob组件，之后对仓库进行还原</li>\n</ul>\n<blockquote>\n<p>我们看到，git的整个过程都是以hash和二进制进行操作，所以git执行效率非常之高。</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git基础篇--上）","date":"2018-03-06T23:46:38.000Z","_content":"# 初始化配置\n我们安装了git之后，都要先配置以下git工作环境。git提供了git config的工具，专门用来配置或读取相应的工作环境变量。\n\n配置：\n\n```java\ngit config --global user.name \"hellomypastor\"\ngit config --global user.email 18013963220@163.com\n```\n\n查看配置：\n\n```java\ngit config --list //方式一\ngit config -l //方式二\n```\n\n这些配置一般会存在三个地方：\n\n+ /etc/gitconfig：全局配置（针对所有用户）\n+ ~/.gitconfig：全局配置（针对某个用户）\n+ .git/config：局部配置（针对某个目录/项目）\n\n<!--more-->\n\n# 获取帮助\n\ngit help可以获取帮助，使用如下：\n\n```java\ngit commit --help //方式一\ngit help commit //方式二\n```\n\n# 在工作目录中初始化新仓库\n\ngit init可以将任何目录转化为git版本库，使用方法如下：\n\n```java\ngit init\n```\n\n初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n\n# 跟踪新文件\n\n初始化后，我们在目录中增加一个README.md文件，如果要跟踪这个文件，那么执行如下命令：\n\n```java\ngit add README.md\n```\n\n执行后，我们可以执行git status，可以看到，README.md已被跟踪起来：\n\n```java\nOn branch master\n\nInitial commit\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n\tnew file:   README.md\n```\n\n# 提交\n\n```java\ngit commit -m \"init version\"\n[master (root-commit) 4dfc094] init version\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\n```\n\n执行完，执行git status查看状态：\n\n```java\n On branch master\nnothing to commit, working tree clean\n```\n\n下面我用简单gif动图进行示例git commit的效果：\n\n执行命令如下：\n\n```java\ngit commit -m \"c2\"\ngit commit -m \"c3\"\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/7/162009ecae2b78b5?w=1024&h=768&f=gif&s=1022937)\n\n# 忽略某些文件\n\n一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表，比如说编译文件、日志、配置文件、环境文件等等，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式，看一个例子：\n\n```java\n# 此为注释 – 将被 Git 忽略\n# 忽略所有 .a 结尾的文件\n*.a\n# 但 lib.a 除外\n!lib.a\n# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\n/TODO\n# 忽略 build/ 目录下的所有文件\nbuild/\n# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\ndoc/*.txt\n# 忽略 doc/ 目录下所有扩展名为 txt 的文件\ndoc/**/*.txt\n```\n\n# 分支\n\n分支相关命令如下：\n\n```java\n//查看分支\ngit branch\n* master\n//新建分支\ngit branch bugFix\n  bugFix\n* master\n//新建分支并切换到分支\ngit checkout -b bugFix\n* bugFix\n  master\n```\n\n下面我用简单gif动图进行示例git commit的效果：\n\n执行命令如下：\n\n```java\ngit branch bugFix\ngit commit -m \"c2\"\ngit checkout bugFix\ngit commit -m \"c3\"\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/7/16200d5bc77b46e9?w=1024&h=768&f=gif&s=1120392)\n\n> 相信大家对git的基础命令已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git基础篇--下》，主要介绍git merge与git rebase，敬请期待～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git基础篇-上）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git基础篇--上）\ndate: 2018-03-07 07:46:38\ncategories: Git\ntags: [Git]\n---\n# 初始化配置\n我们安装了git之后，都要先配置以下git工作环境。git提供了git config的工具，专门用来配置或读取相应的工作环境变量。\n\n配置：\n\n```java\ngit config --global user.name \"hellomypastor\"\ngit config --global user.email 18013963220@163.com\n```\n\n查看配置：\n\n```java\ngit config --list //方式一\ngit config -l //方式二\n```\n\n这些配置一般会存在三个地方：\n\n+ /etc/gitconfig：全局配置（针对所有用户）\n+ ~/.gitconfig：全局配置（针对某个用户）\n+ .git/config：局部配置（针对某个目录/项目）\n\n<!--more-->\n\n# 获取帮助\n\ngit help可以获取帮助，使用如下：\n\n```java\ngit commit --help //方式一\ngit help commit //方式二\n```\n\n# 在工作目录中初始化新仓库\n\ngit init可以将任何目录转化为git版本库，使用方法如下：\n\n```java\ngit init\n```\n\n初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n\n# 跟踪新文件\n\n初始化后，我们在目录中增加一个README.md文件，如果要跟踪这个文件，那么执行如下命令：\n\n```java\ngit add README.md\n```\n\n执行后，我们可以执行git status，可以看到，README.md已被跟踪起来：\n\n```java\nOn branch master\n\nInitial commit\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n\n\tnew file:   README.md\n```\n\n# 提交\n\n```java\ngit commit -m \"init version\"\n[master (root-commit) 4dfc094] init version\n 1 file changed, 1 insertion(+)\n create mode 100644 README.md\n```\n\n执行完，执行git status查看状态：\n\n```java\n On branch master\nnothing to commit, working tree clean\n```\n\n下面我用简单gif动图进行示例git commit的效果：\n\n执行命令如下：\n\n```java\ngit commit -m \"c2\"\ngit commit -m \"c3\"\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/7/162009ecae2b78b5?w=1024&h=768&f=gif&s=1022937)\n\n# 忽略某些文件\n\n一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表，比如说编译文件、日志、配置文件、环境文件等等，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式，看一个例子：\n\n```java\n# 此为注释 – 将被 Git 忽略\n# 忽略所有 .a 结尾的文件\n*.a\n# 但 lib.a 除外\n!lib.a\n# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\n/TODO\n# 忽略 build/ 目录下的所有文件\nbuild/\n# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\ndoc/*.txt\n# 忽略 doc/ 目录下所有扩展名为 txt 的文件\ndoc/**/*.txt\n```\n\n# 分支\n\n分支相关命令如下：\n\n```java\n//查看分支\ngit branch\n* master\n//新建分支\ngit branch bugFix\n  bugFix\n* master\n//新建分支并切换到分支\ngit checkout -b bugFix\n* bugFix\n  master\n```\n\n下面我用简单gif动图进行示例git commit的效果：\n\n执行命令如下：\n\n```java\ngit branch bugFix\ngit commit -m \"c2\"\ngit checkout bugFix\ngit commit -m \"c3\"\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/7/16200d5bc77b46e9?w=1024&h=768&f=gif&s=1120392)\n\n> 相信大家对git的基础命令已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git基础篇--下》，主要介绍git merge与git rebase，敬请期待～","slug":"如何克服解决Git冲突的恐惧症？（Git基础篇-上）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2w0038rz5m0h0f0i48","content":"<h1 id=\"初始化配置\"><a href=\"#初始化配置\" class=\"headerlink\" title=\"初始化配置\"></a>初始化配置</h1><p>我们安装了git之后，都要先配置以下git工作环境。git提供了git config的工具，专门用来配置或读取相应的工作环境变量。</p>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;hellomypastor&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"number\">18013963220</span>@<span class=\"number\">163.</span>com</span><br></pre></td></tr></table></figure>\n\n<p>查看配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list <span class=\"comment\">//方式一</span></span><br><span class=\"line\">git config -l <span class=\"comment\">//方式二</span></span><br></pre></td></tr></table></figure>\n\n<p>这些配置一般会存在三个地方：</p>\n<ul>\n<li>&#x2F;etc&#x2F;gitconfig：全局配置（针对所有用户）</li>\n<li>~&#x2F;.gitconfig：全局配置（针对某个用户）</li>\n<li>.git&#x2F;config：局部配置（针对某个目录&#x2F;项目）</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"获取帮助\"><a href=\"#获取帮助\" class=\"headerlink\" title=\"获取帮助\"></a>获取帮助</h1><p>git help可以获取帮助，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --help <span class=\"comment\">//方式一</span></span><br><span class=\"line\">git help commit <span class=\"comment\">//方式二</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在工作目录中初始化新仓库\"><a href=\"#在工作目录中初始化新仓库\" class=\"headerlink\" title=\"在工作目录中初始化新仓库\"></a>在工作目录中初始化新仓库</h1><p>git init可以将任何目录转化为git版本库，使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>\n<h1 id=\"跟踪新文件\"><a href=\"#跟踪新文件\" class=\"headerlink\" title=\"跟踪新文件\"></a>跟踪新文件</h1><p>初始化后，我们在目录中增加一个README.md文件，如果要跟踪这个文件，那么执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add README.md</span><br></pre></td></tr></table></figure>\n\n<p>执行后，我们可以执行git status，可以看到，README.md已被跟踪起来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">file</span>:   README.md</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;init version&quot;</span></span><br><span class=\"line\">[master (root-commit) 4dfc094] init version</span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">1</span> insertion(+)</span><br><span class=\"line\"> create mode <span class=\"number\">100644</span> README.md</span><br></pre></td></tr></table></figure>\n\n<p>执行完，执行git status查看状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<p>下面我用简单gif动图进行示例git commit的效果：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;c2&quot;</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/7/162009ecae2b78b5?w=1024&h=768&f=gif&s=1022937\"></p>\n<h1 id=\"忽略某些文件\"><a href=\"#忽略某些文件\" class=\"headerlink\" title=\"忽略某些文件\"></a>忽略某些文件</h1><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表，比如说编译文件、日志、配置文件、环境文件等等，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式，看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 此为注释 – 将被 Git 忽略</span><br><span class=\"line\"># 忽略所有 .a 结尾的文件</span><br><span class=\"line\">*.a</span><br><span class=\"line\"># 但 lib.a 除外</span><br><span class=\"line\">!lib.a</span><br><span class=\"line\"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class=\"line\">/TODO</span><br><span class=\"line\"># 忽略 build/ 目录下的所有文件</span><br><span class=\"line\">build/</span><br><span class=\"line\"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class=\"line\">doc<span class=\"comment\">/*.txt</span></span><br><span class=\"line\"><span class=\"comment\"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span></span><br><span class=\"line\"><span class=\"comment\">doc/**/</span>*.txt</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><p>分支相关命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查看分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\"><span class=\"comment\">//新建分支</span></span><br><span class=\"line\">git branch bugFix</span><br><span class=\"line\">  bugFix</span><br><span class=\"line\">* master</span><br><span class=\"line\"><span class=\"comment\">//新建分支并切换到分支</span></span><br><span class=\"line\">git checkout -b bugFix</span><br><span class=\"line\">* bugFix</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n\n<p>下面我用简单gif动图进行示例git commit的效果：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch bugFix</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c2&quot;</span></span><br><span class=\"line\">git checkout bugFix</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/7/16200d5bc77b46e9?w=1024&h=768&f=gif&s=1120392\"></p>\n<blockquote>\n<p>相信大家对git的基础命令已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git基础篇–下》，主要介绍git merge与git rebase，敬请期待～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"初始化配置\"><a href=\"#初始化配置\" class=\"headerlink\" title=\"初始化配置\"></a>初始化配置</h1><p>我们安装了git之后，都要先配置以下git工作环境。git提供了git config的工具，专门用来配置或读取相应的工作环境变量。</p>\n<p>配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name <span class=\"string\">&quot;hellomypastor&quot;</span></span><br><span class=\"line\">git config --global user.email <span class=\"number\">18013963220</span>@<span class=\"number\">163.</span>com</span><br></pre></td></tr></table></figure>\n\n<p>查看配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --list <span class=\"comment\">//方式一</span></span><br><span class=\"line\">git config -l <span class=\"comment\">//方式二</span></span><br></pre></td></tr></table></figure>\n\n<p>这些配置一般会存在三个地方：</p>\n<ul>\n<li>&#x2F;etc&#x2F;gitconfig：全局配置（针对所有用户）</li>\n<li>~&#x2F;.gitconfig：全局配置（针对某个用户）</li>\n<li>.git&#x2F;config：局部配置（针对某个目录&#x2F;项目）</li>\n</ul>","more":"<h1 id=\"获取帮助\"><a href=\"#获取帮助\" class=\"headerlink\" title=\"获取帮助\"></a>获取帮助</h1><p>git help可以获取帮助，使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit --help <span class=\"comment\">//方式一</span></span><br><span class=\"line\">git help commit <span class=\"comment\">//方式二</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"在工作目录中初始化新仓库\"><a href=\"#在工作目录中初始化新仓库\" class=\"headerlink\" title=\"在工作目录中初始化新仓库\"></a>在工作目录中初始化新仓库</h1><p>git init可以将任何目录转化为git版本库，使用方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>\n<h1 id=\"跟踪新文件\"><a href=\"#跟踪新文件\" class=\"headerlink\" title=\"跟踪新文件\"></a>跟踪新文件</h1><p>初始化后，我们在目录中增加一个README.md文件，如果要跟踪这个文件，那么执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add README.md</span><br></pre></td></tr></table></figure>\n\n<p>执行后，我们可以执行git status，可以看到，README.md已被跟踪起来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\"></span><br><span class=\"line\">Initial commit</span><br><span class=\"line\"></span><br><span class=\"line\">Changes to be committed:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">file</span>:   README.md</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;init version&quot;</span></span><br><span class=\"line\">[master (root-commit) 4dfc094] init version</span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">1</span> insertion(+)</span><br><span class=\"line\"> create mode <span class=\"number\">100644</span> README.md</span><br></pre></td></tr></table></figure>\n\n<p>执行完，执行git status查看状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> On branch master</span><br><span class=\"line\">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>\n\n<p>下面我用简单gif动图进行示例git commit的效果：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&quot;c2&quot;</span></span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/7/162009ecae2b78b5?w=1024&h=768&f=gif&s=1022937\"></p>\n<h1 id=\"忽略某些文件\"><a href=\"#忽略某些文件\" class=\"headerlink\" title=\"忽略某些文件\"></a>忽略某些文件</h1><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表，比如说编译文件、日志、配置文件、环境文件等等，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式，看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 此为注释 – 将被 Git 忽略</span><br><span class=\"line\"># 忽略所有 .a 结尾的文件</span><br><span class=\"line\">*.a</span><br><span class=\"line\"># 但 lib.a 除外</span><br><span class=\"line\">!lib.a</span><br><span class=\"line\"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class=\"line\">/TODO</span><br><span class=\"line\"># 忽略 build/ 目录下的所有文件</span><br><span class=\"line\">build/</span><br><span class=\"line\"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class=\"line\">doc<span class=\"comment\">/*.txt</span></span><br><span class=\"line\"><span class=\"comment\"># 忽略 doc/ 目录下所有扩展名为 txt 的文件</span></span><br><span class=\"line\"><span class=\"comment\">doc/**/</span>*.txt</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><p>分支相关命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查看分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\"><span class=\"comment\">//新建分支</span></span><br><span class=\"line\">git branch bugFix</span><br><span class=\"line\">  bugFix</span><br><span class=\"line\">* master</span><br><span class=\"line\"><span class=\"comment\">//新建分支并切换到分支</span></span><br><span class=\"line\">git checkout -b bugFix</span><br><span class=\"line\">* bugFix</span><br><span class=\"line\">  master</span><br></pre></td></tr></table></figure>\n\n<p>下面我用简单gif动图进行示例git commit的效果：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch bugFix</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c2&quot;</span></span><br><span class=\"line\">git checkout bugFix</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;c3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/7/16200d5bc77b46e9?w=1024&h=768&f=gif&s=1120392\"></p>\n<blockquote>\n<p>相信大家对git的基础命令已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git基础篇–下》，主要介绍git merge与git rebase，敬请期待～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git基础篇--下）","date":"2018-03-10T23:48:00.000Z","_content":"在上一篇中，介绍了git的初始化配置配置、获取帮助、初始化仓库、跟踪新文件、提交、忽略某些文件，以及分支，具体文章：[如何克服解决Git冲突的恐惧症？（Git基础篇--上）](http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/)，本篇将介绍分支合并相关的`git merge`与`git rebase`。\n\n# merge\n\n分支合并的方法一就是git merge，通过图示更容易理解：\n\n执行命令如下：\n\n```java\ngit merge bugFix\ngit checkout bugFix\ngit merge master\n```\n\n执行过程如下：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/8/1620636c82b68567?w=1024&h=768&f=gif&s=1432430)\n\n# rebase\n\n分支合并的方法二就是git rebase，通过图示更容易理解：\n\n执行命令如下：\n\n```java\ngit rebase master\n//下面两步只是示例，不建议使用\ngit checkout master\ngit rebase bugFix\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/8/16206385e6ce291b?w=1024&h=768&f=gif&s=2051942)\n\n<!--more-->\n\n# merge与rebase的对比\n\nMerge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点，另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。\n\nRebase最大的好处是你的项目历史会非常整洁。首先，它不像git merge 那样引入不必要的合并提交。其次，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用git log、git bisect和gitk来查看项目历史。\n\n不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。\n\n# rebase黄金法则\n\n当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase的黄金法则便是，绝不要在公共的分支上使用它。\n\n# rebase冲突解决\n\n假设有两个分支，master与bugFix：\n\nmaster分支的README.md文件内容如下：\n\n```java\n史培培\n```\n\nbugFix分支的README.md文件内容如下：\n\n```java\n码上论剑\n\n欢迎关注我的公众号\n\nhttp://hellomypastor.net\n```\n\n在bugFix分支执行如下命令：\n\n```java\ngit pull --rebase\n```\n\n发现冲突：\n\n```java\n<<<<<<< HEAD\n史培培\n=======\n码上论剑\n\n欢迎关注我的公众号\n\nhttp://hellomypastor.net\n>>>>>>> init\n```\n\n解决冲突之后，执行：\n\n```java\ngit add README.md\ngit rebase --continue\n```\n\n这样就解决冲突了，是不是很简单？\n\n# 建议\n\n用pull --rebase，而不用pull（默认merge），这样的话在pull的时候就自行在本地解决两路冲突，而不是merge的时候麻烦的多路merge，这才是git的正确使用方式。\n\n\n> 相信大家对git的基础已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git分支管理策略》，主要介绍git分支的管理相关内容，敬请期待～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git基础篇-下）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git基础篇--下）\ndate: 2018-03-11 07:48:00\ncategories: Git\ntags: [Git]\n---\n在上一篇中，介绍了git的初始化配置配置、获取帮助、初始化仓库、跟踪新文件、提交、忽略某些文件，以及分支，具体文章：[如何克服解决Git冲突的恐惧症？（Git基础篇--上）](http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/)，本篇将介绍分支合并相关的`git merge`与`git rebase`。\n\n# merge\n\n分支合并的方法一就是git merge，通过图示更容易理解：\n\n执行命令如下：\n\n```java\ngit merge bugFix\ngit checkout bugFix\ngit merge master\n```\n\n执行过程如下：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/8/1620636c82b68567?w=1024&h=768&f=gif&s=1432430)\n\n# rebase\n\n分支合并的方法二就是git rebase，通过图示更容易理解：\n\n执行命令如下：\n\n```java\ngit rebase master\n//下面两步只是示例，不建议使用\ngit checkout master\ngit rebase bugFix\n```\n\n执行过程如下：\n\n![](https://user-gold-cdn.xitu.io/2018/3/8/16206385e6ce291b?w=1024&h=768&f=gif&s=2051942)\n\n<!--more-->\n\n# merge与rebase的对比\n\nMerge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点，另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。\n\nRebase最大的好处是你的项目历史会非常整洁。首先，它不像git merge 那样引入不必要的合并提交。其次，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用git log、git bisect和gitk来查看项目历史。\n\n不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。\n\n# rebase黄金法则\n\n当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase的黄金法则便是，绝不要在公共的分支上使用它。\n\n# rebase冲突解决\n\n假设有两个分支，master与bugFix：\n\nmaster分支的README.md文件内容如下：\n\n```java\n史培培\n```\n\nbugFix分支的README.md文件内容如下：\n\n```java\n码上论剑\n\n欢迎关注我的公众号\n\nhttp://hellomypastor.net\n```\n\n在bugFix分支执行如下命令：\n\n```java\ngit pull --rebase\n```\n\n发现冲突：\n\n```java\n<<<<<<< HEAD\n史培培\n=======\n码上论剑\n\n欢迎关注我的公众号\n\nhttp://hellomypastor.net\n>>>>>>> init\n```\n\n解决冲突之后，执行：\n\n```java\ngit add README.md\ngit rebase --continue\n```\n\n这样就解决冲突了，是不是很简单？\n\n# 建议\n\n用pull --rebase，而不用pull（默认merge），这样的话在pull的时候就自行在本地解决两路冲突，而不是merge的时候麻烦的多路merge，这才是git的正确使用方式。\n\n\n> 相信大家对git的基础已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git分支管理策略》，主要介绍git分支的管理相关内容，敬请期待～","slug":"如何克服解决Git冲突的恐惧症？（Git基础篇-下）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2w003brz5m5fhhe7rw","content":"<p>在上一篇中，介绍了git的初始化配置配置、获取帮助、初始化仓库、跟踪新文件、提交、忽略某些文件，以及分支，具体文章：<a href=\"http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–上）</a>，本篇将介绍分支合并相关的<code>git merge</code>与<code>git rebase</code>。</p>\n<h1 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h1><p>分支合并的方法一就是git merge，通过图示更容易理解：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge bugFix</span><br><span class=\"line\">git checkout bugFix</span><br><span class=\"line\">git merge master</span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/8/1620636c82b68567?w=1024&h=768&f=gif&s=1432430\"></p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>分支合并的方法二就是git rebase，通过图示更容易理解：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase master</span><br><span class=\"line\"><span class=\"comment\">//下面两步只是示例，不建议使用</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git rebase bugFix</span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/8/16206385e6ce291b?w=1024&h=768&f=gif&s=2051942\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"merge与rebase的对比\"><a href=\"#merge与rebase的对比\" class=\"headerlink\" title=\"merge与rebase的对比\"></a>merge与rebase的对比</h1><p>Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点，另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p>\n<p>Rebase最大的好处是你的项目历史会非常整洁。首先，它不像git merge 那样引入不必要的合并提交。其次，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用git log、git bisect和gitk来查看项目历史。</p>\n<p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。</p>\n<h1 id=\"rebase黄金法则\"><a href=\"#rebase黄金法则\" class=\"headerlink\" title=\"rebase黄金法则\"></a>rebase黄金法则</h1><p>当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase的黄金法则便是，绝不要在公共的分支上使用它。</p>\n<h1 id=\"rebase冲突解决\"><a href=\"#rebase冲突解决\" class=\"headerlink\" title=\"rebase冲突解决\"></a>rebase冲突解决</h1><p>假设有两个分支，master与bugFix：</p>\n<p>master分支的README.md文件内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">史培培</span><br></pre></td></tr></table></figure>\n\n<p>bugFix分支的README.md文件内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">码上论剑</span><br><span class=\"line\"></span><br><span class=\"line\">欢迎关注我的公众号</span><br><span class=\"line\"></span><br><span class=\"line\">http:<span class=\"comment\">//hellomypastor.net</span></span><br></pre></td></tr></table></figure>\n\n<p>在bugFix分支执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n\n<p>发现冲突：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">史培培</span><br><span class=\"line\">=======</span><br><span class=\"line\">码上论剑</span><br><span class=\"line\"></span><br><span class=\"line\">欢迎关注我的公众号</span><br><span class=\"line\"></span><br><span class=\"line\">http:<span class=\"comment\">//hellomypastor.net</span></span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; init</span><br></pre></td></tr></table></figure>\n\n<p>解决冲突之后，执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add README.md</span><br><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就解决冲突了，是不是很简单？</p>\n<h1 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h1><p>用pull –rebase，而不用pull（默认merge），这样的话在pull的时候就自行在本地解决两路冲突，而不是merge的时候麻烦的多路merge，这才是git的正确使用方式。</p>\n<blockquote>\n<p>相信大家对git的基础已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git分支管理策略》，主要介绍git分支的管理相关内容，敬请期待～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在上一篇中，介绍了git的初始化配置配置、获取帮助、初始化仓库、跟踪新文件、提交、忽略某些文件，以及分支，具体文章：<a href=\"http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–上）</a>，本篇将介绍分支合并相关的<code>git merge</code>与<code>git rebase</code>。</p>\n<h1 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h1><p>分支合并的方法一就是git merge，通过图示更容易理解：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge bugFix</span><br><span class=\"line\">git checkout bugFix</span><br><span class=\"line\">git merge master</span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/8/1620636c82b68567?w=1024&h=768&f=gif&s=1432430\"></p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>分支合并的方法二就是git rebase，通过图示更容易理解：</p>\n<p>执行命令如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase master</span><br><span class=\"line\"><span class=\"comment\">//下面两步只是示例，不建议使用</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git rebase bugFix</span><br></pre></td></tr></table></figure>\n\n<p>执行过程如下：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/8/16206385e6ce291b?w=1024&h=768&f=gif&s=2051942\"></p>","more":"<h1 id=\"merge与rebase的对比\"><a href=\"#merge与rebase的对比\" class=\"headerlink\" title=\"merge与rebase的对比\"></a>merge与rebase的对比</h1><p>Merge好在它是一个安全的操作。现有的分支不会被更改，避免了rebase潜在的缺点，另一方面，这同样意味着每次合并上游更改时feature分支都会引入一个外来的合并提交。如果master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的git log选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p>\n<p>Rebase最大的好处是你的项目历史会非常整洁。首先，它不像git merge 那样引入不必要的合并提交。其次，rebase导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的Fork。这让你更容易使用git log、git bisect和gitk来查看项目历史。</p>\n<p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了Rebase黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase不会有合并提交中附带的信息——你看不到feature分支中并入了上游的哪些更改。</p>\n<h1 id=\"rebase黄金法则\"><a href=\"#rebase黄金法则\" class=\"headerlink\" title=\"rebase黄金法则\"></a>rebase黄金法则</h1><p>当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase的黄金法则便是，绝不要在公共的分支上使用它。</p>\n<h1 id=\"rebase冲突解决\"><a href=\"#rebase冲突解决\" class=\"headerlink\" title=\"rebase冲突解决\"></a>rebase冲突解决</h1><p>假设有两个分支，master与bugFix：</p>\n<p>master分支的README.md文件内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">史培培</span><br></pre></td></tr></table></figure>\n\n<p>bugFix分支的README.md文件内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">码上论剑</span><br><span class=\"line\"></span><br><span class=\"line\">欢迎关注我的公众号</span><br><span class=\"line\"></span><br><span class=\"line\">http:<span class=\"comment\">//hellomypastor.net</span></span><br></pre></td></tr></table></figure>\n\n<p>在bugFix分支执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase</span><br></pre></td></tr></table></figure>\n\n<p>发现冲突：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">史培培</span><br><span class=\"line\">=======</span><br><span class=\"line\">码上论剑</span><br><span class=\"line\"></span><br><span class=\"line\">欢迎关注我的公众号</span><br><span class=\"line\"></span><br><span class=\"line\">http:<span class=\"comment\">//hellomypastor.net</span></span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; init</span><br></pre></td></tr></table></figure>\n\n<p>解决冲突之后，执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add README.md</span><br><span class=\"line\">git rebase --<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就解决冲突了，是不是很简单？</p>\n<h1 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h1><p>用pull –rebase，而不用pull（默认merge），这样的话在pull的时候就自行在本地解决两路冲突，而不是merge的时候麻烦的多路merge，这才是git的正确使用方式。</p>\n<blockquote>\n<p>相信大家对git的基础已经基本掌握，不妨在自己的git环境中动手试一试，下篇将讲述《Git分支管理策略》，主要介绍git分支的管理相关内容，敬请期待～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git杂项）","date":"2018-03-18T23:57:02.000Z","_content":">上篇介绍了如何克服解决Git冲突的恐惧症？（Git移交提交记录），本篇我们将介绍Git杂项。\n\n# 只取一个记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个Bug的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把bugFix分支里的工作合并回master分支了。\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ebd4ba0a682d?w=265&h=440&f=png&s=17602)\n\n你可以选择通过fast-forward快速合并到master分支上，但这样的话master分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让Git复制解决问题的那一个提交记录就可以了。跟之前我们在“移交提交记录”中学到的一样，我们可以使用：\n\n+ git rebase -i\n+ git cherry-pick\n\n解决上述问题，可以使用如下命令：\n\n```java\ngit checkout master\ngit cherry-pick C4\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ebc5edb02b72?w=521&h=383&f=png&s=18511)\n\n<!--more-->\n\n# 提交的技巧1\n\n接下来这种情况也是很常见的：你之前在newImage分支上进行了一次提交，然后又基于它创建了caption分支，然后又提交了一次。\n\n此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下newImage中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n先用git rebase -i将提交重新排序，然后把我们想要修改的提交记录挪到最前，然后用commit --amend来进行一些小修改，接着再用git rebase -i来将他们调回原来的顺序，最后我们把master移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n当然完成这个任务的方法不止上面提到的一种（我知道你在看cherry-pick啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ec77b1f1581e?w=290&h=363&f=png&s=15262)\n\n```java\ngit rebase -i caption~2 --aboveAll\ngit commit --amend\ngit rebase -i caption~2 --aboveAll\ngit branch -f master caption\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ec9f9437b47d?w=557&h=398&f=png&s=17946)\n\n最后有必要说明一下目标状态中的那几个'，我们把这个提交移动了两次，每移动一次会产生一个'；而C2上多出来的那个是我们在使用了amend参数提交时产生的，所以最终结果就是这样了。\n\n# 提交的技巧2\n\n我们可以使用rebase -i对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用--amend修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由rebase而导致的冲突。下面还是看看git cherry-pick是怎么做的吧。\n\n要在心里牢记cherry-pick可以将提交树上任何地方的提交记录取过来追加到HEAD上（只要不是HEAD上游的提交就没问题）。\n\n来看看这个例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ecac0755a3d9?w=290&h=363&f=png&s=15262)\n\n```java\ngit checkout master\ngit cherry-pick C2\ngit commit --amend\ngit cherry-pick C3\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623eccb6aa62d2a?w=556&h=383&f=png&s=19597)\n\n# Git Tag\n\n相信通过前面的例子你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。\n\n你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\n当然有了！Git的tag就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。\n\n更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\n咱们来看看标签到底是什么样：\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed1a2fea794e?w=270&h=363&f=png&s=11100)\n\n```java\ngit tag v0 C1\ngit tag v1 C2\n```\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed0ccb0f45ee?w=266&h=363&f=png&s=14176)\n\n# Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是git describe！\n\nGit Describe能帮你在提交历史中移动了多次以后找到方向；当你用git bisect（一个查找产生Bug的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时，可能会用到这个命令。\n\ngit describe的语法是：\n\n```java\ngit describe <ref>\n```\n\n<ref>可以是任何能被Git识别成提交记录的引用，如果你没有指定的话，Git会以你目前所检出的位置（HEAD）。\n\n它输出的结果是这样的：\n\n```java\n<tag>_<numCommits>_g<hash>\n```\n\ntag表示的是离ref最近的标签，numCommits是表示这个ref与tag相差有多少个提交记录，hash表示的是你所给定的ref所表示的提交记录哈希值的前几位。\n\n当ref提交记录上有某个标签时，则只输出标签名称。\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed57a725d7b6?w=507&h=383&f=png&s=18847)\n\n```java\ngit describe master\n//输出\nv1_2_gC2\n\ngit describe side\n//输出\nv2_1_gC4\n```\n\n>相信大家对Git杂项已经基本掌握，不妨在自己的git环境中动手试一试吧～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git杂项）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git杂项）\ndate: 2018-03-19 07:57:02\ncategories: Git\ntags: [Git]\n---\n>上篇介绍了如何克服解决Git冲突的恐惧症？（Git移交提交记录），本篇我们将介绍Git杂项。\n\n# 只取一个记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个Bug的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把bugFix分支里的工作合并回master分支了。\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ebd4ba0a682d?w=265&h=440&f=png&s=17602)\n\n你可以选择通过fast-forward快速合并到master分支上，但这样的话master分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让Git复制解决问题的那一个提交记录就可以了。跟之前我们在“移交提交记录”中学到的一样，我们可以使用：\n\n+ git rebase -i\n+ git cherry-pick\n\n解决上述问题，可以使用如下命令：\n\n```java\ngit checkout master\ngit cherry-pick C4\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ebc5edb02b72?w=521&h=383&f=png&s=18511)\n\n<!--more-->\n\n# 提交的技巧1\n\n接下来这种情况也是很常见的：你之前在newImage分支上进行了一次提交，然后又基于它创建了caption分支，然后又提交了一次。\n\n此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下newImage中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n先用git rebase -i将提交重新排序，然后把我们想要修改的提交记录挪到最前，然后用commit --amend来进行一些小修改，接着再用git rebase -i来将他们调回原来的顺序，最后我们把master移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n当然完成这个任务的方法不止上面提到的一种（我知道你在看cherry-pick啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ec77b1f1581e?w=290&h=363&f=png&s=15262)\n\n```java\ngit rebase -i caption~2 --aboveAll\ngit commit --amend\ngit rebase -i caption~2 --aboveAll\ngit branch -f master caption\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ec9f9437b47d?w=557&h=398&f=png&s=17946)\n\n最后有必要说明一下目标状态中的那几个'，我们把这个提交移动了两次，每移动一次会产生一个'；而C2上多出来的那个是我们在使用了amend参数提交时产生的，所以最终结果就是这样了。\n\n# 提交的技巧2\n\n我们可以使用rebase -i对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用--amend修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由rebase而导致的冲突。下面还是看看git cherry-pick是怎么做的吧。\n\n要在心里牢记cherry-pick可以将提交树上任何地方的提交记录取过来追加到HEAD上（只要不是HEAD上游的提交就没问题）。\n\n来看看这个例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ecac0755a3d9?w=290&h=363&f=png&s=15262)\n\n```java\ngit checkout master\ngit cherry-pick C2\ngit commit --amend\ngit cherry-pick C3\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623eccb6aa62d2a?w=556&h=383&f=png&s=19597)\n\n# Git Tag\n\n相信通过前面的例子你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。\n\n你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\n当然有了！Git的tag就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。\n\n更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\n咱们来看看标签到底是什么样：\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed1a2fea794e?w=270&h=363&f=png&s=11100)\n\n```java\ngit tag v0 C1\ngit tag v1 C2\n```\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed0ccb0f45ee?w=266&h=363&f=png&s=14176)\n\n# Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是git describe！\n\nGit Describe能帮你在提交历史中移动了多次以后找到方向；当你用git bisect（一个查找产生Bug的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时，可能会用到这个命令。\n\ngit describe的语法是：\n\n```java\ngit describe <ref>\n```\n\n<ref>可以是任何能被Git识别成提交记录的引用，如果你没有指定的话，Git会以你目前所检出的位置（HEAD）。\n\n它输出的结果是这样的：\n\n```java\n<tag>_<numCommits>_g<hash>\n```\n\ntag表示的是离ref最近的标签，numCommits是表示这个ref与tag相差有多少个提交记录，hash表示的是你所给定的ref所表示的提交记录哈希值的前几位。\n\n当ref提交记录上有某个标签时，则只输出标签名称。\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/19/1623ed57a725d7b6?w=507&h=383&f=png&s=18847)\n\n```java\ngit describe master\n//输出\nv1_2_gC2\n\ngit describe side\n//输出\nv2_1_gC4\n```\n\n>相信大家对Git杂项已经基本掌握，不妨在自己的git环境中动手试一试吧～","slug":"如何克服解决Git冲突的恐惧症？（Git杂项）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2x003grz5me7ylh4eu","content":"<blockquote>\n<p>上篇介绍了如何克服解决Git冲突的恐惧症？（Git移交提交记录），本篇我们将介绍Git杂项。</p>\n</blockquote>\n<h1 id=\"只取一个记录\"><a href=\"#只取一个记录\" class=\"headerlink\" title=\"只取一个记录\"></a>只取一个记录</h1><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个Bug的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把bugFix分支里的工作合并回master分支了。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ebd4ba0a682d?w=265&h=440&f=png&s=17602\"></p>\n<p>你可以选择通过fast-forward快速合并到master分支上，但这样的话master分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让Git复制解决问题的那一个提交记录就可以了。跟之前我们在“移交提交记录”中学到的一样，我们可以使用：</p>\n<ul>\n<li>git rebase -i</li>\n<li>git cherry-pick</li>\n</ul>\n<p>解决上述问题，可以使用如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git cherry-pick C4</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ebc5edb02b72?w=521&h=383&f=png&s=18511\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"提交的技巧1\"><a href=\"#提交的技巧1\" class=\"headerlink\" title=\"提交的技巧1\"></a>提交的技巧1</h1><p>接下来这种情况也是很常见的：你之前在newImage分支上进行了一次提交，然后又基于它创建了caption分支，然后又提交了一次。</p>\n<p>此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下newImage中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<p>先用git rebase -i将提交重新排序，然后把我们想要修改的提交记录挪到最前，然后用commit –amend来进行一些小修改，接着再用git rebase -i来将他们调回原来的顺序，最后我们把master移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</p>\n<p>当然完成这个任务的方法不止上面提到的一种（我知道你在看cherry-pick啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ec77b1f1581e?w=290&h=363&f=png&s=15262\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i caption~<span class=\"number\">2</span> --aboveAll</span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\">git rebase -i caption~<span class=\"number\">2</span> --aboveAll</span><br><span class=\"line\">git branch -f master caption</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ec9f9437b47d?w=557&h=398&f=png&s=17946\"></p>\n<p>最后有必要说明一下目标状态中的那几个’，我们把这个提交移动了两次，每移动一次会产生一个’；而C2上多出来的那个是我们在使用了amend参数提交时产生的，所以最终结果就是这样了。</p>\n<h1 id=\"提交的技巧2\"><a href=\"#提交的技巧2\" class=\"headerlink\" title=\"提交的技巧2\"></a>提交的技巧2</h1><p>我们可以使用rebase -i对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用–amend修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由rebase而导致的冲突。下面还是看看git cherry-pick是怎么做的吧。</p>\n<p>要在心里牢记cherry-pick可以将提交树上任何地方的提交记录取过来追加到HEAD上（只要不是HEAD上游的提交就没问题）。</p>\n<p>来看看这个例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ecac0755a3d9?w=290&h=363&f=png&s=15262\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git cherry-pick C2</span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\">git cherry-pick C3</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623eccb6aa62d2a?w=556&h=383&f=png&s=19597\"></p>\n<h1 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h1><p>相信通过前面的例子你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>\n<p>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>当然有了！Git的tag就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>\n<p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>咱们来看看标签到底是什么样：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed1a2fea794e?w=270&h=363&f=png&s=11100\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v0 C1</span><br><span class=\"line\">git tag v1 C2</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed0ccb0f45ee?w=266&h=363&f=png&s=14176\"></p>\n<h1 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h1><p>由于标签在代码库中起着“锚点”的作用，Git还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是git describe！</p>\n<p>Git Describe能帮你在提交历史中移动了多次以后找到方向；当你用git bisect（一个查找产生Bug的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时，可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>\n\n<p><ref>可以是任何能被Git识别成提交记录的引用，如果你没有指定的话，Git会以你目前所检出的位置（HEAD）。</p>\n<p>它输出的结果是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure>\n\n<p>tag表示的是离ref最近的标签，numCommits是表示这个ref与tag相差有多少个提交记录，hash表示的是你所给定的ref所表示的提交记录哈希值的前几位。</p>\n<p>当ref提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed57a725d7b6?w=507&h=383&f=png&s=18847\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe master</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">v1_2_gC2</span><br><span class=\"line\"></span><br><span class=\"line\">git describe side</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">v2_1_gC4</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相信大家对Git杂项已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上篇介绍了如何克服解决Git冲突的恐惧症？（Git移交提交记录），本篇我们将介绍Git杂项。</p>\n</blockquote>\n<h1 id=\"只取一个记录\"><a href=\"#只取一个记录\" class=\"headerlink\" title=\"只取一个记录\"></a>只取一个记录</h1><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个Bug的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把bugFix分支里的工作合并回master分支了。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ebd4ba0a682d?w=265&h=440&f=png&s=17602\"></p>\n<p>你可以选择通过fast-forward快速合并到master分支上，但这样的话master分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让Git复制解决问题的那一个提交记录就可以了。跟之前我们在“移交提交记录”中学到的一样，我们可以使用：</p>\n<ul>\n<li>git rebase -i</li>\n<li>git cherry-pick</li>\n</ul>\n<p>解决上述问题，可以使用如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git cherry-pick C4</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ebc5edb02b72?w=521&h=383&f=png&s=18511\"></p>","more":"<h1 id=\"提交的技巧1\"><a href=\"#提交的技巧1\" class=\"headerlink\" title=\"提交的技巧1\"></a>提交的技巧1</h1><p>接下来这种情况也是很常见的：你之前在newImage分支上进行了一次提交，然后又基于它创建了caption分支，然后又提交了一次。</p>\n<p>此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下newImage中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<p>先用git rebase -i将提交重新排序，然后把我们想要修改的提交记录挪到最前，然后用commit –amend来进行一些小修改，接着再用git rebase -i来将他们调回原来的顺序，最后我们把master移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</p>\n<p>当然完成这个任务的方法不止上面提到的一种（我知道你在看cherry-pick啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ec77b1f1581e?w=290&h=363&f=png&s=15262\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase -i caption~<span class=\"number\">2</span> --aboveAll</span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\">git rebase -i caption~<span class=\"number\">2</span> --aboveAll</span><br><span class=\"line\">git branch -f master caption</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ec9f9437b47d?w=557&h=398&f=png&s=17946\"></p>\n<p>最后有必要说明一下目标状态中的那几个’，我们把这个提交移动了两次，每移动一次会产生一个’；而C2上多出来的那个是我们在使用了amend参数提交时产生的，所以最终结果就是这样了。</p>\n<h1 id=\"提交的技巧2\"><a href=\"#提交的技巧2\" class=\"headerlink\" title=\"提交的技巧2\"></a>提交的技巧2</h1><p>我们可以使用rebase -i对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用–amend修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由rebase而导致的冲突。下面还是看看git cherry-pick是怎么做的吧。</p>\n<p>要在心里牢记cherry-pick可以将提交树上任何地方的提交记录取过来追加到HEAD上（只要不是HEAD上游的提交就没问题）。</p>\n<p>来看看这个例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ecac0755a3d9?w=290&h=363&f=png&s=15262\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br><span class=\"line\">git cherry-pick C2</span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\">git cherry-pick C3</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623eccb6aa62d2a?w=556&h=383&f=png&s=19597\"></p>\n<h1 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h1><p>相信通过前面的例子你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>\n<p>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>当然有了！Git的tag就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>\n<p>更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>咱们来看看标签到底是什么样：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed1a2fea794e?w=270&h=363&f=png&s=11100\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag v0 C1</span><br><span class=\"line\">git tag v1 C2</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed0ccb0f45ee?w=266&h=363&f=png&s=14176\"></p>\n<h1 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h1><p>由于标签在代码库中起着“锚点”的作用，Git还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是git describe！</p>\n<p>Git Describe能帮你在提交历史中移动了多次以后找到方向；当你用git bisect（一个查找产生Bug的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时，可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>\n\n<p><ref>可以是任何能被Git识别成提交记录的引用，如果你没有指定的话，Git会以你目前所检出的位置（HEAD）。</p>\n<p>它输出的结果是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure>\n\n<p>tag表示的是离ref最近的标签，numCommits是表示这个ref与tag相差有多少个提交记录，hash表示的是你所给定的ref所表示的提交记录哈希值的前几位。</p>\n<p>当ref提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/19/1623ed57a725d7b6?w=507&h=383&f=png&s=18847\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git describe master</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">v1_2_gC2</span><br><span class=\"line\"></span><br><span class=\"line\">git describe side</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">v2_1_gC4</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相信大家对Git杂项已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git移交提交记录）","date":"2018-03-17T23:54:17.000Z","_content":"到现在我们已经学习了Git的基础知识，包括：\n\n+ [如何克服解决Git冲突的恐惧症？（序）](http://hellomypastor.net/2018/03/05/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88%E5%BA%8F%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git入门介绍）](http://hellomypastor.net/2018/03/06/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git基础篇--上）](http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git基础篇--下）](http://hellomypastor.net/2018/03/11/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8B%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git分支策略）](http://hellomypastor.net/2018/03/13/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git四大组件）](http://hellomypastor.net/2018/03/14/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git高级篇）](http://hellomypastor.net/2018/03/15/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/)\n\n概念涵盖了Git 90%的功能，同样也足够满足开发者的日常需求。\n\n> 然而, 剩余的10%在处理复杂的工作流时（或者当你陷入困惑时）可能就显示尤为重要了。\n\n接下来要讨论的这个话题是“整理提交记录” ：开发人员有时会说“`我想要把这个提交放到这里,那个提交放到刚才那个提交的后面`”, 而接下来就讲的就是它的实现方式，看起来挺复杂, 其实是个很简单的概念。\n\n<!--more-->\n\n# git cherry-pick\n\n第一个命令是`git cherry-pick`, 命令形式为:\n\n```java\ngit cherry-pick <提交号>...\n```\n\n如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，cherry-pick是最直接的方式了。我个人非常喜欢cherry-pick，因为它特别简单。\n\n咱们还是通过例子来看一下！\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 master 分支，你立刻想到了之前学过的`rebase`了吧？但是咱们还是看看 cherry-pick有什么本领吧。\n\n```java\ngit cherry-pick C2 C4\n```\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/18/1623974a20860eef?w=1024&h=768&f=gif&s=1838351)\n\n这就是了！我们只需要提交记录C2和C4，所以Git就将被它们抓过来放到当前分支下了，就是这么简单!\n\n# 交互式rebase\n\n当你你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用cherry-pick再好不过了，没有比这更简单的方式了。\n\n但是如果你不清楚你想要的提交记录的哈希值呢?\n\n幸好Git帮你想到了这一点, 我们可以利用交互式的rebase，如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了\n\n咱们具体来看一下：\n\n交互式rebase指的是使用带参数`--interactive`的rebase命令, 简写为`-i`\n\n如果你在命令后增加了这个选项, Git会打开一个UI界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的UI窗口一般会在文本编辑器：如Vim中打开一个文件。\n\n当rebase UI界面打开时, 你能做3件事:\n\n+ 调整提交记录的顺序\n+ 删除你不想要的提交\n+ 合并提交\n\n接下来看下具体命令：\n\n![](https://user-gold-cdn.xitu.io/2018/3/18/1623948b8b1e9de5?w=1490&h=874&f=png&s=345569)\n\n可以看到：\n\n+ p, pick = use commit\n+ r, reword = use commit, but edit the commit message\n+ e, edit = use commit, but stop for amending\n+ s, squash = use commit, but meld into previous commit\n+ f, fixup = like \"squash\", but discard this commit's log message\n+ x, exec = run command (the rest of the line) using shell\n+ d, drop = remove commit\n\n#### 拆分提交记录 edit\n\n更改子提交pick为edit，表示需要修改此次提交；然后reset到需要拆分的上次提交，但是保留工区的内容，再依次commit工作区中的内容。\n\n#### 合并提交记录 squash\n\n更改子提交 pick 为squash，表示与当前提交的父提交合并。\n\n#### 批量修改历史提交信息 reword\n\n更改子提交 pick 为reword，表示修改历史提交信息。\n\n#### 删除历史纪录\n\n修改pick为drop, 或者直接删除所在的行。\n\n>相信大家对Git移交提交记录已经基本掌握，不妨在自己的git环境中动手试一试吧～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git移交提交记录）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git移交提交记录）\ndate: 2018-03-18 07:54:17\ncategories: Git\ntags: [Git]\n---\n到现在我们已经学习了Git的基础知识，包括：\n\n+ [如何克服解决Git冲突的恐惧症？（序）](http://hellomypastor.net/2018/03/05/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88%E5%BA%8F%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git入门介绍）](http://hellomypastor.net/2018/03/06/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git基础篇--上）](http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git基础篇--下）](http://hellomypastor.net/2018/03/11/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8B%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git分支策略）](http://hellomypastor.net/2018/03/13/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git四大组件）](http://hellomypastor.net/2018/03/14/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%89/)\n+ [如何克服解决Git冲突的恐惧症？（Git高级篇）](http://hellomypastor.net/2018/03/15/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/)\n\n概念涵盖了Git 90%的功能，同样也足够满足开发者的日常需求。\n\n> 然而, 剩余的10%在处理复杂的工作流时（或者当你陷入困惑时）可能就显示尤为重要了。\n\n接下来要讨论的这个话题是“整理提交记录” ：开发人员有时会说“`我想要把这个提交放到这里,那个提交放到刚才那个提交的后面`”, 而接下来就讲的就是它的实现方式，看起来挺复杂, 其实是个很简单的概念。\n\n<!--more-->\n\n# git cherry-pick\n\n第一个命令是`git cherry-pick`, 命令形式为:\n\n```java\ngit cherry-pick <提交号>...\n```\n\n如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，cherry-pick是最直接的方式了。我个人非常喜欢cherry-pick，因为它特别简单。\n\n咱们还是通过例子来看一下！\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 master 分支，你立刻想到了之前学过的`rebase`了吧？但是咱们还是看看 cherry-pick有什么本领吧。\n\n```java\ngit cherry-pick C2 C4\n```\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/18/1623974a20860eef?w=1024&h=768&f=gif&s=1838351)\n\n这就是了！我们只需要提交记录C2和C4，所以Git就将被它们抓过来放到当前分支下了，就是这么简单!\n\n# 交互式rebase\n\n当你你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用cherry-pick再好不过了，没有比这更简单的方式了。\n\n但是如果你不清楚你想要的提交记录的哈希值呢?\n\n幸好Git帮你想到了这一点, 我们可以利用交互式的rebase，如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了\n\n咱们具体来看一下：\n\n交互式rebase指的是使用带参数`--interactive`的rebase命令, 简写为`-i`\n\n如果你在命令后增加了这个选项, Git会打开一个UI界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的UI窗口一般会在文本编辑器：如Vim中打开一个文件。\n\n当rebase UI界面打开时, 你能做3件事:\n\n+ 调整提交记录的顺序\n+ 删除你不想要的提交\n+ 合并提交\n\n接下来看下具体命令：\n\n![](https://user-gold-cdn.xitu.io/2018/3/18/1623948b8b1e9de5?w=1490&h=874&f=png&s=345569)\n\n可以看到：\n\n+ p, pick = use commit\n+ r, reword = use commit, but edit the commit message\n+ e, edit = use commit, but stop for amending\n+ s, squash = use commit, but meld into previous commit\n+ f, fixup = like \"squash\", but discard this commit's log message\n+ x, exec = run command (the rest of the line) using shell\n+ d, drop = remove commit\n\n#### 拆分提交记录 edit\n\n更改子提交pick为edit，表示需要修改此次提交；然后reset到需要拆分的上次提交，但是保留工区的内容，再依次commit工作区中的内容。\n\n#### 合并提交记录 squash\n\n更改子提交 pick 为squash，表示与当前提交的父提交合并。\n\n#### 批量修改历史提交信息 reword\n\n更改子提交 pick 为reword，表示修改历史提交信息。\n\n#### 删除历史纪录\n\n修改pick为drop, 或者直接删除所在的行。\n\n>相信大家对Git移交提交记录已经基本掌握，不妨在自己的git环境中动手试一试吧～","slug":"如何克服解决Git冲突的恐惧症？（Git移交提交记录）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2y003irz5mg9fl9gtk","content":"<p>到现在我们已经学习了Git的基础知识，包括：</p>\n<ul>\n<li><a href=\"http://hellomypastor.net/2018/03/05/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88%E5%BA%8F%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（序）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/06/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git入门介绍）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–上）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/11/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8B%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–下）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/13/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git分支策略）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/14/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git四大组件）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/15/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git高级篇）</a></li>\n</ul>\n<p>概念涵盖了Git 90%的功能，同样也足够满足开发者的日常需求。</p>\n<blockquote>\n<p>然而, 剩余的10%在处理复杂的工作流时（或者当你陷入困惑时）可能就显示尤为重要了。</p>\n</blockquote>\n<p>接下来要讨论的这个话题是“整理提交记录” ：开发人员有时会说“<code>我想要把这个提交放到这里,那个提交放到刚才那个提交的后面</code>”, 而接下来就讲的就是它的实现方式，看起来挺复杂, 其实是个很简单的概念。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h1><p>第一个命令是<code>git cherry-pick</code>, 命令形式为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;提交号&gt;...</span><br></pre></td></tr></table></figure>\n\n<p>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，cherry-pick是最直接的方式了。我个人非常喜欢cherry-pick，因为它特别简单。</p>\n<p>咱们还是通过例子来看一下！</p>\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 master 分支，你立刻想到了之前学过的<code>rebase</code>了吧？但是咱们还是看看 cherry-pick有什么本领吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/18/1623974a20860eef?w=1024&h=768&f=gif&s=1838351\"></p>\n<p>这就是了！我们只需要提交记录C2和C4，所以Git就将被它们抓过来放到当前分支下了，就是这么简单!</p>\n<h1 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h1><p>当你你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用cherry-pick再好不过了，没有比这更简单的方式了。</p>\n<p>但是如果你不清楚你想要的提交记录的哈希值呢?</p>\n<p>幸好Git帮你想到了这一点, 我们可以利用交互式的rebase，如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>\n<p>咱们具体来看一下：</p>\n<p>交互式rebase指的是使用带参数<code>--interactive</code>的rebase命令, 简写为<code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git会打开一个UI界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的UI窗口一般会在文本编辑器：如Vim中打开一个文件。</p>\n<p>当rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序</li>\n<li>删除你不想要的提交</li>\n<li>合并提交</li>\n</ul>\n<p>接下来看下具体命令：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/18/1623948b8b1e9de5?w=1490&h=874&f=png&s=345569\"></p>\n<p>可以看到：</p>\n<ul>\n<li>p, pick &#x3D; use commit</li>\n<li>r, reword &#x3D; use commit, but edit the commit message</li>\n<li>e, edit &#x3D; use commit, but stop for amending</li>\n<li>s, squash &#x3D; use commit, but meld into previous commit</li>\n<li>f, fixup &#x3D; like “squash”, but discard this commit’s log message</li>\n<li>x, exec &#x3D; run command (the rest of the line) using shell</li>\n<li>d, drop &#x3D; remove commit</li>\n</ul>\n<h4 id=\"拆分提交记录-edit\"><a href=\"#拆分提交记录-edit\" class=\"headerlink\" title=\"拆分提交记录 edit\"></a>拆分提交记录 edit</h4><p>更改子提交pick为edit，表示需要修改此次提交；然后reset到需要拆分的上次提交，但是保留工区的内容，再依次commit工作区中的内容。</p>\n<h4 id=\"合并提交记录-squash\"><a href=\"#合并提交记录-squash\" class=\"headerlink\" title=\"合并提交记录 squash\"></a>合并提交记录 squash</h4><p>更改子提交 pick 为squash，表示与当前提交的父提交合并。</p>\n<h4 id=\"批量修改历史提交信息-reword\"><a href=\"#批量修改历史提交信息-reword\" class=\"headerlink\" title=\"批量修改历史提交信息 reword\"></a>批量修改历史提交信息 reword</h4><p>更改子提交 pick 为reword，表示修改历史提交信息。</p>\n<h4 id=\"删除历史纪录\"><a href=\"#删除历史纪录\" class=\"headerlink\" title=\"删除历史纪录\"></a>删除历史纪录</h4><p>修改pick为drop, 或者直接删除所在的行。</p>\n<blockquote>\n<p>相信大家对Git移交提交记录已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>到现在我们已经学习了Git的基础知识，包括：</p>\n<ul>\n<li><a href=\"http://hellomypastor.net/2018/03/05/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88%E5%BA%8F%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（序）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/06/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git入门介绍）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/07/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8A%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–上）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/11/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%8B%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git基础篇–下）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/13/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git分支策略）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/14/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git四大组件）</a></li>\n<li><a href=\"http://hellomypastor.net/2018/03/15/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%A7%A3%E5%86%B3Git%E5%86%B2%E7%AA%81%E7%9A%84%E6%81%90%E6%83%A7%E7%97%87%EF%BC%9F%EF%BC%88Git%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/\">如何克服解决Git冲突的恐惧症？（Git高级篇）</a></li>\n</ul>\n<p>概念涵盖了Git 90%的功能，同样也足够满足开发者的日常需求。</p>\n<blockquote>\n<p>然而, 剩余的10%在处理复杂的工作流时（或者当你陷入困惑时）可能就显示尤为重要了。</p>\n</blockquote>\n<p>接下来要讨论的这个话题是“整理提交记录” ：开发人员有时会说“<code>我想要把这个提交放到这里,那个提交放到刚才那个提交的后面</code>”, 而接下来就讲的就是它的实现方式，看起来挺复杂, 其实是个很简单的概念。</p>","more":"<h1 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h1><p>第一个命令是<code>git cherry-pick</code>, 命令形式为:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick &lt;提交号&gt;...</span><br></pre></td></tr></table></figure>\n\n<p>如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，cherry-pick是最直接的方式了。我个人非常喜欢cherry-pick，因为它特别简单。</p>\n<p>咱们还是通过例子来看一下！</p>\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 master 分支，你立刻想到了之前学过的<code>rebase</code>了吧？但是咱们还是看看 cherry-pick有什么本领吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/18/1623974a20860eef?w=1024&h=768&f=gif&s=1838351\"></p>\n<p>这就是了！我们只需要提交记录C2和C4，所以Git就将被它们抓过来放到当前分支下了，就是这么简单!</p>\n<h1 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h1><p>当你你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时, 用cherry-pick再好不过了，没有比这更简单的方式了。</p>\n<p>但是如果你不清楚你想要的提交记录的哈希值呢?</p>\n<p>幸好Git帮你想到了这一点, 我们可以利用交互式的rebase，如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>\n<p>咱们具体来看一下：</p>\n<p>交互式rebase指的是使用带参数<code>--interactive</code>的rebase命令, 简写为<code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git会打开一个UI界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的UI窗口一般会在文本编辑器：如Vim中打开一个文件。</p>\n<p>当rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序</li>\n<li>删除你不想要的提交</li>\n<li>合并提交</li>\n</ul>\n<p>接下来看下具体命令：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/18/1623948b8b1e9de5?w=1490&h=874&f=png&s=345569\"></p>\n<p>可以看到：</p>\n<ul>\n<li>p, pick &#x3D; use commit</li>\n<li>r, reword &#x3D; use commit, but edit the commit message</li>\n<li>e, edit &#x3D; use commit, but stop for amending</li>\n<li>s, squash &#x3D; use commit, but meld into previous commit</li>\n<li>f, fixup &#x3D; like “squash”, but discard this commit’s log message</li>\n<li>x, exec &#x3D; run command (the rest of the line) using shell</li>\n<li>d, drop &#x3D; remove commit</li>\n</ul>\n<h4 id=\"拆分提交记录-edit\"><a href=\"#拆分提交记录-edit\" class=\"headerlink\" title=\"拆分提交记录 edit\"></a>拆分提交记录 edit</h4><p>更改子提交pick为edit，表示需要修改此次提交；然后reset到需要拆分的上次提交，但是保留工区的内容，再依次commit工作区中的内容。</p>\n<h4 id=\"合并提交记录-squash\"><a href=\"#合并提交记录-squash\" class=\"headerlink\" title=\"合并提交记录 squash\"></a>合并提交记录 squash</h4><p>更改子提交 pick 为squash，表示与当前提交的父提交合并。</p>\n<h4 id=\"批量修改历史提交信息-reword\"><a href=\"#批量修改历史提交信息-reword\" class=\"headerlink\" title=\"批量修改历史提交信息 reword\"></a>批量修改历史提交信息 reword</h4><p>更改子提交 pick 为reword，表示修改历史提交信息。</p>\n<h4 id=\"删除历史纪录\"><a href=\"#删除历史纪录\" class=\"headerlink\" title=\"删除历史纪录\"></a>删除历史纪录</h4><p>修改pick为drop, 或者直接删除所在的行。</p>\n<blockquote>\n<p>相信大家对Git移交提交记录已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git高级篇）","date":"2018-03-14T23:53:00.000Z","_content":"# HEAD\n\nHEAD是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的Git命令都是从改变HEAD的指向开始的。\n\n我们可以通过下面这张图来理解：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162142f49d2f9674?w=612&h=296&f=png&s=11639)\n\nHEAD->master->C1，HEAD指向master， master指向C1\n\nHEAD通常情况下是指向分支名的（如bugFix）。在你提交时，改变了 bugFix的状态，这一变化通过HEAD变得可见。\n\n如果想看HEAD指向，可以通过cat .git/HEAD查看，如果HEAD指向的是一个引用，还可以用git symbolic-ref HEAD查看它的指向。\n\n<!--more-->\n\n# 分离HEAD\n\n分离的HEAD就是让其指向了某个具体的提交记录而不是分支名。\n\n当我们执行`git checkout C4`命令时，效果如下gif图所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162142236a8bc2eb?w=1024&h=768&f=gif&s=1633733)\n\n>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。\n\n# 相对引用\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n+ 使用`^`向上移动1个提交记录\n+ 使用`~<num>`向上移动多个提交记录，如`~3`\n\n### 相对引用（^）\n\n把操作符（^）加在引用名称的后面，表示让Git寻找指定提交记录的父提交。\n\n所以，`master^`相当于“master的父节点”，`master^^`是master的第二个父节点。\n\n执行`git checkout master^`，具体效果如下gif所示：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162143bfb7d3144f?w=1024&h=768&f=gif&s=1716110)\n\n### 相对引用（~）\n\n如果你想在提交树中向上移动很多步的话，敲那么多`^`貌似也挺烦人的，Git当然也考虑到了这一点，于是又引入了操作符`~`。\n\n该操作符后面可以跟一个数字（可选，不跟数字时与`^ 相同`，向上移动一次），指定向上移动多少次。\n\n执行`git checkout master~2`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162143deeea90019?w=1024&h=768&f=gif&s=1658391)\n\n# 撤销变更\n\n在Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更：\n\n+ git reset\n+ git revert。\n\n接下来咱们逐个进行讲解：\n\n### git reset\n\ngit reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset向上移动分支，原来指向的提交记录就跟从来没有提交过一样。\n\n虽然在你的本地分支中使用git reset很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！\n\n执行`git reset master^`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/1621445bce1c92c9?w=1024&h=768&f=gif&s=1446124)\n\n### git revert\n\n为了撤销更改并分享给别人，我们需要使用git revert。\n\n执行`git revert master^`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162153f22cc880a6?w=1024&h=768&f=gif&s=1549282)\n\n奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录C2'引入了更改，这些更改刚好是用来撤销C2这个提交的。也就是说C2'的状态与C1是相同的。\n\nrevert之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n>相信大家对git的高级篇已经基本掌握，不妨在自己的git环境中动手试一试吧～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git高级篇）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git高级篇）\ndate: 2018-03-15 07:53:00\ncategories: Git\ntags: [Git]\n---\n# HEAD\n\nHEAD是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的Git命令都是从改变HEAD的指向开始的。\n\n我们可以通过下面这张图来理解：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162142f49d2f9674?w=612&h=296&f=png&s=11639)\n\nHEAD->master->C1，HEAD指向master， master指向C1\n\nHEAD通常情况下是指向分支名的（如bugFix）。在你提交时，改变了 bugFix的状态，这一变化通过HEAD变得可见。\n\n如果想看HEAD指向，可以通过cat .git/HEAD查看，如果HEAD指向的是一个引用，还可以用git symbolic-ref HEAD查看它的指向。\n\n<!--more-->\n\n# 分离HEAD\n\n分离的HEAD就是让其指向了某个具体的提交记录而不是分支名。\n\n当我们执行`git checkout C4`命令时，效果如下gif图所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162142236a8bc2eb?w=1024&h=768&f=gif&s=1633733)\n\n>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。\n\n# 相对引用\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n+ 使用`^`向上移动1个提交记录\n+ 使用`~<num>`向上移动多个提交记录，如`~3`\n\n### 相对引用（^）\n\n把操作符（^）加在引用名称的后面，表示让Git寻找指定提交记录的父提交。\n\n所以，`master^`相当于“master的父节点”，`master^^`是master的第二个父节点。\n\n执行`git checkout master^`，具体效果如下gif所示：\n\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162143bfb7d3144f?w=1024&h=768&f=gif&s=1716110)\n\n### 相对引用（~）\n\n如果你想在提交树中向上移动很多步的话，敲那么多`^`貌似也挺烦人的，Git当然也考虑到了这一点，于是又引入了操作符`~`。\n\n该操作符后面可以跟一个数字（可选，不跟数字时与`^ 相同`，向上移动一次），指定向上移动多少次。\n\n执行`git checkout master~2`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162143deeea90019?w=1024&h=768&f=gif&s=1658391)\n\n# 撤销变更\n\n在Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更：\n\n+ git reset\n+ git revert。\n\n接下来咱们逐个进行讲解：\n\n### git reset\n\ngit reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset向上移动分支，原来指向的提交记录就跟从来没有提交过一样。\n\n虽然在你的本地分支中使用git reset很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！\n\n执行`git reset master^`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/1621445bce1c92c9?w=1024&h=768&f=gif&s=1446124)\n\n### git revert\n\n为了撤销更改并分享给别人，我们需要使用git revert。\n\n执行`git revert master^`，具体效果如下gif所示：\n\n![](https://user-gold-cdn.xitu.io/2018/3/11/162153f22cc880a6?w=1024&h=768&f=gif&s=1549282)\n\n奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录C2'引入了更改，这些更改刚好是用来撤销C2这个提交的。也就是说C2'的状态与C1是相同的。\n\nrevert之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n>相信大家对git的高级篇已经基本掌握，不妨在自己的git环境中动手试一试吧～","slug":"如何克服解决Git冲突的恐惧症？（Git高级篇）","published":1,"updated":"2025-03-07T13:26:47.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz2z003nrz5m4acdbyoj","content":"<h1 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a>HEAD</h1><p>HEAD是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的Git命令都是从改变HEAD的指向开始的。</p>\n<p>我们可以通过下面这张图来理解：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162142f49d2f9674?w=612&h=296&f=png&s=11639\"></p>\n<p>HEAD-&gt;master-&gt;C1，HEAD指向master， master指向C1</p>\n<p>HEAD通常情况下是指向分支名的（如bugFix）。在你提交时，改变了 bugFix的状态，这一变化通过HEAD变得可见。</p>\n<p>如果想看HEAD指向，可以通过cat .git&#x2F;HEAD查看，如果HEAD指向的是一个引用，还可以用git symbolic-ref HEAD查看它的指向。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h1><p>分离的HEAD就是让其指向了某个具体的提交记录而不是分支名。</p>\n<p>当我们执行<code>git checkout C4</code>命令时，效果如下gif图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162142236a8bc2eb?w=1024&h=768&f=gif&s=1633733\"></p>\n<blockquote>\n<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。</p>\n</blockquote>\n<h1 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用\"></a>相对引用</h1><p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用<code>^</code>向上移动1个提交记录</li>\n<li>使用<code>~&lt;num&gt;</code>向上移动多个提交记录，如<code>~3</code></li>\n</ul>\n<h3 id=\"相对引用（-）\"><a href=\"#相对引用（-）\" class=\"headerlink\" title=\"相对引用（^）\"></a>相对引用（^）</h3><p>把操作符（^）加在引用名称的后面，表示让Git寻找指定提交记录的父提交。</p>\n<p>所以，<code>master^</code>相当于“master的父节点”，<code>master^^</code>是master的第二个父节点。</p>\n<p>执行<code>git checkout master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162143bfb7d3144f?w=1024&h=768&f=gif&s=1716110\"></p>\n<h3 id=\"相对引用（-）-1\"><a href=\"#相对引用（-）-1\" class=\"headerlink\" title=\"相对引用（~）\"></a>相对引用（~）</h3><p>如果你想在提交树中向上移动很多步的话，敲那么多<code>^</code>貌似也挺烦人的，Git当然也考虑到了这一点，于是又引入了操作符<code>~</code>。</p>\n<p>该操作符后面可以跟一个数字（可选，不跟数字时与<code>^ 相同</code>，向上移动一次），指定向上移动多少次。</p>\n<p>执行<code>git checkout master~2</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162143deeea90019?w=1024&h=768&f=gif&s=1658391\"></p>\n<h1 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h1><p>在Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更：</p>\n<ul>\n<li>git reset</li>\n<li>git revert。</li>\n</ul>\n<p>接下来咱们逐个进行讲解：</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>\n<p>虽然在你的本地分支中使用git reset很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p>\n<p>执行<code>git reset master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/1621445bce1c92c9?w=1024&h=768&f=gif&s=1446124\"></p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h3><p>为了撤销更改并分享给别人，我们需要使用git revert。</p>\n<p>执行<code>git revert master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162153f22cc880a6?w=1024&h=768&f=gif&s=1549282\"></p>\n<p>奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录C2’引入了更改，这些更改刚好是用来撤销C2这个提交的。也就是说C2’的状态与C1是相同的。</p>\n<p>revert之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<blockquote>\n<p>相信大家对git的高级篇已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"HEAD\"><a href=\"#HEAD\" class=\"headerlink\" title=\"HEAD\"></a>HEAD</h1><p>HEAD是一个对当前检出记录的符号引用，也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的Git命令都是从改变HEAD的指向开始的。</p>\n<p>我们可以通过下面这张图来理解：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162142f49d2f9674?w=612&h=296&f=png&s=11639\"></p>\n<p>HEAD-&gt;master-&gt;C1，HEAD指向master， master指向C1</p>\n<p>HEAD通常情况下是指向分支名的（如bugFix）。在你提交时，改变了 bugFix的状态，这一变化通过HEAD变得可见。</p>\n<p>如果想看HEAD指向，可以通过cat .git&#x2F;HEAD查看，如果HEAD指向的是一个引用，还可以用git symbolic-ref HEAD查看它的指向。</p>","more":"<h1 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h1><p>分离的HEAD就是让其指向了某个具体的提交记录而不是分支名。</p>\n<p>当我们执行<code>git checkout C4</code>命令时，效果如下gif图所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162142236a8bc2eb?w=1024&h=768&f=gif&s=1633733\"></p>\n<blockquote>\n<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。</p>\n</blockquote>\n<h1 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用\"></a>相对引用</h1><p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用<code>^</code>向上移动1个提交记录</li>\n<li>使用<code>~&lt;num&gt;</code>向上移动多个提交记录，如<code>~3</code></li>\n</ul>\n<h3 id=\"相对引用（-）\"><a href=\"#相对引用（-）\" class=\"headerlink\" title=\"相对引用（^）\"></a>相对引用（^）</h3><p>把操作符（^）加在引用名称的后面，表示让Git寻找指定提交记录的父提交。</p>\n<p>所以，<code>master^</code>相当于“master的父节点”，<code>master^^</code>是master的第二个父节点。</p>\n<p>执行<code>git checkout master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162143bfb7d3144f?w=1024&h=768&f=gif&s=1716110\"></p>\n<h3 id=\"相对引用（-）-1\"><a href=\"#相对引用（-）-1\" class=\"headerlink\" title=\"相对引用（~）\"></a>相对引用（~）</h3><p>如果你想在提交树中向上移动很多步的话，敲那么多<code>^</code>貌似也挺烦人的，Git当然也考虑到了这一点，于是又引入了操作符<code>~</code>。</p>\n<p>该操作符后面可以跟一个数字（可选，不跟数字时与<code>^ 相同</code>，向上移动一次），指定向上移动多少次。</p>\n<p>执行<code>git checkout master~2</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162143deeea90019?w=1024&h=768&f=gif&s=1658391\"></p>\n<h1 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h1><p>在Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更：</p>\n<ul>\n<li>git reset</li>\n<li>git revert。</li>\n</ul>\n<p>接下来咱们逐个进行讲解：</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>\n<p>虽然在你的本地分支中使用git reset很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p>\n<p>执行<code>git reset master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/1621445bce1c92c9?w=1024&h=768&f=gif&s=1446124\"></p>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h3><p>为了撤销更改并分享给别人，我们需要使用git revert。</p>\n<p>执行<code>git revert master^</code>，具体效果如下gif所示：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/11/162153f22cc880a6?w=1024&h=768&f=gif&s=1549282\"></p>\n<p>奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录C2’引入了更改，这些更改刚好是用来撤销C2这个提交的。也就是说C2’的状态与C1是相同的。</p>\n<p>revert之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<blockquote>\n<p>相信大家对git的高级篇已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（Git高级话题）","date":"2018-03-19T23:55:41.000Z","_content":"# 多分支rebase\n\n多分支的情况下，我们往往希望得到有序的提交历史，看下面的例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243be85bfa1d62?w=880&h=419&f=png&s=26832)\n\n执行如下步骤进行多分支rebase：\n\n```java\ngit rebase master bugFix\ngit rebase bugFix side\ngit rebase side another\ngit rebase another master\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243c2acbce1666?w=273&h=669&f=png&s=24669)\n\n<!--more-->\n\n# 两个父节点\n\n操作符`^`与`~`符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与~后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit默认选择合并提交的“第一个”父提交，在操作符^后跟一个数字可以改变这一默认行为。\n\n废话不多说，举个例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243ca0a2420e26?w=532&h=555&f=png&s=23445)\n\n```java\n//链式操作\ngit branch bugWork master~^2~\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243cb3f790e8f5?w=673&h=555&f=png&s=27729)\n\n# 纠缠不清的分支\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243cf4b1a4eabc?w=264&h=517&f=png&s=18476)\n\n如上图，现在我们的master分支是比one、two和three要多几个提交。出于某种原因，我们需要把master分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。\n\none需要重新排序并删除C5，two仅需要重排排序，而three只需要提交一次。\n\n执行如下命令：\n\n```java\ngit checkout one\ngit cherry-pick C4 C3 C2\ngit checkout two\ngit cherry-pick C5 C4 C3 C2\ngit branch -f three C2\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243e68de653a4f?w=636&h=517&f=png&s=34988)\n\n>相信大家对Git高级话题已经基本掌握，不妨在自己的git环境中动手试一试吧～","source":"_posts/如何克服解决Git冲突的恐惧症？（Git高级话题）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（Git高级话题）\ndate: 2018-03-20 07:55:41\ncategories: Git\ntags: [Git]\n---\n# 多分支rebase\n\n多分支的情况下，我们往往希望得到有序的提交历史，看下面的例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243be85bfa1d62?w=880&h=419&f=png&s=26832)\n\n执行如下步骤进行多分支rebase：\n\n```java\ngit rebase master bugFix\ngit rebase bugFix side\ngit rebase side another\ngit rebase another master\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243c2acbce1666?w=273&h=669&f=png&s=24669)\n\n<!--more-->\n\n# 两个父节点\n\n操作符`^`与`~`符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与~后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit默认选择合并提交的“第一个”父提交，在操作符^后跟一个数字可以改变这一默认行为。\n\n废话不多说，举个例子：\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243ca0a2420e26?w=532&h=555&f=png&s=23445)\n\n```java\n//链式操作\ngit branch bugWork master~^2~\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243cb3f790e8f5?w=673&h=555&f=png&s=27729)\n\n# 纠缠不清的分支\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243cf4b1a4eabc?w=264&h=517&f=png&s=18476)\n\n如上图，现在我们的master分支是比one、two和three要多几个提交。出于某种原因，我们需要把master分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。\n\none需要重新排序并删除C5，two仅需要重排排序，而three只需要提交一次。\n\n执行如下命令：\n\n```java\ngit checkout one\ngit cherry-pick C4 C3 C2\ngit checkout two\ngit cherry-pick C5 C4 C3 C2\ngit branch -f three C2\n```\n\n![](https://user-gold-cdn.xitu.io/2018/3/20/16243e68de653a4f?w=636&h=517&f=png&s=34988)\n\n>相信大家对Git高级话题已经基本掌握，不妨在自己的git环境中动手试一试吧～","slug":"如何克服解决Git冲突的恐惧症？（Git高级话题）","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz30003qrz5m53u81000","content":"<h1 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h1><p>多分支的情况下，我们往往希望得到有序的提交历史，看下面的例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243be85bfa1d62?w=880&h=419&f=png&s=26832\"></p>\n<p>执行如下步骤进行多分支rebase：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase master bugFix</span><br><span class=\"line\">git rebase bugFix side</span><br><span class=\"line\">git rebase side another</span><br><span class=\"line\">git rebase another master</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243c2acbce1666?w=273&h=669&f=png&s=24669\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h1><p>操作符<code>^</code>与<code>~</code>符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与~后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git默认选择合并提交的“第一个”父提交，在操作符^后跟一个数字可以改变这一默认行为。</p>\n<p>废话不多说，举个例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243ca0a2420e26?w=532&h=555&f=png&s=23445\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//链式操作</span></span><br><span class=\"line\">git branch bugWork master~^<span class=\"number\">2</span>~</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243cb3f790e8f5?w=673&h=555&f=png&s=27729\"></p>\n<h1 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h1><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243cf4b1a4eabc?w=264&h=517&f=png&s=18476\"></p>\n<p>如上图，现在我们的master分支是比one、two和three要多几个提交。出于某种原因，我们需要把master分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p>\n<p>one需要重新排序并删除C5，two仅需要重排排序，而three只需要提交一次。</p>\n<p>执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout one</span><br><span class=\"line\">git cherry-pick C4 C3 C2</span><br><span class=\"line\">git checkout two</span><br><span class=\"line\">git cherry-pick C5 C4 C3 C2</span><br><span class=\"line\">git branch -f three C2</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e68de653a4f?w=636&h=517&f=png&s=34988\"></p>\n<blockquote>\n<p>相信大家对Git高级话题已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h1><p>多分支的情况下，我们往往希望得到有序的提交历史，看下面的例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243be85bfa1d62?w=880&h=419&f=png&s=26832\"></p>\n<p>执行如下步骤进行多分支rebase：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rebase master bugFix</span><br><span class=\"line\">git rebase bugFix side</span><br><span class=\"line\">git rebase side another</span><br><span class=\"line\">git rebase another master</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243c2acbce1666?w=273&h=669&f=png&s=24669\"></p>","more":"<h1 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h1><p>操作符<code>^</code>与<code>~</code>符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与~后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git默认选择合并提交的“第一个”父提交，在操作符^后跟一个数字可以改变这一默认行为。</p>\n<p>废话不多说，举个例子：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243ca0a2420e26?w=532&h=555&f=png&s=23445\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//链式操作</span></span><br><span class=\"line\">git branch bugWork master~^<span class=\"number\">2</span>~</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243cb3f790e8f5?w=673&h=555&f=png&s=27729\"></p>\n<h1 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h1><p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243cf4b1a4eabc?w=264&h=517&f=png&s=18476\"></p>\n<p>如上图，现在我们的master分支是比one、two和three要多几个提交。出于某种原因，我们需要把master分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。</p>\n<p>one需要重新排序并删除C5，two仅需要重排排序，而three只需要提交一次。</p>\n<p>执行如下命令：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout one</span><br><span class=\"line\">git cherry-pick C4 C3 C2</span><br><span class=\"line\">git checkout two</span><br><span class=\"line\">git cherry-pick C5 C4 C3 C2</span><br><span class=\"line\">git branch -f three C2</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/3/20/16243e68de653a4f?w=636&h=517&f=png&s=34988\"></p>\n<blockquote>\n<p>相信大家对Git高级话题已经基本掌握，不妨在自己的git环境中动手试一试吧～</p>\n</blockquote>"},{"title":"如何克服解决Git冲突的恐惧症？（序）","date":"2018-03-04T23:43:06.000Z","_content":">不知道大家有没有这样的经历呢？\n\n在大学期间，我们经常会有课程设计，比如C++程序设计，比如设计一个俄罗斯方块程序，那么我们会怎么做呢？先在自己电脑上开发调试好，然后到了机房给老师演示到时候呢，用`U盘`拷到机房的电脑上，然后给老师演示，后来想了想，其实这样也没什么毛病，毕竟一个人。\n\n后来随着课程设计越来越大、越来越难，一个人几乎不能完成（`大神`可以^_^），那么就几个人一组啦，那么如何协作呢？如果是两个人，那么可以在一台电脑上开发（`结对开发`），多个人的时候呢？用U盘？呵呵哒...于是我们想到了用版本控制，用什么好呢？\n\n>Svn？Github？Gitlab？GitOsChina（当时还是http://git.oschina.net，现在已经变成了https://gitee.com）？\n\n后来决定用GitOsChina，因为免费，且可以创建私有仓库，那么问题来了，如何说服大家用Git呢？\n\n...（此处省略1万字）\n\n我费了十分大的力气说服他们使用 Git并教会他们基本的操作。但是使用Git不可避免的会产生编辑冲突，可是大家都害怕冲突、害怕解决冲突，可能是觉得解决冲突太麻烦了，解决不好还可能会丢失代码，说出来都是血和泪啊。\n\n>那么有没有好的方法或者是好的工具能克服解决Git冲突的恐惧症呢？\n\n<!--more-->\n\n#### 关键方法->减少冲突：\n\n要减少冲突（即将它扼杀在萌芽阶段，/捂脸），关键在于组织和分工、沟通和习惯，如果架构设计耦合太多、分工有交叉、沟通少，那么无论用什么版本控制工具都不能解决冲突的问题；\n\n#### 治标方法->立竿见影：\n\n“熟练掌握reflog+reset”告诉你后悔药是如何吃的，这就跟学车是一样的道理，一定要先学会踩刹车，心里才有底。不过，初次接触 reflog 的界面的童鞋很可能会不太熟悉，不知道怎么退出去，不要害怕，谷歌会给你答案。\n\n#### 治本方法->壮胆神药：\n\n掌握Git基础和原理\n\n#### 辅助方法->开门见山：\n\n装个好的前端比如`SourceTree`，一般性的操作，都可以不用指令，出了错有UI界面，解决冲突时只需动动鼠标，轻松加写意。\n\n>那么从下篇文章开始，我将带领大家一步一步炼出壮胆神药，敬请期待～","source":"_posts/如何克服解决Git冲突的恐惧症？（序）.md","raw":"title: 如何克服解决Git冲突的恐惧症？（序）\ndate: 2018-03-05 07:43:06\ncategories: Git\ntags: [Git]\n---\n>不知道大家有没有这样的经历呢？\n\n在大学期间，我们经常会有课程设计，比如C++程序设计，比如设计一个俄罗斯方块程序，那么我们会怎么做呢？先在自己电脑上开发调试好，然后到了机房给老师演示到时候呢，用`U盘`拷到机房的电脑上，然后给老师演示，后来想了想，其实这样也没什么毛病，毕竟一个人。\n\n后来随着课程设计越来越大、越来越难，一个人几乎不能完成（`大神`可以^_^），那么就几个人一组啦，那么如何协作呢？如果是两个人，那么可以在一台电脑上开发（`结对开发`），多个人的时候呢？用U盘？呵呵哒...于是我们想到了用版本控制，用什么好呢？\n\n>Svn？Github？Gitlab？GitOsChina（当时还是http://git.oschina.net，现在已经变成了https://gitee.com）？\n\n后来决定用GitOsChina，因为免费，且可以创建私有仓库，那么问题来了，如何说服大家用Git呢？\n\n...（此处省略1万字）\n\n我费了十分大的力气说服他们使用 Git并教会他们基本的操作。但是使用Git不可避免的会产生编辑冲突，可是大家都害怕冲突、害怕解决冲突，可能是觉得解决冲突太麻烦了，解决不好还可能会丢失代码，说出来都是血和泪啊。\n\n>那么有没有好的方法或者是好的工具能克服解决Git冲突的恐惧症呢？\n\n<!--more-->\n\n#### 关键方法->减少冲突：\n\n要减少冲突（即将它扼杀在萌芽阶段，/捂脸），关键在于组织和分工、沟通和习惯，如果架构设计耦合太多、分工有交叉、沟通少，那么无论用什么版本控制工具都不能解决冲突的问题；\n\n#### 治标方法->立竿见影：\n\n“熟练掌握reflog+reset”告诉你后悔药是如何吃的，这就跟学车是一样的道理，一定要先学会踩刹车，心里才有底。不过，初次接触 reflog 的界面的童鞋很可能会不太熟悉，不知道怎么退出去，不要害怕，谷歌会给你答案。\n\n#### 治本方法->壮胆神药：\n\n掌握Git基础和原理\n\n#### 辅助方法->开门见山：\n\n装个好的前端比如`SourceTree`，一般性的操作，都可以不用指令，出了错有UI界面，解决冲突时只需动动鼠标，轻松加写意。\n\n>那么从下篇文章开始，我将带领大家一步一步炼出壮胆神药，敬请期待～","slug":"如何克服解决Git冲突的恐惧症？（序）","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz31003trz5m9g1j1ej7","content":"<blockquote>\n<p>不知道大家有没有这样的经历呢？</p>\n</blockquote>\n<p>在大学期间，我们经常会有课程设计，比如C++程序设计，比如设计一个俄罗斯方块程序，那么我们会怎么做呢？先在自己电脑上开发调试好，然后到了机房给老师演示到时候呢，用<code>U盘</code>拷到机房的电脑上，然后给老师演示，后来想了想，其实这样也没什么毛病，毕竟一个人。</p>\n<p>后来随着课程设计越来越大、越来越难，一个人几乎不能完成（<code>大神</code>可以^_^），那么就几个人一组啦，那么如何协作呢？如果是两个人，那么可以在一台电脑上开发（<code>结对开发</code>），多个人的时候呢？用U盘？呵呵哒…于是我们想到了用版本控制，用什么好呢？</p>\n<blockquote>\n<p>Svn？Github？Gitlab？GitOsChina（当时还是<a href=\"http://git.oschina.net,现在已经变成了https//gitee.com%EF%BC%89%EF%BC%9F\">http://git.oschina.net，现在已经变成了https://gitee.com）？</a></p>\n</blockquote>\n<p>后来决定用GitOsChina，因为免费，且可以创建私有仓库，那么问题来了，如何说服大家用Git呢？</p>\n<p>…（此处省略1万字）</p>\n<p>我费了十分大的力气说服他们使用 Git并教会他们基本的操作。但是使用Git不可避免的会产生编辑冲突，可是大家都害怕冲突、害怕解决冲突，可能是觉得解决冲突太麻烦了，解决不好还可能会丢失代码，说出来都是血和泪啊。</p>\n<blockquote>\n<p>那么有没有好的方法或者是好的工具能克服解决Git冲突的恐惧症呢？</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h4 id=\"关键方法-gt-减少冲突：\"><a href=\"#关键方法-gt-减少冲突：\" class=\"headerlink\" title=\"关键方法-&gt;减少冲突：\"></a>关键方法-&gt;减少冲突：</h4><p>要减少冲突（即将它扼杀在萌芽阶段，&#x2F;捂脸），关键在于组织和分工、沟通和习惯，如果架构设计耦合太多、分工有交叉、沟通少，那么无论用什么版本控制工具都不能解决冲突的问题；</p>\n<h4 id=\"治标方法-gt-立竿见影：\"><a href=\"#治标方法-gt-立竿见影：\" class=\"headerlink\" title=\"治标方法-&gt;立竿见影：\"></a>治标方法-&gt;立竿见影：</h4><p>“熟练掌握reflog+reset”告诉你后悔药是如何吃的，这就跟学车是一样的道理，一定要先学会踩刹车，心里才有底。不过，初次接触 reflog 的界面的童鞋很可能会不太熟悉，不知道怎么退出去，不要害怕，谷歌会给你答案。</p>\n<h4 id=\"治本方法-gt-壮胆神药：\"><a href=\"#治本方法-gt-壮胆神药：\" class=\"headerlink\" title=\"治本方法-&gt;壮胆神药：\"></a>治本方法-&gt;壮胆神药：</h4><p>掌握Git基础和原理</p>\n<h4 id=\"辅助方法-gt-开门见山：\"><a href=\"#辅助方法-gt-开门见山：\" class=\"headerlink\" title=\"辅助方法-&gt;开门见山：\"></a>辅助方法-&gt;开门见山：</h4><p>装个好的前端比如<code>SourceTree</code>，一般性的操作，都可以不用指令，出了错有UI界面，解决冲突时只需动动鼠标，轻松加写意。</p>\n<blockquote>\n<p>那么从下篇文章开始，我将带领大家一步一步炼出壮胆神药，敬请期待～</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>不知道大家有没有这样的经历呢？</p>\n</blockquote>\n<p>在大学期间，我们经常会有课程设计，比如C++程序设计，比如设计一个俄罗斯方块程序，那么我们会怎么做呢？先在自己电脑上开发调试好，然后到了机房给老师演示到时候呢，用<code>U盘</code>拷到机房的电脑上，然后给老师演示，后来想了想，其实这样也没什么毛病，毕竟一个人。</p>\n<p>后来随着课程设计越来越大、越来越难，一个人几乎不能完成（<code>大神</code>可以^_^），那么就几个人一组啦，那么如何协作呢？如果是两个人，那么可以在一台电脑上开发（<code>结对开发</code>），多个人的时候呢？用U盘？呵呵哒…于是我们想到了用版本控制，用什么好呢？</p>\n<blockquote>\n<p>Svn？Github？Gitlab？GitOsChina（当时还是<a href=\"http://git.oschina.net,现在已经变成了https//gitee.com%EF%BC%89%EF%BC%9F\">http://git.oschina.net，现在已经变成了https://gitee.com）？</a></p>\n</blockquote>\n<p>后来决定用GitOsChina，因为免费，且可以创建私有仓库，那么问题来了，如何说服大家用Git呢？</p>\n<p>…（此处省略1万字）</p>\n<p>我费了十分大的力气说服他们使用 Git并教会他们基本的操作。但是使用Git不可避免的会产生编辑冲突，可是大家都害怕冲突、害怕解决冲突，可能是觉得解决冲突太麻烦了，解决不好还可能会丢失代码，说出来都是血和泪啊。</p>\n<blockquote>\n<p>那么有没有好的方法或者是好的工具能克服解决Git冲突的恐惧症呢？</p>\n</blockquote>","more":"<h4 id=\"关键方法-gt-减少冲突：\"><a href=\"#关键方法-gt-减少冲突：\" class=\"headerlink\" title=\"关键方法-&gt;减少冲突：\"></a>关键方法-&gt;减少冲突：</h4><p>要减少冲突（即将它扼杀在萌芽阶段，&#x2F;捂脸），关键在于组织和分工、沟通和习惯，如果架构设计耦合太多、分工有交叉、沟通少，那么无论用什么版本控制工具都不能解决冲突的问题；</p>\n<h4 id=\"治标方法-gt-立竿见影：\"><a href=\"#治标方法-gt-立竿见影：\" class=\"headerlink\" title=\"治标方法-&gt;立竿见影：\"></a>治标方法-&gt;立竿见影：</h4><p>“熟练掌握reflog+reset”告诉你后悔药是如何吃的，这就跟学车是一样的道理，一定要先学会踩刹车，心里才有底。不过，初次接触 reflog 的界面的童鞋很可能会不太熟悉，不知道怎么退出去，不要害怕，谷歌会给你答案。</p>\n<h4 id=\"治本方法-gt-壮胆神药：\"><a href=\"#治本方法-gt-壮胆神药：\" class=\"headerlink\" title=\"治本方法-&gt;壮胆神药：\"></a>治本方法-&gt;壮胆神药：</h4><p>掌握Git基础和原理</p>\n<h4 id=\"辅助方法-gt-开门见山：\"><a href=\"#辅助方法-gt-开门见山：\" class=\"headerlink\" title=\"辅助方法-&gt;开门见山：\"></a>辅助方法-&gt;开门见山：</h4><p>装个好的前端比如<code>SourceTree</code>，一般性的操作，都可以不用指令，出了错有UI界面，解决冲突时只需动动鼠标，轻松加写意。</p>\n<blockquote>\n<p>那么从下篇文章开始，我将带领大家一步一步炼出壮胆神药，敬请期待～</p>\n</blockquote>"},{"title":"微信公众号企业付款","date":"2015-11-05T15:47:16.000Z","type":"tags","_content":"近期做微信公众号开发，由于`企业向微信用户个人发现金红包`的功能有金额限制`（1~200）`，而且有时间限制`（0~8点间不能发红包）`，于是就改用`企业向用户付款`的功能，实现过程总结如下。\n- 请求Url：https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers\n- 是否需要证书：是\n- 请求方式：POST\n<!--more-->\n- 数据示例\n```xml\n<xml>\n  <mch_appid>wxe062425f740c30d8</mch_appid>\n  <mchid>10000098</mchid>\n  <nonce_str>3PG2J4ILTKCH16CQ2502SI8ZNMTM67VS</nonce_str>\n  <partner_trade_no>100000982014120919616</partner_trade_no>\n  <openid>ohO4Gt7wVPxIT1A9GjFaMYMiZY1s</openid>\n  <check_name>OPTION_CHECK</check_name>\n  <re_user_name>张三</re_user_name>\n  <amount>100</amount>\n  <desc>节日快乐!</desc>\n  <spbill_create_ip>10.2.3.10</spbill_create_ip>\n  <sign>C97BDBACF37622775366F38B629F45E3</sign>\n</xml>\n```\n- 具体java代码实现和发现金红包类似\n下面对比一下发现金红包与企业付款：\n- 发送频率规则\n现金红包：`每分钟`发送红包不超过`1800`个；北`京时间0：00-8：00`不触发红包赠送；\n企业付款：无\n- 金额规则\n现金红包：单个红包金额介于`[1.00元，200.00元]`之间；同一个红包只能发送给一个用户\n企业付款：给同一个`非实名用户`付款，单笔单日限额`2000`；给同一个`实名用户`付款，单笔单日限额`2W`；\n- 到账规则\n现金红包：以发红包的形式，用户需`打开红包`才能将钱存到个人钱包的零钱中\n企业付款：`直接`到个人钱包的零钱中","source":"_posts/微信公众号企业付款.md","raw":"title: \"微信公众号企业付款\"\ndate: 2015-11-05 23:47:16\ntype: \"tags\"\ntags: [微信公众平台开发,Java]\n---\n近期做微信公众号开发，由于`企业向微信用户个人发现金红包`的功能有金额限制`（1~200）`，而且有时间限制`（0~8点间不能发红包）`，于是就改用`企业向用户付款`的功能，实现过程总结如下。\n- 请求Url：https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers\n- 是否需要证书：是\n- 请求方式：POST\n<!--more-->\n- 数据示例\n```xml\n<xml>\n  <mch_appid>wxe062425f740c30d8</mch_appid>\n  <mchid>10000098</mchid>\n  <nonce_str>3PG2J4ILTKCH16CQ2502SI8ZNMTM67VS</nonce_str>\n  <partner_trade_no>100000982014120919616</partner_trade_no>\n  <openid>ohO4Gt7wVPxIT1A9GjFaMYMiZY1s</openid>\n  <check_name>OPTION_CHECK</check_name>\n  <re_user_name>张三</re_user_name>\n  <amount>100</amount>\n  <desc>节日快乐!</desc>\n  <spbill_create_ip>10.2.3.10</spbill_create_ip>\n  <sign>C97BDBACF37622775366F38B629F45E3</sign>\n</xml>\n```\n- 具体java代码实现和发现金红包类似\n下面对比一下发现金红包与企业付款：\n- 发送频率规则\n现金红包：`每分钟`发送红包不超过`1800`个；北`京时间0：00-8：00`不触发红包赠送；\n企业付款：无\n- 金额规则\n现金红包：单个红包金额介于`[1.00元，200.00元]`之间；同一个红包只能发送给一个用户\n企业付款：给同一个`非实名用户`付款，单笔单日限额`2000`；给同一个`实名用户`付款，单笔单日限额`2W`；\n- 到账规则\n现金红包：以发红包的形式，用户需`打开红包`才能将钱存到个人钱包的零钱中\n企业付款：`直接`到个人钱包的零钱中","slug":"微信公众号企业付款","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz31003wrz5mgtd9bo8a","content":"<p>近期做微信公众号开发，由于<code>企业向微信用户个人发现金红包</code>的功能有金额限制<code>（1~200）</code>，而且有时间限制<code>（0~8点间不能发红包）</code>，于是就改用<code>企业向用户付款</code>的功能，实现过程总结如下。</p>\n<ul>\n<li>请求Url：<a href=\"https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers\">https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers</a></li>\n<li>是否需要证书：是</li>\n<li>请求方式：POST<span id=\"more\"></span></li>\n<li>数据示例<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xml</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_appid</span>&gt;</span>wxe062425f740c30d8<span class=\"tag\">&lt;/<span class=\"name\">mch_appid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mchid</span>&gt;</span>10000098<span class=\"tag\">&lt;/<span class=\"name\">mchid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nonce_str</span>&gt;</span>3PG2J4ILTKCH16CQ2502SI8ZNMTM67VS<span class=\"tag\">&lt;/<span class=\"name\">nonce_str</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">partner_trade_no</span>&gt;</span>100000982014120919616<span class=\"tag\">&lt;/<span class=\"name\">partner_trade_no</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">openid</span>&gt;</span>ohO4Gt7wVPxIT1A9GjFaMYMiZY1s<span class=\"tag\">&lt;/<span class=\"name\">openid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">check_name</span>&gt;</span>OPTION_CHECK<span class=\"tag\">&lt;/<span class=\"name\">check_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">re_user_name</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">re_user_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">amount</span>&gt;</span>100<span class=\"tag\">&lt;/<span class=\"name\">amount</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>节日快乐!<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">spbill_create_ip</span>&gt;</span>10.2.3.10<span class=\"tag\">&lt;/<span class=\"name\">spbill_create_ip</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sign</span>&gt;</span>C97BDBACF37622775366F38B629F45E3<span class=\"tag\">&lt;/<span class=\"name\">sign</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>具体java代码实现和发现金红包类似<br>下面对比一下发现金红包与企业付款：</li>\n<li>发送频率规则<br>现金红包：<code>每分钟</code>发送红包不超过<code>1800</code>个；北<code>京时间0：00-8：00</code>不触发红包赠送；<br>企业付款：无</li>\n<li>金额规则<br>现金红包：单个红包金额介于<code>[1.00元，200.00元]</code>之间；同一个红包只能发送给一个用户<br>企业付款：给同一个<code>非实名用户</code>付款，单笔单日限额<code>2000</code>；给同一个<code>实名用户</code>付款，单笔单日限额<code>2W</code>；</li>\n<li>到账规则<br>现金红包：以发红包的形式，用户需<code>打开红包</code>才能将钱存到个人钱包的零钱中<br>企业付款：<code>直接</code>到个人钱包的零钱中</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>近期做微信公众号开发，由于<code>企业向微信用户个人发现金红包</code>的功能有金额限制<code>（1~200）</code>，而且有时间限制<code>（0~8点间不能发红包）</code>，于是就改用<code>企业向用户付款</code>的功能，实现过程总结如下。</p>\n<ul>\n<li>请求Url：<a href=\"https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers\">https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers</a></li>\n<li>是否需要证书：是</li>\n<li>请求方式：POST","more":"</li>\n<li>数据示例<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xml</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_appid</span>&gt;</span>wxe062425f740c30d8<span class=\"tag\">&lt;/<span class=\"name\">mch_appid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mchid</span>&gt;</span>10000098<span class=\"tag\">&lt;/<span class=\"name\">mchid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nonce_str</span>&gt;</span>3PG2J4ILTKCH16CQ2502SI8ZNMTM67VS<span class=\"tag\">&lt;/<span class=\"name\">nonce_str</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">partner_trade_no</span>&gt;</span>100000982014120919616<span class=\"tag\">&lt;/<span class=\"name\">partner_trade_no</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">openid</span>&gt;</span>ohO4Gt7wVPxIT1A9GjFaMYMiZY1s<span class=\"tag\">&lt;/<span class=\"name\">openid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">check_name</span>&gt;</span>OPTION_CHECK<span class=\"tag\">&lt;/<span class=\"name\">check_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">re_user_name</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">re_user_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">amount</span>&gt;</span>100<span class=\"tag\">&lt;/<span class=\"name\">amount</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">desc</span>&gt;</span>节日快乐!<span class=\"tag\">&lt;/<span class=\"name\">desc</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">spbill_create_ip</span>&gt;</span>10.2.3.10<span class=\"tag\">&lt;/<span class=\"name\">spbill_create_ip</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sign</span>&gt;</span>C97BDBACF37622775366F38B629F45E3<span class=\"tag\">&lt;/<span class=\"name\">sign</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>具体java代码实现和发现金红包类似<br>下面对比一下发现金红包与企业付款：</li>\n<li>发送频率规则<br>现金红包：<code>每分钟</code>发送红包不超过<code>1800</code>个；北<code>京时间0：00-8：00</code>不触发红包赠送；<br>企业付款：无</li>\n<li>金额规则<br>现金红包：单个红包金额介于<code>[1.00元，200.00元]</code>之间；同一个红包只能发送给一个用户<br>企业付款：给同一个<code>非实名用户</code>付款，单笔单日限额<code>2000</code>；给同一个<code>实名用户</code>付款，单笔单日限额<code>2W</code>；</li>\n<li>到账规则<br>现金红包：以发红包的形式，用户需<code>打开红包</code>才能将钱存到个人钱包的零钱中<br>企业付款：<code>直接</code>到个人钱包的零钱中</li>\n</ul>"},{"title":"微信公众号发红包实现","date":"2015-11-03T15:46:59.000Z","type":"tags","_content":"近期做微信公众号开发，用到了`企业向微信用户个人发现金红包`的功能，相比之前微信支付功能的实现，多了证书的验证，实现过程总结如下。\n- 请求Url：https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\n- 是否需要证书：是\n- 请求方式：POST\n<!--more-->\n- 数据示例\n```xml\n<xml>\n  <sign><![CDATA[E1EE61A91C8E90F299DE6AE075D60A2D]]></sign>\n  <mch_billno><![CDATA[0010010404201411170000046545]]></mch_billno>\n  <mch_id><![CDATA[888]]></mch_id>\n  <wxappid><![CDATA[wxcbda96de0b165486]]></wxappid>\n  <send_name><![CDATA[send_name]]></send_name>\n  <re_openid><![CDATA[onqOjjmM1tad-3ROpncN-yUfa6uI]]></re_openid>\n  <total_amount><![CDATA[200]]></total_amount>\n  <total_num><![CDATA[1]]></total_num>\n  <wishing><![CDATA[恭喜发财]]></wishing>\n  <client_ip><![CDATA[127.0.0.1]]></client_ip>\n  <act_name><![CDATA[新年红包]]></act_name>\n  <remark><![CDATA[新年红包]]></remark>\n  <nonce_str><![CDATA[50780e0cca98c8c8e814883e5caa672e]]></nonce_str>\n</xml>\n```\n- 带证书的请求java代码实现如下：\n```java\n  KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n  FileInputStream instream = new FileInputStream(new File(\"/../123XXXXXXXX.p12\"));\n  try\n  {\n    keyStore.load(instream, \"123XXXXXXXX\".toCharArray());\n  }\n  finally\n  {\n    instream.close();\n  }\n  // Trust own CA and all self-signed certs\n  SSLContext sslcontext = SSLContexts.custom().loadKeyMaterial(keyStore, \"1236829802\".toCharArray()).build();\n  // Allow TLSv1 protocol only\n  SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { \"TLSv1\" }, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n  CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n  String xml = getPackage();\n  StringEntity stringEntity;\n  try\n  {\n    HttpPost httppost = new HttpPost(\"https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\");\n    stringEntity = new StringEntity(xml, \"utf-8\");\n    httppost.setEntity(stringEntity);\n    CloseableHttpResponse response = httpclient.execute(httppost);\n  }\n  ...\n```","source":"_posts/微信公众号发红包实现.md","raw":"title: \"微信公众号发红包实现\"\ndate: 2015-11-03 23:46:59\ntype: \"tags\"\ntags:\n- 微信公众平台开发\n- Java\n---\n近期做微信公众号开发，用到了`企业向微信用户个人发现金红包`的功能，相比之前微信支付功能的实现，多了证书的验证，实现过程总结如下。\n- 请求Url：https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\n- 是否需要证书：是\n- 请求方式：POST\n<!--more-->\n- 数据示例\n```xml\n<xml>\n  <sign><![CDATA[E1EE61A91C8E90F299DE6AE075D60A2D]]></sign>\n  <mch_billno><![CDATA[0010010404201411170000046545]]></mch_billno>\n  <mch_id><![CDATA[888]]></mch_id>\n  <wxappid><![CDATA[wxcbda96de0b165486]]></wxappid>\n  <send_name><![CDATA[send_name]]></send_name>\n  <re_openid><![CDATA[onqOjjmM1tad-3ROpncN-yUfa6uI]]></re_openid>\n  <total_amount><![CDATA[200]]></total_amount>\n  <total_num><![CDATA[1]]></total_num>\n  <wishing><![CDATA[恭喜发财]]></wishing>\n  <client_ip><![CDATA[127.0.0.1]]></client_ip>\n  <act_name><![CDATA[新年红包]]></act_name>\n  <remark><![CDATA[新年红包]]></remark>\n  <nonce_str><![CDATA[50780e0cca98c8c8e814883e5caa672e]]></nonce_str>\n</xml>\n```\n- 带证书的请求java代码实现如下：\n```java\n  KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n  FileInputStream instream = new FileInputStream(new File(\"/../123XXXXXXXX.p12\"));\n  try\n  {\n    keyStore.load(instream, \"123XXXXXXXX\".toCharArray());\n  }\n  finally\n  {\n    instream.close();\n  }\n  // Trust own CA and all self-signed certs\n  SSLContext sslcontext = SSLContexts.custom().loadKeyMaterial(keyStore, \"1236829802\".toCharArray()).build();\n  // Allow TLSv1 protocol only\n  SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { \"TLSv1\" }, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);\n  CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n  String xml = getPackage();\n  StringEntity stringEntity;\n  try\n  {\n    HttpPost httppost = new HttpPost(\"https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\");\n    stringEntity = new StringEntity(xml, \"utf-8\");\n    httppost.setEntity(stringEntity);\n    CloseableHttpResponse response = httpclient.execute(httppost);\n  }\n  ...\n```","slug":"微信公众号发红包实现","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz320040rz5m5gyba3f9","content":"<p>近期做微信公众号开发，用到了<code>企业向微信用户个人发现金红包</code>的功能，相比之前微信支付功能的实现，多了证书的验证，实现过程总结如下。</p>\n<ul>\n<li>请求Url：<a href=\"https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\">https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack</a></li>\n<li>是否需要证书：是</li>\n<li>请求方式：POST<span id=\"more\"></span></li>\n<li>数据示例<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xml</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sign</span>&gt;</span>&lt;![CDATA[E1EE61A91C8E90F299DE6AE075D60A2D]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">sign</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_billno</span>&gt;</span>&lt;![CDATA[0010010404201411170000046545]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">mch_billno</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_id</span>&gt;</span>&lt;![CDATA[888]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">mch_id</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">wxappid</span>&gt;</span>&lt;![CDATA[wxcbda96de0b165486]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">wxappid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">send_name</span>&gt;</span>&lt;![CDATA[send_name]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">send_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">re_openid</span>&gt;</span>&lt;![CDATA[onqOjjmM1tad-3ROpncN-yUfa6uI]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">re_openid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">total_amount</span>&gt;</span>&lt;![CDATA[200]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">total_amount</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">total_num</span>&gt;</span>&lt;![CDATA[1]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">total_num</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">wishing</span>&gt;</span>&lt;![CDATA[恭喜发财]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">wishing</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">client_ip</span>&gt;</span>&lt;![CDATA[127.0.0.1]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">client_ip</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">act_name</span>&gt;</span>&lt;![CDATA[新年红包]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">act_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">remark</span>&gt;</span>&lt;![CDATA[新年红包]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">remark</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nonce_str</span>&gt;</span>&lt;![CDATA[50780e0cca98c8c8e814883e5caa672e]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">nonce_str</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>带证书的请求java代码实现如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">KeyStore</span> <span class=\"variable\">keyStore</span> <span class=\"operator\">=</span> KeyStore.getInstance(<span class=\"string\">&quot;PKCS12&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">instream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/../123XXXXXXXX.p12&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  keyStore.load(instream, <span class=\"string\">&quot;123XXXXXXXX&quot;</span>.toCharArray());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  instream.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Trust own CA and all self-signed certs</span></span><br><span class=\"line\"><span class=\"type\">SSLContext</span> <span class=\"variable\">sslcontext</span> <span class=\"operator\">=</span> SSLContexts.custom().loadKeyMaterial(keyStore, <span class=\"string\">&quot;1236829802&quot;</span>.toCharArray()).build();</span><br><span class=\"line\"><span class=\"comment\">// Allow TLSv1 protocol only</span></span><br><span class=\"line\"><span class=\"type\">SSLConnectionSocketFactory</span> <span class=\"variable\">sslsf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SSLConnectionSocketFactory</span>(sslcontext, <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;TLSv1&quot;</span> &#125;, <span class=\"literal\">null</span>, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);</span><br><span class=\"line\"><span class=\"type\">CloseableHttpClient</span> <span class=\"variable\">httpclient</span> <span class=\"operator\">=</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">xml</span> <span class=\"operator\">=</span> getPackage();</span><br><span class=\"line\">StringEntity stringEntity;</span><br><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">HttpPost</span> <span class=\"variable\">httppost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPost</span>(<span class=\"string\">&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack&quot;</span>);</span><br><span class=\"line\">  stringEntity = <span class=\"keyword\">new</span> <span class=\"title class_\">StringEntity</span>(xml, <span class=\"string\">&quot;utf-8&quot;</span>);</span><br><span class=\"line\">  httppost.setEntity(stringEntity);</span><br><span class=\"line\">  <span class=\"type\">CloseableHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> httpclient.execute(httppost);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>近期做微信公众号开发，用到了<code>企业向微信用户个人发现金红包</code>的功能，相比之前微信支付功能的实现，多了证书的验证，实现过程总结如下。</p>\n<ul>\n<li>请求Url：<a href=\"https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack\">https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack</a></li>\n<li>是否需要证书：是</li>\n<li>请求方式：POST","more":"</li>\n<li>数据示例<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xml</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">sign</span>&gt;</span>&lt;![CDATA[E1EE61A91C8E90F299DE6AE075D60A2D]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">sign</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_billno</span>&gt;</span>&lt;![CDATA[0010010404201411170000046545]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">mch_billno</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mch_id</span>&gt;</span>&lt;![CDATA[888]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">mch_id</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">wxappid</span>&gt;</span>&lt;![CDATA[wxcbda96de0b165486]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">wxappid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">send_name</span>&gt;</span>&lt;![CDATA[send_name]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">send_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">re_openid</span>&gt;</span>&lt;![CDATA[onqOjjmM1tad-3ROpncN-yUfa6uI]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">re_openid</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">total_amount</span>&gt;</span>&lt;![CDATA[200]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">total_amount</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">total_num</span>&gt;</span>&lt;![CDATA[1]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">total_num</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">wishing</span>&gt;</span>&lt;![CDATA[恭喜发财]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">wishing</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">client_ip</span>&gt;</span>&lt;![CDATA[127.0.0.1]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">client_ip</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">act_name</span>&gt;</span>&lt;![CDATA[新年红包]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">act_name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">remark</span>&gt;</span>&lt;![CDATA[新年红包]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">remark</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nonce_str</span>&gt;</span>&lt;![CDATA[50780e0cca98c8c8e814883e5caa672e]]&gt;<span class=\"tag\">&lt;/<span class=\"name\">nonce_str</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xml</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>带证书的请求java代码实现如下：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">KeyStore</span> <span class=\"variable\">keyStore</span> <span class=\"operator\">=</span> KeyStore.getInstance(<span class=\"string\">&quot;PKCS12&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">instream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;/../123XXXXXXXX.p12&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  keyStore.load(instream, <span class=\"string\">&quot;123XXXXXXXX&quot;</span>.toCharArray());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  instream.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Trust own CA and all self-signed certs</span></span><br><span class=\"line\"><span class=\"type\">SSLContext</span> <span class=\"variable\">sslcontext</span> <span class=\"operator\">=</span> SSLContexts.custom().loadKeyMaterial(keyStore, <span class=\"string\">&quot;1236829802&quot;</span>.toCharArray()).build();</span><br><span class=\"line\"><span class=\"comment\">// Allow TLSv1 protocol only</span></span><br><span class=\"line\"><span class=\"type\">SSLConnectionSocketFactory</span> <span class=\"variable\">sslsf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SSLConnectionSocketFactory</span>(sslcontext, <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;TLSv1&quot;</span> &#125;, <span class=\"literal\">null</span>, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);</span><br><span class=\"line\"><span class=\"type\">CloseableHttpClient</span> <span class=\"variable\">httpclient</span> <span class=\"operator\">=</span> HttpClients.custom().setSSLSocketFactory(sslsf).build();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">xml</span> <span class=\"operator\">=</span> getPackage();</span><br><span class=\"line\">StringEntity stringEntity;</span><br><span class=\"line\"><span class=\"keyword\">try</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">HttpPost</span> <span class=\"variable\">httppost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPost</span>(<span class=\"string\">&quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack&quot;</span>);</span><br><span class=\"line\">  stringEntity = <span class=\"keyword\">new</span> <span class=\"title class_\">StringEntity</span>(xml, <span class=\"string\">&quot;utf-8&quot;</span>);</span><br><span class=\"line\">  httppost.setEntity(stringEntity);</span><br><span class=\"line\">  <span class=\"type\">CloseableHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> httpclient.execute(httppost);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"微信公众号调用access_token接口频率限制解决(Java)","date":"2015-05-09T07:02:44.000Z","type":"tags","_content":"access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。\n公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：\n```\n{\"errcode\":45009,\"errmsg\":\"api freq out of limit\"}\n```\n那怎么才能在access_token失效前定时刷新呢？\n<!--more-->\n\n## 新建token线程，定时获取token\n代码如下：\n```java\npublic class TokenThread implements Runnable \n{\n  public static String appid = \"\";\n  public static String appsecret = \"\";\n  public static AccessToken accessToken = null;\n  public static String jsapiTicket = null;\n  public void run()\n  {\n    while (true)\n    {\n      try\n      {\n      \taccessToken = AdvancedUtil.getAccessToken(appid, appsecret);\n      \tif (null != accessToken)\n      \t{\n      \t  jsapiTicket = AdvancedUtil.getJsapiTicket(accessToken.getAccess_token());\n      \t  if (null != jsapiTicket)\n      \t  {\n      \t  \tThread.sleep((accessToken.getExpires_in() - 200) * 1000);\n      \t  }\n      \t  else\n      \t  {\n      \t  \tThread.sleep(60 * 1000);\n      \t  }\n      \t}\n      \telse\n      \t{\n      \t  Thread.sleep(60 * 1000);\n      \t}\n      }\n      catch (InterruptedException e)\n      {\n      \ttry\n      \t{\n      \t  Thread.sleep(60 * 1000);\n      \t}\n      \tcatch (InterruptedException e1) \n      \t{\n      \t}\n      }\n    }\n  }\n\n}\n```\n\n## 初始化servlet\n代码如下：\n```java\npublic class InitServlet extends HttpServlet \n{\n  private static final long serialVersionUID = 1L;\n  public void init() throws ServletException\n  {\n    TokenThread.appid = Constants.APPID;\n    TokenThread.appsecret = Constants.APPSECRET;\n\n    //未配置APPID、APPSECRET时不启动线程\n    if (\"\".equals(TokenThread.appid) || \"\".equals(TokenThread.appsecret))\n    {\n    }\n    else\n    {\n      //启动定时获取access_token的线程\n      new Thread(new TokenThread()).start();\n    }\n  }\n}\n```\n\n## web.xml配置\n代码如下：\n```xml\n<servlet>\n  <servlet-name>initServlet</servlet-name>\n  <servlet-class>\n    com.beibeibang.wechat.servlet.InitServlet\n  </servlet-class>\n  <load-on-startup>0</load-on-startup>\n</servlet>\n```\n\n## 调用\n代码如下：\n```java\nString accessToken = TokenThread.accessToken;\n```\n参考\n[获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n[接口频率限制说明](http://mp.weixin.qq.com/wiki/0/2e2239fa5f49388d5b5136ecc8e0e440.html)","source":"_posts/微信公众号调用access-token接口频率限制解决-Java.md","raw":"title: \"微信公众号调用access_token接口频率限制解决(Java)\"\ndate: 2015-05-09 15:02:44\ntype: \"tags\"\ntags:\n- 微信公众平台开发\n- Java\n---\naccess_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。\n公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：\n```\n{\"errcode\":45009,\"errmsg\":\"api freq out of limit\"}\n```\n那怎么才能在access_token失效前定时刷新呢？\n<!--more-->\n\n## 新建token线程，定时获取token\n代码如下：\n```java\npublic class TokenThread implements Runnable \n{\n  public static String appid = \"\";\n  public static String appsecret = \"\";\n  public static AccessToken accessToken = null;\n  public static String jsapiTicket = null;\n  public void run()\n  {\n    while (true)\n    {\n      try\n      {\n      \taccessToken = AdvancedUtil.getAccessToken(appid, appsecret);\n      \tif (null != accessToken)\n      \t{\n      \t  jsapiTicket = AdvancedUtil.getJsapiTicket(accessToken.getAccess_token());\n      \t  if (null != jsapiTicket)\n      \t  {\n      \t  \tThread.sleep((accessToken.getExpires_in() - 200) * 1000);\n      \t  }\n      \t  else\n      \t  {\n      \t  \tThread.sleep(60 * 1000);\n      \t  }\n      \t}\n      \telse\n      \t{\n      \t  Thread.sleep(60 * 1000);\n      \t}\n      }\n      catch (InterruptedException e)\n      {\n      \ttry\n      \t{\n      \t  Thread.sleep(60 * 1000);\n      \t}\n      \tcatch (InterruptedException e1) \n      \t{\n      \t}\n      }\n    }\n  }\n\n}\n```\n\n## 初始化servlet\n代码如下：\n```java\npublic class InitServlet extends HttpServlet \n{\n  private static final long serialVersionUID = 1L;\n  public void init() throws ServletException\n  {\n    TokenThread.appid = Constants.APPID;\n    TokenThread.appsecret = Constants.APPSECRET;\n\n    //未配置APPID、APPSECRET时不启动线程\n    if (\"\".equals(TokenThread.appid) || \"\".equals(TokenThread.appsecret))\n    {\n    }\n    else\n    {\n      //启动定时获取access_token的线程\n      new Thread(new TokenThread()).start();\n    }\n  }\n}\n```\n\n## web.xml配置\n代码如下：\n```xml\n<servlet>\n  <servlet-name>initServlet</servlet-name>\n  <servlet-class>\n    com.beibeibang.wechat.servlet.InitServlet\n  </servlet-class>\n  <load-on-startup>0</load-on-startup>\n</servlet>\n```\n\n## 调用\n代码如下：\n```java\nString accessToken = TokenThread.accessToken;\n```\n参考\n[获取access token](http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html)\n[接口频率限制说明](http://mp.weixin.qq.com/wiki/0/2e2239fa5f49388d5b5136ecc8e0e440.html)","slug":"微信公众号调用access-token接口频率限制解决-Java","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz320043rz5mer779wev","content":"<p>access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。<br>公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>那怎么才能在access_token失效前定时刷新呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"新建token线程，定时获取token\"><a href=\"#新建token线程，定时获取token\" class=\"headerlink\" title=\"新建token线程，定时获取token\"></a>新建token线程，定时获取token</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TokenThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">appid</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">appsecret</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">AccessToken</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">jsapiTicket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      \taccessToken = AdvancedUtil.getAccessToken(appid, appsecret);</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != accessToken)</span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  jsapiTicket = AdvancedUtil.getJsapiTicket(accessToken.getAccess_token());</span><br><span class=\"line\">      \t  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsapiTicket)</span><br><span class=\"line\">      \t  &#123;</span><br><span class=\"line\">      \t  \tThread.sleep((accessToken.getExpires_in() - <span class=\"number\">200</span>) * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t  &#125;</span><br><span class=\"line\">      \t  <span class=\"keyword\">else</span></span><br><span class=\"line\">      \t  &#123;</span><br><span class=\"line\">      \t  \tThread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t  &#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">else</span></span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  Thread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">try</span></span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  Thread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">catch</span> (InterruptedException e1) </span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化servlet\"><a href=\"#初始化servlet\" class=\"headerlink\" title=\"初始化servlet\"></a>初始化servlet</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InitServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    TokenThread.appid = Constants.APPID;</span><br><span class=\"line\">    TokenThread.appsecret = Constants.APPSECRET;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//未配置APPID、APPSECRET时不启动线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;&quot;</span>.equals(TokenThread.appid) || <span class=\"string\">&quot;&quot;</span>.equals(TokenThread.appsecret))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//启动定时获取access_token的线程</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TokenThread</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"web-xml配置\"><a href=\"#web-xml配置\" class=\"headerlink\" title=\"web.xml配置\"></a>web.xml配置</h2><p>代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>initServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    com.beibeibang.wechat.servlet.InitServlet</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> TokenThread.accessToken;</span><br></pre></td></tr></table></figure>\n<p>参考<br><a href=\"http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html\">获取access token</a><br><a href=\"http://mp.weixin.qq.com/wiki/0/2e2239fa5f49388d5b5136ecc8e0e440.html\">接口频率限制说明</a></p>\n","site":{"data":{}},"excerpt":"<p>access_token是公众号的全局唯一票据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。<br>公众号调用接口并不是无限制的。为了防止公众号的程序错误而引发微信服务器负载异常，默认情况下，每个公众号调用接口都不能超过一定限制，当超过一定限制时，调用对应接口会收到如下错误返回码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;errcode&quot;:45009,&quot;errmsg&quot;:&quot;api freq out of limit&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>那怎么才能在access_token失效前定时刷新呢？</p>","more":"<h2 id=\"新建token线程，定时获取token\"><a href=\"#新建token线程，定时获取token\" class=\"headerlink\" title=\"新建token线程，定时获取token\"></a>新建token线程，定时获取token</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TokenThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">appid</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">appsecret</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">AccessToken</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">jsapiTicket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      \taccessToken = AdvancedUtil.getAccessToken(appid, appsecret);</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != accessToken)</span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  jsapiTicket = AdvancedUtil.getJsapiTicket(accessToken.getAccess_token());</span><br><span class=\"line\">      \t  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsapiTicket)</span><br><span class=\"line\">      \t  &#123;</span><br><span class=\"line\">      \t  \tThread.sleep((accessToken.getExpires_in() - <span class=\"number\">200</span>) * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t  &#125;</span><br><span class=\"line\">      \t  <span class=\"keyword\">else</span></span><br><span class=\"line\">      \t  &#123;</span><br><span class=\"line\">      \t  \tThread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t  &#125;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">else</span></span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  Thread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">try</span></span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t  Thread.sleep(<span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      \t<span class=\"keyword\">catch</span> (InterruptedException e1) </span><br><span class=\"line\">      \t&#123;</span><br><span class=\"line\">      \t&#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"初始化servlet\"><a href=\"#初始化servlet\" class=\"headerlink\" title=\"初始化servlet\"></a>初始化servlet</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InitServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    TokenThread.appid = Constants.APPID;</span><br><span class=\"line\">    TokenThread.appsecret = Constants.APPSECRET;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//未配置APPID、APPSECRET时不启动线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;&quot;</span>.equals(TokenThread.appid) || <span class=\"string\">&quot;&quot;</span>.equals(TokenThread.appsecret))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//启动定时获取access_token的线程</span></span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TokenThread</span>()).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"web-xml配置\"><a href=\"#web-xml配置\" class=\"headerlink\" title=\"web.xml配置\"></a>web.xml配置</h2><p>代码如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>initServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    com.beibeibang.wechat.servlet.InitServlet</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> TokenThread.accessToken;</span><br></pre></td></tr></table></figure>\n<p>参考<br><a href=\"http://mp.weixin.qq.com/wiki/11/0e4b294685f817b95cbed85ba5e82b8f.html\">获取access token</a><br><a href=\"http://mp.weixin.qq.com/wiki/0/2e2239fa5f49388d5b5136ecc8e0e440.html\">接口频率限制说明</a></p>"},{"title":"微信支付V3.x后台实现(Java)","date":"2015-05-09T05:25:50.000Z","type":"tags","_content":"最近做微信公众号开发，用到了`网页中调起微信支付`的功能，微信公众平台提供的DEMO是基于PHP的，没有Java的，到网上查阅资料也都是`V2.x`的，而现在微信支付已经更新到了`V3.x`版本，经过几天的探索，终于成功实现，将实现过程总结下。\n<!--more-->\n## 获取签名证书，初始化JS-API\n在网页中JS调起微信支付需用到微信JS-SDK，首先得初始化JS-API，后台将`签名证书`传给前端。\n- 第一步，获取jsapiTicket\n```java\n//获取AccessToken\npublic static AccessToken getAccessToken(String appId, String appSecret) \n{\n  AccessToken accessToken = null;\n  String requestUrl = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\";\n  requestUrl = requestUrl.replace(\"APPID\", appId);\n  requestUrl = requestUrl.replace(\"APPSECRET\", appSecret);\n  String result = CommonUtil.httpRequest(requestUrl);\n  JSONObject jsonObject = JSONObject.fromObject(result);\n  if (null != jsonObject) \n  {\n    try \n    {\n      accessToken = new AccessToken();\n      accessToken.setAccess_token(jsonObject.getString(\"access_token\"));\n      accessToken.setExpires_in(jsonObject.getInt(\"expires_in\"));\n    } \n    catch (Exception e) \n    {\n      accessToken = null;\n      int errorCode = jsonObject.getInt(\"errcode\");\n      String errorMsg = jsonObject.getString(\"errmsg\");\n    }\n  }\n  return accessToken;\n}\n//获取jsapiTicket\npublic static String getJsapiTicket(String accessToken) \n{\n  String jsapiTicket = null;\n  String requestUrl = \"https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=jsapi\";\n  requestUrl = requestUrl.replace(\"ACCESS_TOKEN\", accessToken);\n  String result = CommonUtil.httpRequest(requestUrl);\n  JSONObject jsonObject = JSONObject.fromObject(result);\n  if (null != jsonObject) \n  {\n    try \n    {\n      jsapiTicket = jsonObject.getString(\"ticket\");\n    }\n    catch (Exception e)\n    {\n      int errorCode = jsonObject.getInt(\"errcode\");\n      String errorMsg = jsonObject.getString(\"errmsg\");\n    }\n  }\n  return jsapiTicket;\n}\n```\n`access_token和jsapiTicket需控制调用频率`，参考[微信公众号调用access_token接口频率限制解决(Java)](http://hellomypastor.net/2015/05/09/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%B0%83%E7%94%A8access-token%E6%8E%A5%E5%8F%A3%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E8%A7%A3%E5%86%B3-Java/)\n- 第二步，获取sign签名证书\n```java\npublic static Map<String, String> sign(String jsapi_ticket, String url) \n{\n  Map<String, String> ret = new HashMap<String, String>();\n  String nonce_str = create_nonce_str();\n  String timestamp = create_timestamp();\n  String string1;\n  String signature = \"\";\n  // 注意这里参数名必须全部小写，且必须有序\n  string1 = \"jsapi_ticket=\" + jsapi_ticket + \"&noncestr=\" + nonce_str + \"&timestamp=\" + timestamp + \"&url=\" + url;\n  try \n  {\n    MessageDigest crypt = MessageDigest.getInstance(\"SHA-1\");\n    crypt.reset();\n    crypt.update(string1.getBytes(\"UTF-8\"));\n    signature = byteToHex(crypt.digest());\n  } \n  catch (NoSuchAlgorithmException e) \n  {\n    return null;\n  } \n  catch (UnsupportedEncodingException e) \n  {\n    return null;\n  }\n  ret.put(\"jsapi_ticket\", jsapi_ticket);\n  ret.put(\"nonceStr\", nonce_str);\n  ret.put(\"timestamp\", timestamp);\n  ret.put(\"signature\", signature);\n  return ret;\n}\n```\n## 获取微信支付配置参数\n微信支付参数需要的有3个:a.微信分配的公众账号ID（appid）;b.微信支付分配的商户号（mch_id/PartnerId）；c.商户密钥（PartnerKey）\n## 调用统一下单接口，生成预支付订单号\n代码如下：\n```java\n/**\n* 生成预支付订单\n* \n* @return\n*/\npublic String submitXmlGetPrepayId() \n{\n  // 创建HttpClientBuilder\n  HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n  HttpPost httpPost = new HttpPost(unifiedorder);\n  String xml = getPackage();\n  StringEntity entity;\n  String result = null;\n  try \n  {\n    entity = new StringEntity(xml, \"utf-8\");\n    httpPost.setEntity(entity);\n    HttpResponse httpResponse;\n    httpResponse = closeableHttpClient.execute(httpPost);\n    HttpEntity httpEntity = httpResponse.getEntity();\n    if (httpEntity != null)\n    {\n      result = result.replaceAll(\"<![CDATA[|]]>\", \"\");\n      String prepay_id = Jsoup.parse(result).select(\"prepay_id\").html();\n      this.prepay_id = prepay_id;\n      if (prepay_id != null)\n      {\n        return prepay_id;\n      }\n    }\n    closeableHttpClient.close();\n  } \n  catch (Exception e) \n  {\n    e.printStackTrace();\n  }\n  return prepay_id;\n}\n```\n## 生成带支付签名的订单凭据并返回\n代码如下：\n```java\npublic class WXPay \n{\n  public static String createPackageValue(String appid, String appKey, String prepay_id)  \n  {\n    SortedMap<String, String> nativeObj = new TreeMap<String, String>();\n    nativeObj.put(\"appId\", appid);\n    nativeObj.put(\"timeStamp\", OrderUtil.GetTimestamp());\n    Random random = new Random();\n    String randomStr = MD5.GetMD5String(String.valueOf(random.nextInt(10000)));\n    nativeObj.put(\"nonceStr\", MD5Util.MD5Encode(randomStr, \"utf-8\").toLowerCase());\n    nativeObj.put(\"package\", \"prepay_id=\" +prepay_id);\n    nativeObj.put(\"signType\", \"MD5\");\n    nativeObj.put(\"paySign\", createSign(nativeObj, appKey));\n    System.out.println(JSONObject.fromObject(nativeObj).toString());\n    return JSONObject.fromObject(nativeObj).toString();\n  }\n  /**\n   * 创建md5摘要,规则是:按参数名称a-z排序,遇到空值的参数不参加签名。\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static String createSign(SortedMap<String, String> packageParams, String AppKey) \n  {\n    StringBuffer sb = new StringBuffer();\n    Set es = packageParams.entrySet();\n    Iterator it = es.iterator();\n    while (it.hasNext()) \n    {\n      Map.Entry entry = (Map.Entry) it.next();\n      String k = (String) entry.getKey();\n      String v = (String) entry.getValue();\n      if (null != v && !\"\".equals(v) && !\"sign\".equals(k) && !\"key\".equals(k)) \n      {\n        sb.append(k + \"=\" + v + \"&\");\n      }\n    }\n    sb.append(\"key=\" + AppKey);\n    String sign = MD5Util.MD5Encode(sb.toString(), \"UTF-8\").toUpperCase();\n    return sign;\n  }\n}\n```\n## 调起微信支付（发起微信支付请求）\n## 用户确认金额并输入支付密码\n## 向用户展示支付结果\n参考\n[JS-SDK-API](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)\n[微信支付PDF文档](https://mp.weixin.qq.com/paymch/readtemplate?t=mp/business/course3_tmpl&lang=zh_CN)\n[这篇文章](http://blog.csdn.net/omsvip/article/details/43342957)。\n","source":"_posts/微信支付V3-x实现-Java后台.md","raw":"title: \"微信支付V3.x后台实现(Java)\"\ndate: 2015-05-09 13:25:50\ntype: \"tags\"\ntags:\n- 微信公众平台开发\n- Java\n- SpringMVC\n---\n最近做微信公众号开发，用到了`网页中调起微信支付`的功能，微信公众平台提供的DEMO是基于PHP的，没有Java的，到网上查阅资料也都是`V2.x`的，而现在微信支付已经更新到了`V3.x`版本，经过几天的探索，终于成功实现，将实现过程总结下。\n<!--more-->\n## 获取签名证书，初始化JS-API\n在网页中JS调起微信支付需用到微信JS-SDK，首先得初始化JS-API，后台将`签名证书`传给前端。\n- 第一步，获取jsapiTicket\n```java\n//获取AccessToken\npublic static AccessToken getAccessToken(String appId, String appSecret) \n{\n  AccessToken accessToken = null;\n  String requestUrl = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\";\n  requestUrl = requestUrl.replace(\"APPID\", appId);\n  requestUrl = requestUrl.replace(\"APPSECRET\", appSecret);\n  String result = CommonUtil.httpRequest(requestUrl);\n  JSONObject jsonObject = JSONObject.fromObject(result);\n  if (null != jsonObject) \n  {\n    try \n    {\n      accessToken = new AccessToken();\n      accessToken.setAccess_token(jsonObject.getString(\"access_token\"));\n      accessToken.setExpires_in(jsonObject.getInt(\"expires_in\"));\n    } \n    catch (Exception e) \n    {\n      accessToken = null;\n      int errorCode = jsonObject.getInt(\"errcode\");\n      String errorMsg = jsonObject.getString(\"errmsg\");\n    }\n  }\n  return accessToken;\n}\n//获取jsapiTicket\npublic static String getJsapiTicket(String accessToken) \n{\n  String jsapiTicket = null;\n  String requestUrl = \"https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=jsapi\";\n  requestUrl = requestUrl.replace(\"ACCESS_TOKEN\", accessToken);\n  String result = CommonUtil.httpRequest(requestUrl);\n  JSONObject jsonObject = JSONObject.fromObject(result);\n  if (null != jsonObject) \n  {\n    try \n    {\n      jsapiTicket = jsonObject.getString(\"ticket\");\n    }\n    catch (Exception e)\n    {\n      int errorCode = jsonObject.getInt(\"errcode\");\n      String errorMsg = jsonObject.getString(\"errmsg\");\n    }\n  }\n  return jsapiTicket;\n}\n```\n`access_token和jsapiTicket需控制调用频率`，参考[微信公众号调用access_token接口频率限制解决(Java)](http://hellomypastor.net/2015/05/09/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%B0%83%E7%94%A8access-token%E6%8E%A5%E5%8F%A3%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E8%A7%A3%E5%86%B3-Java/)\n- 第二步，获取sign签名证书\n```java\npublic static Map<String, String> sign(String jsapi_ticket, String url) \n{\n  Map<String, String> ret = new HashMap<String, String>();\n  String nonce_str = create_nonce_str();\n  String timestamp = create_timestamp();\n  String string1;\n  String signature = \"\";\n  // 注意这里参数名必须全部小写，且必须有序\n  string1 = \"jsapi_ticket=\" + jsapi_ticket + \"&noncestr=\" + nonce_str + \"&timestamp=\" + timestamp + \"&url=\" + url;\n  try \n  {\n    MessageDigest crypt = MessageDigest.getInstance(\"SHA-1\");\n    crypt.reset();\n    crypt.update(string1.getBytes(\"UTF-8\"));\n    signature = byteToHex(crypt.digest());\n  } \n  catch (NoSuchAlgorithmException e) \n  {\n    return null;\n  } \n  catch (UnsupportedEncodingException e) \n  {\n    return null;\n  }\n  ret.put(\"jsapi_ticket\", jsapi_ticket);\n  ret.put(\"nonceStr\", nonce_str);\n  ret.put(\"timestamp\", timestamp);\n  ret.put(\"signature\", signature);\n  return ret;\n}\n```\n## 获取微信支付配置参数\n微信支付参数需要的有3个:a.微信分配的公众账号ID（appid）;b.微信支付分配的商户号（mch_id/PartnerId）；c.商户密钥（PartnerKey）\n## 调用统一下单接口，生成预支付订单号\n代码如下：\n```java\n/**\n* 生成预支付订单\n* \n* @return\n*/\npublic String submitXmlGetPrepayId() \n{\n  // 创建HttpClientBuilder\n  HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();\n  HttpPost httpPost = new HttpPost(unifiedorder);\n  String xml = getPackage();\n  StringEntity entity;\n  String result = null;\n  try \n  {\n    entity = new StringEntity(xml, \"utf-8\");\n    httpPost.setEntity(entity);\n    HttpResponse httpResponse;\n    httpResponse = closeableHttpClient.execute(httpPost);\n    HttpEntity httpEntity = httpResponse.getEntity();\n    if (httpEntity != null)\n    {\n      result = result.replaceAll(\"<![CDATA[|]]>\", \"\");\n      String prepay_id = Jsoup.parse(result).select(\"prepay_id\").html();\n      this.prepay_id = prepay_id;\n      if (prepay_id != null)\n      {\n        return prepay_id;\n      }\n    }\n    closeableHttpClient.close();\n  } \n  catch (Exception e) \n  {\n    e.printStackTrace();\n  }\n  return prepay_id;\n}\n```\n## 生成带支付签名的订单凭据并返回\n代码如下：\n```java\npublic class WXPay \n{\n  public static String createPackageValue(String appid, String appKey, String prepay_id)  \n  {\n    SortedMap<String, String> nativeObj = new TreeMap<String, String>();\n    nativeObj.put(\"appId\", appid);\n    nativeObj.put(\"timeStamp\", OrderUtil.GetTimestamp());\n    Random random = new Random();\n    String randomStr = MD5.GetMD5String(String.valueOf(random.nextInt(10000)));\n    nativeObj.put(\"nonceStr\", MD5Util.MD5Encode(randomStr, \"utf-8\").toLowerCase());\n    nativeObj.put(\"package\", \"prepay_id=\" +prepay_id);\n    nativeObj.put(\"signType\", \"MD5\");\n    nativeObj.put(\"paySign\", createSign(nativeObj, appKey));\n    System.out.println(JSONObject.fromObject(nativeObj).toString());\n    return JSONObject.fromObject(nativeObj).toString();\n  }\n  /**\n   * 创建md5摘要,规则是:按参数名称a-z排序,遇到空值的参数不参加签名。\n   */\n  @SuppressWarnings(\"rawtypes\")\n  public static String createSign(SortedMap<String, String> packageParams, String AppKey) \n  {\n    StringBuffer sb = new StringBuffer();\n    Set es = packageParams.entrySet();\n    Iterator it = es.iterator();\n    while (it.hasNext()) \n    {\n      Map.Entry entry = (Map.Entry) it.next();\n      String k = (String) entry.getKey();\n      String v = (String) entry.getValue();\n      if (null != v && !\"\".equals(v) && !\"sign\".equals(k) && !\"key\".equals(k)) \n      {\n        sb.append(k + \"=\" + v + \"&\");\n      }\n    }\n    sb.append(\"key=\" + AppKey);\n    String sign = MD5Util.MD5Encode(sb.toString(), \"UTF-8\").toUpperCase();\n    return sign;\n  }\n}\n```\n## 调起微信支付（发起微信支付请求）\n## 用户确认金额并输入支付密码\n## 向用户展示支付结果\n参考\n[JS-SDK-API](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)\n[微信支付PDF文档](https://mp.weixin.qq.com/paymch/readtemplate?t=mp/business/course3_tmpl&lang=zh_CN)\n[这篇文章](http://blog.csdn.net/omsvip/article/details/43342957)。\n","slug":"微信支付V3-x实现-Java后台","published":1,"updated":"2025-03-07T13:26:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz330047rz5ma5xado15","content":"<p>最近做微信公众号开发，用到了<code>网页中调起微信支付</code>的功能，微信公众平台提供的DEMO是基于PHP的，没有Java的，到网上查阅资料也都是<code>V2.x</code>的，而现在微信支付已经更新到了<code>V3.x</code>版本，经过几天的探索，终于成功实现，将实现过程总结下。</p>\n<span id=\"more\"></span>\n<h2 id=\"获取签名证书，初始化JS-API\"><a href=\"#获取签名证书，初始化JS-API\" class=\"headerlink\" title=\"获取签名证书，初始化JS-API\"></a>获取签名证书，初始化JS-API</h2><p>在网页中JS调起微信支付需用到微信JS-SDK，首先得初始化JS-API，后台将<code>签名证书</code>传给前端。</p>\n<ul>\n<li>第一步，获取jsapiTicket<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取AccessToken</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AccessToken <span class=\"title function_\">getAccessToken</span><span class=\"params\">(String appId, String appSecret)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">AccessToken</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">requestUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;</span>;</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;APPID&quot;</span>, appId);</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;APPSECRET&quot;</span>, appSecret);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CommonUtil.httpRequest(requestUrl);</span><br><span class=\"line\">  <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> JSONObject.fromObject(result);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsonObject) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      accessToken = <span class=\"keyword\">new</span> <span class=\"title class_\">AccessToken</span>();</span><br><span class=\"line\">      accessToken.setAccess_token(jsonObject.getString(<span class=\"string\">&quot;access_token&quot;</span>));</span><br><span class=\"line\">      accessToken.setExpires_in(jsonObject.getInt(<span class=\"string\">&quot;expires_in&quot;</span>));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      accessToken = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> jsonObject.getInt(<span class=\"string\">&quot;errcode&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;errmsg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accessToken;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取jsapiTicket</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getJsapiTicket</span><span class=\"params\">(String accessToken)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">jsapiTicket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">requestUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi&quot;</span>;</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;ACCESS_TOKEN&quot;</span>, accessToken);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CommonUtil.httpRequest(requestUrl);</span><br><span class=\"line\">  <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> JSONObject.fromObject(result);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsonObject) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      jsapiTicket = jsonObject.getString(<span class=\"string\">&quot;ticket&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> jsonObject.getInt(<span class=\"string\">&quot;errcode&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;errmsg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> jsapiTicket;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<code>access_token和jsapiTicket需控制调用频率</code>，参考<a href=\"http://hellomypastor.net/2015/05/09/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%B0%83%E7%94%A8access-token%E6%8E%A5%E5%8F%A3%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E8%A7%A3%E5%86%B3-Java/\">微信公众号调用access_token接口频率限制解决(Java)</a></li>\n<li>第二步，获取sign签名证书<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, String&gt; <span class=\"title function_\">sign</span><span class=\"params\">(String jsapi_ticket, String url)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Map&lt;String, String&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;();</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">nonce_str</span> <span class=\"operator\">=</span> create_nonce_str();</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> create_timestamp();</span><br><span class=\"line\">  String string1;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 注意这里参数名必须全部小写，且必须有序</span></span><br><span class=\"line\">  string1 = <span class=\"string\">&quot;jsapi_ticket=&quot;</span> + jsapi_ticket + <span class=\"string\">&quot;&amp;noncestr=&quot;</span> + nonce_str + <span class=\"string\">&quot;&amp;timestamp=&quot;</span> + timestamp + <span class=\"string\">&quot;&amp;url=&quot;</span> + url;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageDigest</span> <span class=\"variable\">crypt</span> <span class=\"operator\">=</span> MessageDigest.getInstance(<span class=\"string\">&quot;SHA-1&quot;</span>);</span><br><span class=\"line\">    crypt.reset();</span><br><span class=\"line\">    crypt.update(string1.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    signature = byteToHex(crypt.digest());</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;jsapi_ticket&quot;</span>, jsapi_ticket);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;nonceStr&quot;</span>, nonce_str);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;timestamp&quot;</span>, timestamp);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;signature&quot;</span>, signature);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"获取微信支付配置参数\"><a href=\"#获取微信支付配置参数\" class=\"headerlink\" title=\"获取微信支付配置参数\"></a>获取微信支付配置参数</h2><p>微信支付参数需要的有3个:a.微信分配的公众账号ID（appid）;b.微信支付分配的商户号（mch_id&#x2F;PartnerId）；c.商户密钥（PartnerKey）</p>\n<h2 id=\"调用统一下单接口，生成预支付订单号\"><a href=\"#调用统一下单接口，生成预支付订单号\" class=\"headerlink\" title=\"调用统一下单接口，生成预支付订单号\"></a>调用统一下单接口，生成预支付订单号</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 生成预支付订单</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">submitXmlGetPrepayId</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建HttpClientBuilder</span></span><br><span class=\"line\">  <span class=\"type\">HttpClientBuilder</span> <span class=\"variable\">httpClientBuilder</span> <span class=\"operator\">=</span> HttpClientBuilder.create();</span><br><span class=\"line\">  <span class=\"type\">HttpPost</span> <span class=\"variable\">httpPost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPost</span>(unifiedorder);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">xml</span> <span class=\"operator\">=</span> getPackage();</span><br><span class=\"line\">  StringEntity entity;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    entity = <span class=\"keyword\">new</span> <span class=\"title class_\">StringEntity</span>(xml, <span class=\"string\">&quot;utf-8&quot;</span>);</span><br><span class=\"line\">    httpPost.setEntity(entity);</span><br><span class=\"line\">    HttpResponse httpResponse;</span><br><span class=\"line\">    httpResponse = closeableHttpClient.execute(httpPost);</span><br><span class=\"line\">    <span class=\"type\">HttpEntity</span> <span class=\"variable\">httpEntity</span> <span class=\"operator\">=</span> httpResponse.getEntity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpEntity != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      result = result.replaceAll(<span class=\"string\">&quot;&lt;![CDATA[|]]&gt;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">prepay_id</span> <span class=\"operator\">=</span> Jsoup.parse(result).select(<span class=\"string\">&quot;prepay_id&quot;</span>).html();</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.prepay_id = prepay_id;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prepay_id != <span class=\"literal\">null</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prepay_id;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeableHttpClient.close();</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (Exception e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prepay_id;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成带支付签名的订单凭据并返回\"><a href=\"#生成带支付签名的订单凭据并返回\" class=\"headerlink\" title=\"生成带支付签名的订单凭据并返回\"></a>生成带支付签名的订单凭据并返回</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WXPay</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">createPackageValue</span><span class=\"params\">(String appid, String appKey, String prepay_id)</span>  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SortedMap&lt;String, String&gt; nativeObj = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;String, String&gt;();</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;appId&quot;</span>, appid);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;timeStamp&quot;</span>, OrderUtil.GetTimestamp());</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">randomStr</span> <span class=\"operator\">=</span> MD5.GetMD5String(String.valueOf(random.nextInt(<span class=\"number\">10000</span>)));</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;nonceStr&quot;</span>, MD5Util.MD5Encode(randomStr, <span class=\"string\">&quot;utf-8&quot;</span>).toLowerCase());</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;package&quot;</span>, <span class=\"string\">&quot;prepay_id=&quot;</span> +prepay_id);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;signType&quot;</span>, <span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;paySign&quot;</span>, createSign(nativeObj, appKey));</span><br><span class=\"line\">    System.out.println(JSONObject.fromObject(nativeObj).toString());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSONObject.fromObject(nativeObj).toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 创建md5摘要,规则是:按参数名称a-z排序,遇到空值的参数不参加签名。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">createSign</span><span class=\"params\">(SortedMap&lt;String, String&gt; packageParams, String AppKey)</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">    <span class=\"type\">Set</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> packageParams.entrySet();</span><br><span class=\"line\">    <span class=\"type\">Iterator</span> <span class=\"variable\">it</span> <span class=\"operator\">=</span> es.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      Map.<span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> (Map.Entry) it.next();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> (String) entry.getKey();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">v</span> <span class=\"operator\">=</span> (String) entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != v &amp;&amp; !<span class=\"string\">&quot;&quot;</span>.equals(v) &amp;&amp; !<span class=\"string\">&quot;sign&quot;</span>.equals(k) &amp;&amp; !<span class=\"string\">&quot;key&quot;</span>.equals(k)) </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        sb.append(k + <span class=\"string\">&quot;=&quot;</span> + v + <span class=\"string\">&quot;&amp;&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sb.append(<span class=\"string\">&quot;key=&quot;</span> + AppKey);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> MD5Util.MD5Encode(sb.toString(), <span class=\"string\">&quot;UTF-8&quot;</span>).toUpperCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调起微信支付（发起微信支付请求）\"><a href=\"#调起微信支付（发起微信支付请求）\" class=\"headerlink\" title=\"调起微信支付（发起微信支付请求）\"></a>调起微信支付（发起微信支付请求）</h2><h2 id=\"用户确认金额并输入支付密码\"><a href=\"#用户确认金额并输入支付密码\" class=\"headerlink\" title=\"用户确认金额并输入支付密码\"></a>用户确认金额并输入支付密码</h2><h2 id=\"向用户展示支付结果\"><a href=\"#向用户展示支付结果\" class=\"headerlink\" title=\"向用户展示支付结果\"></a>向用户展示支付结果</h2><p>参考<br><a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\">JS-SDK-API</a><br><a href=\"https://mp.weixin.qq.com/paymch/readtemplate?t=mp/business/course3_tmpl&lang=zh_CN\">微信支付PDF文档</a><br><a href=\"http://blog.csdn.net/omsvip/article/details/43342957\">这篇文章</a>。</p>\n","site":{"data":{}},"excerpt":"<p>最近做微信公众号开发，用到了<code>网页中调起微信支付</code>的功能，微信公众平台提供的DEMO是基于PHP的，没有Java的，到网上查阅资料也都是<code>V2.x</code>的，而现在微信支付已经更新到了<code>V3.x</code>版本，经过几天的探索，终于成功实现，将实现过程总结下。</p>","more":"<h2 id=\"获取签名证书，初始化JS-API\"><a href=\"#获取签名证书，初始化JS-API\" class=\"headerlink\" title=\"获取签名证书，初始化JS-API\"></a>获取签名证书，初始化JS-API</h2><p>在网页中JS调起微信支付需用到微信JS-SDK，首先得初始化JS-API，后台将<code>签名证书</code>传给前端。</p>\n<ul>\n<li>第一步，获取jsapiTicket<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取AccessToken</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AccessToken <span class=\"title function_\">getAccessToken</span><span class=\"params\">(String appId, String appSecret)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">AccessToken</span> <span class=\"variable\">accessToken</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">requestUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;</span>;</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;APPID&quot;</span>, appId);</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;APPSECRET&quot;</span>, appSecret);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CommonUtil.httpRequest(requestUrl);</span><br><span class=\"line\">  <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> JSONObject.fromObject(result);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsonObject) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      accessToken = <span class=\"keyword\">new</span> <span class=\"title class_\">AccessToken</span>();</span><br><span class=\"line\">      accessToken.setAccess_token(jsonObject.getString(<span class=\"string\">&quot;access_token&quot;</span>));</span><br><span class=\"line\">      accessToken.setExpires_in(jsonObject.getInt(<span class=\"string\">&quot;expires_in&quot;</span>));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      accessToken = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> jsonObject.getInt(<span class=\"string\">&quot;errcode&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;errmsg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accessToken;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取jsapiTicket</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">getJsapiTicket</span><span class=\"params\">(String accessToken)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">jsapiTicket</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">requestUrl</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi&quot;</span>;</span><br><span class=\"line\">  requestUrl = requestUrl.replace(<span class=\"string\">&quot;ACCESS_TOKEN&quot;</span>, accessToken);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> CommonUtil.httpRequest(requestUrl);</span><br><span class=\"line\">  <span class=\"type\">JSONObject</span> <span class=\"variable\">jsonObject</span> <span class=\"operator\">=</span> JSONObject.fromObject(result);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != jsonObject) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      jsapiTicket = jsonObject.getString(<span class=\"string\">&quot;ticket&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">errorCode</span> <span class=\"operator\">=</span> jsonObject.getInt(<span class=\"string\">&quot;errcode&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">errorMsg</span> <span class=\"operator\">=</span> jsonObject.getString(<span class=\"string\">&quot;errmsg&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> jsapiTicket;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<code>access_token和jsapiTicket需控制调用频率</code>，参考<a href=\"http://hellomypastor.net/2015/05/09/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E8%B0%83%E7%94%A8access-token%E6%8E%A5%E5%8F%A3%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E8%A7%A3%E5%86%B3-Java/\">微信公众号调用access_token接口频率限制解决(Java)</a></li>\n<li>第二步，获取sign签名证书<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map&lt;String, String&gt; <span class=\"title function_\">sign</span><span class=\"params\">(String jsapi_ticket, String url)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  Map&lt;String, String&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;();</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">nonce_str</span> <span class=\"operator\">=</span> create_nonce_str();</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> create_timestamp();</span><br><span class=\"line\">  String string1;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">signature</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 注意这里参数名必须全部小写，且必须有序</span></span><br><span class=\"line\">  string1 = <span class=\"string\">&quot;jsapi_ticket=&quot;</span> + jsapi_ticket + <span class=\"string\">&quot;&amp;noncestr=&quot;</span> + nonce_str + <span class=\"string\">&quot;&amp;timestamp=&quot;</span> + timestamp + <span class=\"string\">&quot;&amp;url=&quot;</span> + url;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"type\">MessageDigest</span> <span class=\"variable\">crypt</span> <span class=\"operator\">=</span> MessageDigest.getInstance(<span class=\"string\">&quot;SHA-1&quot;</span>);</span><br><span class=\"line\">    crypt.reset();</span><br><span class=\"line\">    crypt.update(string1.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    signature = byteToHex(crypt.digest());</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;jsapi_ticket&quot;</span>, jsapi_ticket);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;nonceStr&quot;</span>, nonce_str);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;timestamp&quot;</span>, timestamp);</span><br><span class=\"line\">  ret.put(<span class=\"string\">&quot;signature&quot;</span>, signature);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"获取微信支付配置参数\"><a href=\"#获取微信支付配置参数\" class=\"headerlink\" title=\"获取微信支付配置参数\"></a>获取微信支付配置参数</h2><p>微信支付参数需要的有3个:a.微信分配的公众账号ID（appid）;b.微信支付分配的商户号（mch_id&#x2F;PartnerId）；c.商户密钥（PartnerKey）</p>\n<h2 id=\"调用统一下单接口，生成预支付订单号\"><a href=\"#调用统一下单接口，生成预支付订单号\" class=\"headerlink\" title=\"调用统一下单接口，生成预支付订单号\"></a>调用统一下单接口，生成预支付订单号</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 生成预支付订单</span></span><br><span class=\"line\"><span class=\"comment\">* </span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">submitXmlGetPrepayId</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 创建HttpClientBuilder</span></span><br><span class=\"line\">  <span class=\"type\">HttpClientBuilder</span> <span class=\"variable\">httpClientBuilder</span> <span class=\"operator\">=</span> HttpClientBuilder.create();</span><br><span class=\"line\">  <span class=\"type\">HttpPost</span> <span class=\"variable\">httpPost</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpPost</span>(unifiedorder);</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">xml</span> <span class=\"operator\">=</span> getPackage();</span><br><span class=\"line\">  StringEntity entity;</span><br><span class=\"line\">  <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    entity = <span class=\"keyword\">new</span> <span class=\"title class_\">StringEntity</span>(xml, <span class=\"string\">&quot;utf-8&quot;</span>);</span><br><span class=\"line\">    httpPost.setEntity(entity);</span><br><span class=\"line\">    HttpResponse httpResponse;</span><br><span class=\"line\">    httpResponse = closeableHttpClient.execute(httpPost);</span><br><span class=\"line\">    <span class=\"type\">HttpEntity</span> <span class=\"variable\">httpEntity</span> <span class=\"operator\">=</span> httpResponse.getEntity();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpEntity != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      result = result.replaceAll(<span class=\"string\">&quot;&lt;![CDATA[|]]&gt;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">prepay_id</span> <span class=\"operator\">=</span> Jsoup.parse(result).select(<span class=\"string\">&quot;prepay_id&quot;</span>).html();</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.prepay_id = prepay_id;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (prepay_id != <span class=\"literal\">null</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prepay_id;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeableHttpClient.close();</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">catch</span> (Exception e) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prepay_id;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成带支付签名的订单凭据并返回\"><a href=\"#生成带支付签名的订单凭据并返回\" class=\"headerlink\" title=\"生成带支付签名的订单凭据并返回\"></a>生成带支付签名的订单凭据并返回</h2><p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WXPay</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">createPackageValue</span><span class=\"params\">(String appid, String appKey, String prepay_id)</span>  </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    SortedMap&lt;String, String&gt; nativeObj = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;String, String&gt;();</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;appId&quot;</span>, appid);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;timeStamp&quot;</span>, OrderUtil.GetTimestamp());</span><br><span class=\"line\">    <span class=\"type\">Random</span> <span class=\"variable\">random</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">randomStr</span> <span class=\"operator\">=</span> MD5.GetMD5String(String.valueOf(random.nextInt(<span class=\"number\">10000</span>)));</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;nonceStr&quot;</span>, MD5Util.MD5Encode(randomStr, <span class=\"string\">&quot;utf-8&quot;</span>).toLowerCase());</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;package&quot;</span>, <span class=\"string\">&quot;prepay_id=&quot;</span> +prepay_id);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;signType&quot;</span>, <span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">    nativeObj.put(<span class=\"string\">&quot;paySign&quot;</span>, createSign(nativeObj, appKey));</span><br><span class=\"line\">    System.out.println(JSONObject.fromObject(nativeObj).toString());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSONObject.fromObject(nativeObj).toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 创建md5摘要,规则是:按参数名称a-z排序,遇到空值的参数不参加签名。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">createSign</span><span class=\"params\">(SortedMap&lt;String, String&gt; packageParams, String AppKey)</span> </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">    <span class=\"type\">Set</span> <span class=\"variable\">es</span> <span class=\"operator\">=</span> packageParams.entrySet();</span><br><span class=\"line\">    <span class=\"type\">Iterator</span> <span class=\"variable\">it</span> <span class=\"operator\">=</span> es.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      Map.<span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> (Map.Entry) it.next();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> (String) entry.getKey();</span><br><span class=\"line\">      <span class=\"type\">String</span> <span class=\"variable\">v</span> <span class=\"operator\">=</span> (String) entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != v &amp;&amp; !<span class=\"string\">&quot;&quot;</span>.equals(v) &amp;&amp; !<span class=\"string\">&quot;sign&quot;</span>.equals(k) &amp;&amp; !<span class=\"string\">&quot;key&quot;</span>.equals(k)) </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        sb.append(k + <span class=\"string\">&quot;=&quot;</span> + v + <span class=\"string\">&quot;&amp;&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sb.append(<span class=\"string\">&quot;key=&quot;</span> + AppKey);</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">sign</span> <span class=\"operator\">=</span> MD5Util.MD5Encode(sb.toString(), <span class=\"string\">&quot;UTF-8&quot;</span>).toUpperCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sign;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"调起微信支付（发起微信支付请求）\"><a href=\"#调起微信支付（发起微信支付请求）\" class=\"headerlink\" title=\"调起微信支付（发起微信支付请求）\"></a>调起微信支付（发起微信支付请求）</h2><h2 id=\"用户确认金额并输入支付密码\"><a href=\"#用户确认金额并输入支付密码\" class=\"headerlink\" title=\"用户确认金额并输入支付密码\"></a>用户确认金额并输入支付密码</h2><h2 id=\"向用户展示支付结果\"><a href=\"#向用户展示支付结果\" class=\"headerlink\" title=\"向用户展示支付结果\"></a>向用户展示支付结果</h2><p>参考<br><a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\">JS-SDK-API</a><br><a href=\"https://mp.weixin.qq.com/paymch/readtemplate?t=mp/business/course3_tmpl&lang=zh_CN\">微信支付PDF文档</a><br><a href=\"http://blog.csdn.net/omsvip/article/details/43342957\">这篇文章</a>。</p>"},{"title":"阿里Java开发手册思考（一）","date":"2017-12-04T13:13:47.000Z","_content":">旧时王谢堂前燕，\n飞入寻常百姓家。\n小编将带你们一起分析阿里巴巴Java开发手册！\n\n<!--more-->\n##背景\n>阿里巴巴Java开发手册是阿里巴巴集团技术团队的集体智慧结晶和经验总结，以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六个维度。手册的愿景是码出高效、码出质量、效率优先、质量为本。\n\n##目的\n>之所以要写这个系列的文章，首先是学习与总结，其次是思考与理解，更是分享与交流，手册中的每一条每一项都有其背后隐藏的原理与经验，我们看到的只是冰山一角，深入挖掘其背后的知识有益于更深刻的理解，并在自己实际编程中提高自己的基本技术素养。\n\n##主题\n+ 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成:\n\n```java\nif (condition) { \n    ...\n    return obj; \n}\n// 接着写 else 的业务逻辑代码;\n```\n+ 说明:如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维\n护困难，请勿超过 3 层。\n+ 正例:超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现， 其中卫语句示例如下:\n\n```java\npublic void today() { \n    if (isBusy()) {\n        System.out.println(“change time.”); return;\n    }\n    if (isFree()) {\n        System.out.println(“go to travel.”);\n        return; \n    }\n    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);\n    return; \n}\n```\n\n>我们试图通过例子来分析下上面的规则，在分析之前，我们先明确在Java里，默认的equals和hashCode方法的实现，以及把一个元素放入散列集合（HashSet、HashMap等）时，散列集合对equals和hashCode方法的判定规则。\nJava对象中默认的equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。hashCode()方法返回一个int数，这个整数值是将该对象的内部地址转换成一个整数返回的 。\n在散列集合中存储一个对象时，先进行hashCode的比较，如果hashCode不想等，则直接放入，否则继续进行equals的比较，equals不相等才放入，equals相等就直接丢弃了。\n\n##理解\n+ 如果只重写equals而不重写hashCode会导致什么问题？\n\n```java\npackage com.test;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class OverrideEqualsTest {    \n    public static void main(String[] args) {\n        Set<Point> set = new HashSet<Point>();\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(1, 1);\n        System.out.println(\"p1.equals(p2):\" + p1.equals(p2));\n        set.add(p1);\n        set.add(p2);\n        set.add(p1);\n        System.out.println(\"set.size():\" + set.size());        \n        for (Point p : set) {\n            System.out.println(p);\n        }\n    }    \n    static class Point {        \n        private int x;        \n        private int y;        \n        public Point(int x, int y) {            \n            super();            \n            this.x = x;            \n            this.y = y;\n        }        \n        @Override\n        public boolean equals(Object obj) {            \n            if (this == obj) {              \n                return true;  \n            }          \n            if (obj == null) {                \n                return false; \n            }           \n            if (getClass() != obj.getClass()) {                \n                return false;\n            }\n            Point other = (Point) obj;            \n            if (x != other.x) {                \n                return false;  \n            }          \n            if (y != other.y) {               \n                return false;  \n            }          \n            return true;\n        }        \n        @Override\n        public String toString() {            \n            return \"Point [x=\" + x + \", y=\" + y + \"]\";\n        }\n    }\n}\n```\n\n运行结果：\np1.equals(p2):true\nset.size():2\nPoint[x=1,y=1]\nPoint[x=1,y=1]\n>分析：由于没有重写hashCode方法，p1和p2对象默认的hashCode方法返回的两个对象地址转换的整数肯定不同，所以p1和p2都可以放入set中，所以这并不是我们期望的结果。\n\n+ ​如果只重写hashCode而不重写equals又会导致什么问题？\n\n```java\npackage com.test;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class OverrideHashCodeTest {    \n    public static void main(String[] args) {\n        Set<Point> set = new HashSet<Point>();\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(1, 1);\n        System.out.println(\"p1.equals(p2):\" + p1.equals(p2));\n        set.add(p1);\n        set.add(p2);\n        set.add(p1);\n        System.out.println(\"set.size():\" + set.size());        \n        for (Point p : set) {\n            System.out.println(p);\n        }\n    }    \n    static class Point {        \n        private int x;        \n        private int y;        \n        public Point(int x, int y) {            \n            super();            \n            this.x = x;            \n            this.y = y;\n        }        \n        @Override\n        public int hashCode() {            \n            final int prime = 3L;            \n            int result = 1;\n            result = prime * result + x;\n            result = prime * result + y;            \n            return result;\n        }        \n        @Override\n        public String toString() {            \n            return \"Point [x=\" + x + \", y=\" + y + \"]\";\n        }\n    }\n}\n```\n\n运行结果：\np1.equals(p2):false\nset.size():2\nPoint[x=1,y=1]\nPoint[x=1,y=1]\n>分析：由于没有重写equals方法，p1和p2对象的默认的equals方法通过“==”来比较，而p1和p2是两个不同的对象，所以p1和p2都可以放入set中，所以这也不是我们期望的结果。\n所以综上，当我们同时重写equals和hashCode方法后，才能在散列集合操作中得到一致性的结果。\n\n+ 对象放入散列集合后，又修改了影响hashCode的值，后果？\n\n```java\npackage com.test;\npublic class Test {    \n    public static void main(String[] args) {\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(2, 2);\n        set.add(p1);\n        set.add(p2);\n        System.out.println(\"set.size():\" + set.size());\n        p2.setY(3);\n        set.remove(p1);\n        set.remove(p2);\n        System.out.println(\"set.size():\" + set.size());\n    }\n}\n```\n运行结果：\nset.size():2\nset.size():1\n>分析：由于在执行期间，修改了p2对象的y值，导致p2对象的hashCode返回值有变化，所以hashset的remove方法将找不到新的hashCode所映射的对象，导致内存泄漏。","source":"_posts/阿里Java开发手册思考（一）.md","raw":"title: 阿里Java开发手册思考（一）\ndate: 2017-12-04 21:13:47\ncategories: Java\ntags: [Java,阿里Java开发手册]\n---\n>旧时王谢堂前燕，\n飞入寻常百姓家。\n小编将带你们一起分析阿里巴巴Java开发手册！\n\n<!--more-->\n##背景\n>阿里巴巴Java开发手册是阿里巴巴集团技术团队的集体智慧结晶和经验总结，以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六个维度。手册的愿景是码出高效、码出质量、效率优先、质量为本。\n\n##目的\n>之所以要写这个系列的文章，首先是学习与总结，其次是思考与理解，更是分享与交流，手册中的每一条每一项都有其背后隐藏的原理与经验，我们看到的只是冰山一角，深入挖掘其背后的知识有益于更深刻的理解，并在自己实际编程中提高自己的基本技术素养。\n\n##主题\n+ 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成:\n\n```java\nif (condition) { \n    ...\n    return obj; \n}\n// 接着写 else 的业务逻辑代码;\n```\n+ 说明:如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维\n护困难，请勿超过 3 层。\n+ 正例:超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现， 其中卫语句示例如下:\n\n```java\npublic void today() { \n    if (isBusy()) {\n        System.out.println(“change time.”); return;\n    }\n    if (isFree()) {\n        System.out.println(“go to travel.”);\n        return; \n    }\n    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);\n    return; \n}\n```\n\n>我们试图通过例子来分析下上面的规则，在分析之前，我们先明确在Java里，默认的equals和hashCode方法的实现，以及把一个元素放入散列集合（HashSet、HashMap等）时，散列集合对equals和hashCode方法的判定规则。\nJava对象中默认的equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。hashCode()方法返回一个int数，这个整数值是将该对象的内部地址转换成一个整数返回的 。\n在散列集合中存储一个对象时，先进行hashCode的比较，如果hashCode不想等，则直接放入，否则继续进行equals的比较，equals不相等才放入，equals相等就直接丢弃了。\n\n##理解\n+ 如果只重写equals而不重写hashCode会导致什么问题？\n\n```java\npackage com.test;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class OverrideEqualsTest {    \n    public static void main(String[] args) {\n        Set<Point> set = new HashSet<Point>();\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(1, 1);\n        System.out.println(\"p1.equals(p2):\" + p1.equals(p2));\n        set.add(p1);\n        set.add(p2);\n        set.add(p1);\n        System.out.println(\"set.size():\" + set.size());        \n        for (Point p : set) {\n            System.out.println(p);\n        }\n    }    \n    static class Point {        \n        private int x;        \n        private int y;        \n        public Point(int x, int y) {            \n            super();            \n            this.x = x;            \n            this.y = y;\n        }        \n        @Override\n        public boolean equals(Object obj) {            \n            if (this == obj) {              \n                return true;  \n            }          \n            if (obj == null) {                \n                return false; \n            }           \n            if (getClass() != obj.getClass()) {                \n                return false;\n            }\n            Point other = (Point) obj;            \n            if (x != other.x) {                \n                return false;  \n            }          \n            if (y != other.y) {               \n                return false;  \n            }          \n            return true;\n        }        \n        @Override\n        public String toString() {            \n            return \"Point [x=\" + x + \", y=\" + y + \"]\";\n        }\n    }\n}\n```\n\n运行结果：\np1.equals(p2):true\nset.size():2\nPoint[x=1,y=1]\nPoint[x=1,y=1]\n>分析：由于没有重写hashCode方法，p1和p2对象默认的hashCode方法返回的两个对象地址转换的整数肯定不同，所以p1和p2都可以放入set中，所以这并不是我们期望的结果。\n\n+ ​如果只重写hashCode而不重写equals又会导致什么问题？\n\n```java\npackage com.test;\nimport java.util.HashSet;\nimport java.util.Set;\npublic class OverrideHashCodeTest {    \n    public static void main(String[] args) {\n        Set<Point> set = new HashSet<Point>();\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(1, 1);\n        System.out.println(\"p1.equals(p2):\" + p1.equals(p2));\n        set.add(p1);\n        set.add(p2);\n        set.add(p1);\n        System.out.println(\"set.size():\" + set.size());        \n        for (Point p : set) {\n            System.out.println(p);\n        }\n    }    \n    static class Point {        \n        private int x;        \n        private int y;        \n        public Point(int x, int y) {            \n            super();            \n            this.x = x;            \n            this.y = y;\n        }        \n        @Override\n        public int hashCode() {            \n            final int prime = 3L;            \n            int result = 1;\n            result = prime * result + x;\n            result = prime * result + y;            \n            return result;\n        }        \n        @Override\n        public String toString() {            \n            return \"Point [x=\" + x + \", y=\" + y + \"]\";\n        }\n    }\n}\n```\n\n运行结果：\np1.equals(p2):false\nset.size():2\nPoint[x=1,y=1]\nPoint[x=1,y=1]\n>分析：由于没有重写equals方法，p1和p2对象的默认的equals方法通过“==”来比较，而p1和p2是两个不同的对象，所以p1和p2都可以放入set中，所以这也不是我们期望的结果。\n所以综上，当我们同时重写equals和hashCode方法后，才能在散列集合操作中得到一致性的结果。\n\n+ 对象放入散列集合后，又修改了影响hashCode的值，后果？\n\n```java\npackage com.test;\npublic class Test {    \n    public static void main(String[] args) {\n        Point p1 = new Point(1, 1);\n        Point p2 = new Point(2, 2);\n        set.add(p1);\n        set.add(p2);\n        System.out.println(\"set.size():\" + set.size());\n        p2.setY(3);\n        set.remove(p1);\n        set.remove(p2);\n        System.out.println(\"set.size():\" + set.size());\n    }\n}\n```\n运行结果：\nset.size():2\nset.size():1\n>分析：由于在执行期间，修改了p2对象的y值，导致p2对象的hashCode返回值有变化，所以hashset的remove方法将找不到新的hashCode所映射的对象，导致内存泄漏。","slug":"阿里Java开发手册思考（一）","published":1,"updated":"2025-03-07T13:26:47.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz33004arz5md2eq4qdw","content":"<blockquote>\n<p>旧时王谢堂前燕，<br>飞入寻常百姓家。<br>小编将带你们一起分析阿里巴巴Java开发手册！</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##背景</p>\n<blockquote>\n<p>阿里巴巴Java开发手册是阿里巴巴集团技术团队的集体智慧结晶和经验总结，以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六个维度。手册的愿景是码出高效、码出质量、效率优先、质量为本。</p>\n</blockquote>\n<p>##目的</p>\n<blockquote>\n<p>之所以要写这个系列的文章，首先是学习与总结，其次是思考与理解，更是分享与交流，手册中的每一条每一项都有其背后隐藏的原理与经验，我们看到的只是冰山一角，深入挖掘其背后的知识有益于更深刻的理解，并在自己实际编程中提高自己的基本技术素养。</p>\n</blockquote>\n<p>##主题</p>\n<ul>\n<li>【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>说明:如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维<br>护困难，请勿超过 3 层。</li>\n<li>正例:超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现， 其中卫语句示例如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">        System.out.println(“change time.”); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">        System.out.println(“go to travel.”);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我们试图通过例子来分析下上面的规则，在分析之前，我们先明确在Java里，默认的equals和hashCode方法的实现，以及把一个元素放入散列集合（HashSet、HashMap等）时，散列集合对equals和hashCode方法的判定规则。<br>Java对象中默认的equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。hashCode()方法返回一个int数，这个整数值是将该对象的内部地址转换成一个整数返回的 。<br>在散列集合中存储一个对象时，先进行hashCode的比较，如果hashCode不想等，则直接放入，否则继续进行equals的比较，equals不相等才放入，equals相等就直接丢弃了。</p>\n</blockquote>\n<p>##理解</p>\n<ul>\n<li>如果只重写equals而不重写hashCode会导致什么问题？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OverrideEqualsTest</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Set&lt;Point&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Point&gt;();</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;p1.equals(p2):&quot;</span> + p1.equals(p2));</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Point p : set) &#123;</span><br><span class=\"line\">            System.out.println(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> y;        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Point</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;            </span><br><span class=\"line\">            <span class=\"built_in\">super</span>();            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.x = x;            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == obj) &#123;              </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj == <span class=\"literal\">null</span>) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getClass() != obj.getClass()) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Point</span> <span class=\"variable\">other</span> <span class=\"operator\">=</span> (Point) obj;            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x != other.x) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (y != other.y) &#123;               </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Point [x=&quot;</span> + x + <span class=\"string\">&quot;, y=&quot;</span> + y + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br>p1.equals(p2):true<br>set.size():2<br>Point[x&#x3D;1,y&#x3D;1]<br>Point[x&#x3D;1,y&#x3D;1]</p>\n<blockquote>\n<p>分析：由于没有重写hashCode方法，p1和p2对象默认的hashCode方法返回的两个对象地址转换的整数肯定不同，所以p1和p2都可以放入set中，所以这并不是我们期望的结果。</p>\n</blockquote>\n<ul>\n<li>​如果只重写hashCode而不重写equals又会导致什么问题？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OverrideHashCodeTest</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Set&lt;Point&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Point&gt;();</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;p1.equals(p2):&quot;</span> + p1.equals(p2));</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Point p : set) &#123;</span><br><span class=\"line\">            System.out.println(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> y;        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Point</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;            </span><br><span class=\"line\">            <span class=\"built_in\">super</span>();            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.x = x;            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">prime</span> <span class=\"operator\">=</span> <span class=\"number\">3L</span>;            </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            result = prime * result + x;</span><br><span class=\"line\">            result = prime * result + y;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Point [x=&quot;</span> + x + <span class=\"string\">&quot;, y=&quot;</span> + y + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br>p1.equals(p2):false<br>set.size():2<br>Point[x&#x3D;1,y&#x3D;1]<br>Point[x&#x3D;1,y&#x3D;1]</p>\n<blockquote>\n<p>分析：由于没有重写equals方法，p1和p2对象的默认的equals方法通过“&#x3D;&#x3D;”来比较，而p1和p2是两个不同的对象，所以p1和p2都可以放入set中，所以这也不是我们期望的结果。<br>所以综上，当我们同时重写equals和hashCode方法后，才能在散列集合操作中得到一致性的结果。</p>\n</blockquote>\n<ul>\n<li>对象放入散列集合后，又修改了影响hashCode的值，后果？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());</span><br><span class=\"line\">        p2.setY(<span class=\"number\">3</span>);</span><br><span class=\"line\">        set.remove(p1);</span><br><span class=\"line\">        set.remove(p2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>set.size():2<br>set.size():1</p>\n<blockquote>\n<p>分析：由于在执行期间，修改了p2对象的y值，导致p2对象的hashCode返回值有变化，所以hashset的remove方法将找不到新的hashCode所映射的对象，导致内存泄漏。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>旧时王谢堂前燕，<br>飞入寻常百姓家。<br>小编将带你们一起分析阿里巴巴Java开发手册！</p>\n</blockquote>","more":"<p>##背景</p>\n<blockquote>\n<p>阿里巴巴Java开发手册是阿里巴巴集团技术团队的集体智慧结晶和经验总结，以Java开发者为中心视角，划分为编程规约、异常日志、单元测试、安全规约、工程结构、MySQL数据库六个维度。手册的愿景是码出高效、码出质量、效率优先、质量为本。</p>\n</blockquote>\n<p>##目的</p>\n<blockquote>\n<p>之所以要写这个系列的文章，首先是学习与总结，其次是思考与理解，更是分享与交流，手册中的每一条每一项都有其背后隐藏的原理与经验，我们看到的只是冰山一角，深入挖掘其背后的知识有益于更深刻的理解，并在自己实际编程中提高自己的基本技术素养。</p>\n</blockquote>\n<p>##主题</p>\n<ul>\n<li>【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition) &#123; </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 接着写 else 的业务逻辑代码;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>说明:如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维<br>护困难，请勿超过 3 层。</li>\n<li>正例:超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现， 其中卫语句示例如下:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">        System.out.println(“change time.”); <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">        System.out.println(“go to travel.”);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>我们试图通过例子来分析下上面的规则，在分析之前，我们先明确在Java里，默认的equals和hashCode方法的实现，以及把一个元素放入散列集合（HashSet、HashMap等）时，散列集合对equals和hashCode方法的判定规则。<br>Java对象中默认的equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。hashCode()方法返回一个int数，这个整数值是将该对象的内部地址转换成一个整数返回的 。<br>在散列集合中存储一个对象时，先进行hashCode的比较，如果hashCode不想等，则直接放入，否则继续进行equals的比较，equals不相等才放入，equals相等就直接丢弃了。</p>\n</blockquote>\n<p>##理解</p>\n<ul>\n<li>如果只重写equals而不重写hashCode会导致什么问题？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OverrideEqualsTest</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Set&lt;Point&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Point&gt;();</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;p1.equals(p2):&quot;</span> + p1.equals(p2));</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Point p : set) &#123;</span><br><span class=\"line\">            System.out.println(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> y;        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Point</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;            </span><br><span class=\"line\">            <span class=\"built_in\">super</span>();            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.x = x;            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">equals</span><span class=\"params\">(Object obj)</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> == obj) &#123;              </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj == <span class=\"literal\">null</span>) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; </span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getClass() != obj.getClass()) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">Point</span> <span class=\"variable\">other</span> <span class=\"operator\">=</span> (Point) obj;            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x != other.x) &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (y != other.y) &#123;               </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;  </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Point [x=&quot;</span> + x + <span class=\"string\">&quot;, y=&quot;</span> + y + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br>p1.equals(p2):true<br>set.size():2<br>Point[x&#x3D;1,y&#x3D;1]<br>Point[x&#x3D;1,y&#x3D;1]</p>\n<blockquote>\n<p>分析：由于没有重写hashCode方法，p1和p2对象默认的hashCode方法返回的两个对象地址转换的整数肯定不同，所以p1和p2都可以放入set中，所以这并不是我们期望的结果。</p>\n</blockquote>\n<ul>\n<li>​如果只重写hashCode而不重写equals又会导致什么问题？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OverrideHashCodeTest</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Set&lt;Point&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;Point&gt;();</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;p1.equals(p2):&quot;</span> + p1.equals(p2));</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Point p : set) &#123;</span><br><span class=\"line\">            System.out.println(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> x;        </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> y;        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">Point</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;            </span><br><span class=\"line\">            <span class=\"built_in\">super</span>();            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.x = x;            </span><br><span class=\"line\">            <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">prime</span> <span class=\"operator\">=</span> <span class=\"number\">3L</span>;            </span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            result = prime * result + x;</span><br><span class=\"line\">            result = prime * result + y;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Point [x=&quot;</span> + x + <span class=\"string\">&quot;, y=&quot;</span> + y + <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br>p1.equals(p2):false<br>set.size():2<br>Point[x&#x3D;1,y&#x3D;1]<br>Point[x&#x3D;1,y&#x3D;1]</p>\n<blockquote>\n<p>分析：由于没有重写equals方法，p1和p2对象的默认的equals方法通过“&#x3D;&#x3D;”来比较，而p1和p2是两个不同的对象，所以p1和p2都可以放入set中，所以这也不是我们期望的结果。<br>所以综上，当我们同时重写equals和hashCode方法后，才能在散列集合操作中得到一致性的结果。</p>\n</blockquote>\n<ul>\n<li>对象放入散列集合后，又修改了影响hashCode的值，后果？</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.test;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">Point</span> <span class=\"variable\">p2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Point</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        set.add(p1);</span><br><span class=\"line\">        set.add(p2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());</span><br><span class=\"line\">        p2.setY(<span class=\"number\">3</span>);</span><br><span class=\"line\">        set.remove(p1);</span><br><span class=\"line\">        set.remove(p2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;set.size():&quot;</span> + set.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：<br>set.size():2<br>set.size():1</p>\n<blockquote>\n<p>分析：由于在执行期间，修改了p2对象的y值，导致p2对象的hashCode返回值有变化，所以hashset的remove方法将找不到新的hashCode所映射的对象，导致内存泄漏。</p>\n</blockquote>"},{"title":"阿里Java开发手册思考（三）","date":"2017-12-09T01:04:00.000Z","_content":">上期我们分享了Java中if/else复杂逻辑的处理\n>\n>本期我们将分享Java中日志的处理（上）\n\n<!--more-->\n>想必大家都用过日志，虽然日志看起来可有可无，但是等到出问题的时候，日志就派上了大用场，所以说日志打得好不好，规范不规范，直接影响了解决生产环境故障的效率，日志打的不好，有可能影响环境的性能，也有可能影响排查问题的难易程度，有可能排查问题的时间比写代码的时间还有多。\n>\n>那么我们就来分析下阿里Java开发手册--日志规约第一条：\n>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n```java \nimport org.slf4j.Logger; \nimport org.slf4j.LoggerFactory; \nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n```\n\n##日志框架\nJava中的日志框架分如下几种：\n\n+ `Log4j` Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。\n\n+ `Log4j 2` Apache Log4j 2是apache开发的一款Log4j的升级产品。\n\n+ `Commons Logging` Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。\n\n+ `Slf4j` 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。\n\n+ `Logback` 一套日志组件的实现(slf4j阵营)。\n\n+ `Jul` (Java Util Logging),自Java1.4以来的官方日志实现。\n\n##使用示例\n+ **Jul**\n\n```java\nimport java.util.logging.Logger;\n\nprivate static final Logger logger = Logger.getLogger(\"name\");\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Log4j**\n\n```java\nimport org.apache.log4j.Logger;\n\nprivate static final Logger logger = Logger.getLogger(Abc.class.getNeme());\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Commons Logging**\n\n```java\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nprivate static final Log logger = LogFactory.getLogger(Abc.class);\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Slf4j**\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error {}\", e.getMessage(), e);\n}\n\nlogger.debug(\".....{}\", name);\n```\n* **Jul**\n    * 不支持占位符\n    * 具体日志实现\n* **Log4j**\n    * 不支持占位符\n    * 具体日志实现\n* **Logback**\n    * 不支持占位符\n    * 具体日志实现\n* **Commons Logging**\n    * 不支持占位符\n    * 日志门面\n* **Slf4j**\n    * 支持占位符\n    * 日志门面\n\n>Slf4j中有一个很重要的特性：`占位符`，{}可以拼接任意`字符串`，相比如其他框架的优点即不需要用`+`来拼接字符串，也就不会创建新的字符串对象，所以像log4j中需要加`isDebugEnabled()`的判断就是这个道理，在slf4j中就不需要加判断。\n\n##门面模式\n门面(Facade)模式，又称外观模式，对外隐藏了系统的复杂性，并向客户端提供了可以访问的接口，门面模式的好处是将客户端和子系统松耦合，方便子系统的扩展和维护。\n\n正是门面模式这样的特点，使用Slf4j门面，不管日志组件使用的是log4j还是logback等等，对于调用者而言并不关心使用的是什么日志组件，而且对于日志组件的更换或者升级，调用的地方也不要做任何修改。\n\n##源码分析\n\n此处应有代（zhang）码（sheng）：\n\n>首先使用静态工厂来获取Logger对象，传入的class，最终会转化为name，每个类的日志处理可能不同，所以根据传入类的名字来判断类的实现方式\n\n```java\npublic static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n}\n\npublic static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n}\n```\n\n>真正核心的在getILoggerFactory()中，首先判断初始化的状态`INITIALIZATION_STATE`，如果没有初始化`UNINITIALIZED`，那么会更改状态为正在初始化`ONGOING_INITIALIZATION`，并执行初始化`performInitialization()`，初始化完成之后，判断初始化的状态，如果初始化成功`SUCCESSFUL_INITIALIZATION`，那么会通过`StaticLoggerBinder`获取日志工厂`getLoggerFactory()`，这里又涉及到了`单例模式`。\n\n```java\npublic static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n        INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n        performInitialization();\n    }\n    switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(\"org.slf4j.LoggerFactory could not be successfully initialized. See also http://www.slf4j.org/codes.html#unsuccessfulInit\");\n        case ONGOING_INITIALIZATION:\n            return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n}\n```\n\n>接着我们分析`performInitialization`是如何初始化的，首先是执行`bind()`方法，然后判断如果状态为初始化成功`SUCCESSFUL_INITIALIZATION`，执行版本检查，主要是检查jdk版本与slf4j的版本，看是否匹配。\n\n```java\nprivate static final void performInitialization() {\n    bind();\n    if (INITIALIZATION_STATE == 3) {\n        versionSanityCheck();\n    }\n}\n```\n\n>bind()方法，首先获取实现日志的加载路径，检查路径是否合法，然后初始化StaticLoggerBinder的对象，寻找合适的实现方式使用。\n\n```java\nprivate static final void bind() {\n    try {\n        Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n        reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n\n        StaticLoggerBinder.getSingleton();\n        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n        reportActualBinding(staticLoggerBinderPathSet);\n        emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n        String msg = ncde.getMessage();\n        if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n            Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n            Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n            Util.report(\"See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\");\n        } else {\n            failedBinding(ncde);\n            throw ncde;\n        }\n    } catch (NoSuchMethodError nsme) {\n        String msg = nsme.getMessage();\n        if ((msg != null) && (msg.indexOf(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\") != -1)) {\n            INITIALIZATION_STATE = FAILED_INITIALIZATION;\n            Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n            Util.report(\"Your binding is version 1.5.5 or earlier.\");\n            Util.report(\"Upgrade your binding to version 1.6.x.\");\n        }\n        throw nsme;\n    } catch (Exception e) {\n        failedBinding(e);\n        throw new IllegalStateException(\"Unexpected initialization failure\", e);\n    }\n}\n```\n\n>可以看出，bind()方法中最重要的方法就是寻找实现方式`findPossibleStaticLoggerBinderPathSet`，具体方法实现如下：\n\n```java\nprivate static Set findPossibleStaticLoggerBinderPathSet() {\n    Set staticLoggerBinderPathSet = new LinkedHashSet();\n    try {\n        ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n        Enumeration paths;\n        Enumeration paths;\n        if (loggerFactoryClassLoader == null) {\n            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n        } else {\n            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n        }\n\n        while (paths.hasMoreElements()) {\n            URL path = (URL)paths.nextElement();\n            staticLoggerBinderPathSet.add(path);\n        }\n    } catch (IOException ioe) {\n        Util.report(\"Error getting resources from path\", ioe);\n    }\n    return staticLoggerBinderPathSet;\n}\n```\n\n>**注意！！前方高能！！**\n\n>Slf4j的绝妙之处就在于此，类加载器加载类，也就是说寻找StaticLoggerBinder.class文件，然后只要实现了这个类的日志组件，都可以作为一种实现，如果有多个实现，那么谁先加载就使用谁，这个地方涉及`JVM的类加载机制`\n\n##桥接\n+ **Slf4j与其他日志组件的桥接（Bridge）**\n\n* **slf4j-log4j12-1.7.13.jar**\n    * log4j1.2版本的桥接器\n* **slf4j-jdk14-1.7.13.jar**\n    * java.util.logging的桥接器\n* **slf4j-nop-1.7.13.jar**\n    * NOP桥接器\n* **slf4j-simple-1.7.13.jar**\n    * 一个简单实现的桥接器\n* **slf4j-jcl-1.7.13.jar**\n    * Jakarta Commons Logging 的桥接器. 这个桥接器将SLF4j所有日志委派给JCL\n* **logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)**\n    * slf4j的原生实现，logback直接实现了slf4j的接口，因此使用slf4j与logback的结合使用也意味更小的内存与计算开销\n\n[Slf4j Manual](https://www.slf4j.org/manual.html)中有一张图清晰的展示了接入方式，如下：\n\n![桥接](http://upload-images.jianshu.io/upload_images/6851748-1f6febd8ef94bc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ **Bridging legacy APIs（桥接遗留的api）**\n\n>* **log4j-over-slf4j-version.jar**\n    * 将log4j重定向到slf4j\n* **jcl-over-slf4j-version.jar**\n    * 将commos logging里的Simple Logger重定向到slf4j\n* **jul-to-slf4j-version.jar**\n    * 将Java Util Logging重定向到slf4j\n\n![桥接遗留api](http://upload-images.jianshu.io/upload_images/6851748-6c4d2a7f090aeafe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ **桥接注意事项**\n\n>在使用slf4j桥接时要注意避免形成死循环，在项目依赖的jar包中不要存在以下情况\n\n>* **log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在**\n  * 从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环\n* **jul-to-slf4j.jar和slf4j-jdk14.jar同时存在**\n  * 从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环\n\n##总结\n* 为了更好的了解Slf4j，你需要了解：\n    * **JVM类加载机制**\n    * **设计模式：门面模式、桥接模式**\n\n* 简单总结Slf4j的原理：\n    * 通过工厂类，提供一个的接口，用户可以通过这个门面，直接使用API实现日志的记录。\n    * 而具体实现由Slf4j来寻找加载，寻找的过程，就是通过类加载加载**org/slf4j/impl/StaticLoggerBinder.class**的文件，只要实现了这个文件的日志实现系统，都可以作为一种实现方式。\n    * 如果找到很多种方式，那么就寻找一种默认的方式。\n    * 这就是日志接口的工作方式，**简单高效**，关键是**完全解耦**，不需要日志实现部分提供任何的修改配置，只需要符合接口的标准就可以加载进来，**有利于维护和各个类的日志处理方式统一**。","source":"_posts/阿里Java开发手册思考（三）.md","raw":"title: 阿里Java开发手册思考（三）\ndate: 2017-12-09 09:04:00\ncategories: Java\ntags: [Java,阿里Java开发手册]\n---\n>上期我们分享了Java中if/else复杂逻辑的处理\n>\n>本期我们将分享Java中日志的处理（上）\n\n<!--more-->\n>想必大家都用过日志，虽然日志看起来可有可无，但是等到出问题的时候，日志就派上了大用场，所以说日志打得好不好，规范不规范，直接影响了解决生产环境故障的效率，日志打的不好，有可能影响环境的性能，也有可能影响排查问题的难易程度，有可能排查问题的时间比写代码的时间还有多。\n>\n>那么我们就来分析下阿里Java开发手册--日志规约第一条：\n>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。\n```java \nimport org.slf4j.Logger; \nimport org.slf4j.LoggerFactory; \nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n```\n\n##日志框架\nJava中的日志框架分如下几种：\n\n+ `Log4j` Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。\n\n+ `Log4j 2` Apache Log4j 2是apache开发的一款Log4j的升级产品。\n\n+ `Commons Logging` Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。\n\n+ `Slf4j` 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。\n\n+ `Logback` 一套日志组件的实现(slf4j阵营)。\n\n+ `Jul` (Java Util Logging),自Java1.4以来的官方日志实现。\n\n##使用示例\n+ **Jul**\n\n```java\nimport java.util.logging.Logger;\n\nprivate static final Logger logger = Logger.getLogger(\"name\");\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Log4j**\n\n```java\nimport org.apache.log4j.Logger;\n\nprivate static final Logger logger = Logger.getLogger(Abc.class.getNeme());\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Commons Logging**\n\n```java\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nprivate static final Log logger = LogFactory.getLogger(Abc.class);\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error\");\n}\n\nif(logger.isDebugEnabled()) {\n    logger.debug(\".....\" + name);\n}\n```\n\n+ **Slf4j**\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nprivate static final Logger logger = LoggerFactory.getLogger(Abc.class);\n...\ntry {\n...\n} catch (Exception e) {\n    logger.error(\".....error {}\", e.getMessage(), e);\n}\n\nlogger.debug(\".....{}\", name);\n```\n* **Jul**\n    * 不支持占位符\n    * 具体日志实现\n* **Log4j**\n    * 不支持占位符\n    * 具体日志实现\n* **Logback**\n    * 不支持占位符\n    * 具体日志实现\n* **Commons Logging**\n    * 不支持占位符\n    * 日志门面\n* **Slf4j**\n    * 支持占位符\n    * 日志门面\n\n>Slf4j中有一个很重要的特性：`占位符`，{}可以拼接任意`字符串`，相比如其他框架的优点即不需要用`+`来拼接字符串，也就不会创建新的字符串对象，所以像log4j中需要加`isDebugEnabled()`的判断就是这个道理，在slf4j中就不需要加判断。\n\n##门面模式\n门面(Facade)模式，又称外观模式，对外隐藏了系统的复杂性，并向客户端提供了可以访问的接口，门面模式的好处是将客户端和子系统松耦合，方便子系统的扩展和维护。\n\n正是门面模式这样的特点，使用Slf4j门面，不管日志组件使用的是log4j还是logback等等，对于调用者而言并不关心使用的是什么日志组件，而且对于日志组件的更换或者升级，调用的地方也不要做任何修改。\n\n##源码分析\n\n此处应有代（zhang）码（sheng）：\n\n>首先使用静态工厂来获取Logger对象，传入的class，最终会转化为name，每个类的日志处理可能不同，所以根据传入类的名字来判断类的实现方式\n\n```java\npublic static Logger getLogger(Class clazz) {\n    return getLogger(clazz.getName());\n}\n\npublic static Logger getLogger(String name) {\n    ILoggerFactory iLoggerFactory = getILoggerFactory();\n    return iLoggerFactory.getLogger(name);\n}\n```\n\n>真正核心的在getILoggerFactory()中，首先判断初始化的状态`INITIALIZATION_STATE`，如果没有初始化`UNINITIALIZED`，那么会更改状态为正在初始化`ONGOING_INITIALIZATION`，并执行初始化`performInitialization()`，初始化完成之后，判断初始化的状态，如果初始化成功`SUCCESSFUL_INITIALIZATION`，那么会通过`StaticLoggerBinder`获取日志工厂`getLoggerFactory()`，这里又涉及到了`单例模式`。\n\n```java\npublic static ILoggerFactory getILoggerFactory() {\n    if (INITIALIZATION_STATE == UNINITIALIZED) {\n        INITIALIZATION_STATE = ONGOING_INITIALIZATION;\n        performInitialization();\n    }\n    switch (INITIALIZATION_STATE) {\n        case SUCCESSFUL_INITIALIZATION:\n            return StaticLoggerBinder.getSingleton().getLoggerFactory();\n        case NOP_FALLBACK_INITIALIZATION:\n            return NOP_FALLBACK_FACTORY;\n        case FAILED_INITIALIZATION:\n            throw new IllegalStateException(\"org.slf4j.LoggerFactory could not be successfully initialized. See also http://www.slf4j.org/codes.html#unsuccessfulInit\");\n        case ONGOING_INITIALIZATION:\n            return TEMP_FACTORY;\n    }\n    throw new IllegalStateException(\"Unreachable code\");\n}\n```\n\n>接着我们分析`performInitialization`是如何初始化的，首先是执行`bind()`方法，然后判断如果状态为初始化成功`SUCCESSFUL_INITIALIZATION`，执行版本检查，主要是检查jdk版本与slf4j的版本，看是否匹配。\n\n```java\nprivate static final void performInitialization() {\n    bind();\n    if (INITIALIZATION_STATE == 3) {\n        versionSanityCheck();\n    }\n}\n```\n\n>bind()方法，首先获取实现日志的加载路径，检查路径是否合法，然后初始化StaticLoggerBinder的对象，寻找合适的实现方式使用。\n\n```java\nprivate static final void bind() {\n    try {\n        Set staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();\n        reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);\n\n        StaticLoggerBinder.getSingleton();\n        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;\n        reportActualBinding(staticLoggerBinderPathSet);\n        emitSubstituteLoggerWarning();\n    } catch (NoClassDefFoundError ncde) {\n        String msg = ncde.getMessage();\n        if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {\n            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;\n            Util.report(\"Failed to load class \\\"org.slf4j.impl.StaticLoggerBinder\\\".\");\n            Util.report(\"Defaulting to no-operation (NOP) logger implementation\");\n            Util.report(\"See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\");\n        } else {\n            failedBinding(ncde);\n            throw ncde;\n        }\n    } catch (NoSuchMethodError nsme) {\n        String msg = nsme.getMessage();\n        if ((msg != null) && (msg.indexOf(\"org.slf4j.impl.StaticLoggerBinder.getSingleton()\") != -1)) {\n            INITIALIZATION_STATE = FAILED_INITIALIZATION;\n            Util.report(\"slf4j-api 1.6.x (or later) is incompatible with this binding.\");\n            Util.report(\"Your binding is version 1.5.5 or earlier.\");\n            Util.report(\"Upgrade your binding to version 1.6.x.\");\n        }\n        throw nsme;\n    } catch (Exception e) {\n        failedBinding(e);\n        throw new IllegalStateException(\"Unexpected initialization failure\", e);\n    }\n}\n```\n\n>可以看出，bind()方法中最重要的方法就是寻找实现方式`findPossibleStaticLoggerBinderPathSet`，具体方法实现如下：\n\n```java\nprivate static Set findPossibleStaticLoggerBinderPathSet() {\n    Set staticLoggerBinderPathSet = new LinkedHashSet();\n    try {\n        ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();\n        Enumeration paths;\n        Enumeration paths;\n        if (loggerFactoryClassLoader == null) {\n            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);\n        } else {\n            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);\n        }\n\n        while (paths.hasMoreElements()) {\n            URL path = (URL)paths.nextElement();\n            staticLoggerBinderPathSet.add(path);\n        }\n    } catch (IOException ioe) {\n        Util.report(\"Error getting resources from path\", ioe);\n    }\n    return staticLoggerBinderPathSet;\n}\n```\n\n>**注意！！前方高能！！**\n\n>Slf4j的绝妙之处就在于此，类加载器加载类，也就是说寻找StaticLoggerBinder.class文件，然后只要实现了这个类的日志组件，都可以作为一种实现，如果有多个实现，那么谁先加载就使用谁，这个地方涉及`JVM的类加载机制`\n\n##桥接\n+ **Slf4j与其他日志组件的桥接（Bridge）**\n\n* **slf4j-log4j12-1.7.13.jar**\n    * log4j1.2版本的桥接器\n* **slf4j-jdk14-1.7.13.jar**\n    * java.util.logging的桥接器\n* **slf4j-nop-1.7.13.jar**\n    * NOP桥接器\n* **slf4j-simple-1.7.13.jar**\n    * 一个简单实现的桥接器\n* **slf4j-jcl-1.7.13.jar**\n    * Jakarta Commons Logging 的桥接器. 这个桥接器将SLF4j所有日志委派给JCL\n* **logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)**\n    * slf4j的原生实现，logback直接实现了slf4j的接口，因此使用slf4j与logback的结合使用也意味更小的内存与计算开销\n\n[Slf4j Manual](https://www.slf4j.org/manual.html)中有一张图清晰的展示了接入方式，如下：\n\n![桥接](http://upload-images.jianshu.io/upload_images/6851748-1f6febd8ef94bc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ **Bridging legacy APIs（桥接遗留的api）**\n\n>* **log4j-over-slf4j-version.jar**\n    * 将log4j重定向到slf4j\n* **jcl-over-slf4j-version.jar**\n    * 将commos logging里的Simple Logger重定向到slf4j\n* **jul-to-slf4j-version.jar**\n    * 将Java Util Logging重定向到slf4j\n\n![桥接遗留api](http://upload-images.jianshu.io/upload_images/6851748-6c4d2a7f090aeafe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n+ **桥接注意事项**\n\n>在使用slf4j桥接时要注意避免形成死循环，在项目依赖的jar包中不要存在以下情况\n\n>* **log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在**\n  * 从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环\n* **jul-to-slf4j.jar和slf4j-jdk14.jar同时存在**\n  * 从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环\n\n##总结\n* 为了更好的了解Slf4j，你需要了解：\n    * **JVM类加载机制**\n    * **设计模式：门面模式、桥接模式**\n\n* 简单总结Slf4j的原理：\n    * 通过工厂类，提供一个的接口，用户可以通过这个门面，直接使用API实现日志的记录。\n    * 而具体实现由Slf4j来寻找加载，寻找的过程，就是通过类加载加载**org/slf4j/impl/StaticLoggerBinder.class**的文件，只要实现了这个文件的日志实现系统，都可以作为一种实现方式。\n    * 如果找到很多种方式，那么就寻找一种默认的方式。\n    * 这就是日志接口的工作方式，**简单高效**，关键是**完全解耦**，不需要日志实现部分提供任何的修改配置，只需要符合接口的标准就可以加载进来，**有利于维护和各个类的日志处理方式统一**。","slug":"阿里Java开发手册思考（三）","published":1,"updated":"2025-03-07T13:26:47.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz34004erz5m36zg6qfs","content":"<blockquote>\n<p>上期我们分享了Java中if&#x2F;else复杂逻辑的处理</p>\n<p>本期我们将分享Java中日志的处理（上）</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>想必大家都用过日志，虽然日志看起来可有可无，但是等到出问题的时候，日志就派上了大用场，所以说日志打得好不好，规范不规范，直接影响了解决生产环境故障的效率，日志打的不好，有可能影响环境的性能，也有可能影响排查问题的难易程度，有可能排查问题的时间比写代码的时间还有多。</p>\n<p>那么我们就来分析下阿里Java开发手册–日志规约第一条：<br>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger; </span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory; </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Abc.class);</span><br></pre></td></tr></table></figure>\n\n<p>##日志框架<br>Java中的日志框架分如下几种：</p>\n<ul>\n<li><p><code>Log4j</code> Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。</p>\n</li>\n<li><p><code>Log4j 2</code> Apache Log4j 2是apache开发的一款Log4j的升级产品。</p>\n</li>\n<li><p><code>Commons Logging</code> Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。</p>\n</li>\n<li><p><code>Slf4j</code> 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</p>\n</li>\n<li><p><code>Logback</code> 一套日志组件的实现(slf4j阵营)。</p>\n</li>\n<li><p><code>Jul</code> (Java Util Logging),自Java1.4以来的官方日志实现。</p>\n</li>\n</ul>\n<p>##使用示例</p>\n<ul>\n<li><strong>Jul</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> Logger.getLogger(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Log4j</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.log4j.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> Logger.getLogger(Abc.class.getNeme());</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Commons Logging</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LogFactory.getLogger(Abc.class);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Slf4j</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Abc.class);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logger.debug(<span class=\"string\">&quot;.....&#123;&#125;&quot;</span>, name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Jul</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Log4j</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Logback</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Commons Logging</strong><ul>\n<li>不支持占位符</li>\n<li>日志门面</li>\n</ul>\n</li>\n<li><strong>Slf4j</strong><ul>\n<li>支持占位符</li>\n<li>日志门面</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Slf4j中有一个很重要的特性：<code>占位符</code>，{}可以拼接任意<code>字符串</code>，相比如其他框架的优点即不需要用<code>+</code>来拼接字符串，也就不会创建新的字符串对象，所以像log4j中需要加<code>isDebugEnabled()</code>的判断就是这个道理，在slf4j中就不需要加判断。</p>\n</blockquote>\n<p>##门面模式<br>门面(Facade)模式，又称外观模式，对外隐藏了系统的复杂性，并向客户端提供了可以访问的接口，门面模式的好处是将客户端和子系统松耦合，方便子系统的扩展和维护。</p>\n<p>正是门面模式这样的特点，使用Slf4j门面，不管日志组件使用的是log4j还是logback等等，对于调用者而言并不关心使用的是什么日志组件，而且对于日志组件的更换或者升级，调用的地方也不要做任何修改。</p>\n<p>##源码分析</p>\n<p>此处应有代（zhang）码（sheng）：</p>\n<blockquote>\n<p>首先使用静态工厂来获取Logger对象，传入的class，最终会转化为name，每个类的日志处理可能不同，所以根据传入类的名字来判断类的实现方式</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getLogger</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getLogger(clazz.getName());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getLogger</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ILoggerFactory</span> <span class=\"variable\">iLoggerFactory</span> <span class=\"operator\">=</span> getILoggerFactory();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iLoggerFactory.getLogger(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>真正核心的在getILoggerFactory()中，首先判断初始化的状态<code>INITIALIZATION_STATE</code>，如果没有初始化<code>UNINITIALIZED</code>，那么会更改状态为正在初始化<code>ONGOING_INITIALIZATION</code>，并执行初始化<code>performInitialization()</code>，初始化完成之后，判断初始化的状态，如果初始化成功<code>SUCCESSFUL_INITIALIZATION</code>，那么会通过<code>StaticLoggerBinder</code>获取日志工厂<code>getLoggerFactory()</code>，这里又涉及到了<code>单例模式</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ILoggerFactory <span class=\"title function_\">getILoggerFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class=\"line\">        INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class=\"line\">        performInitialization();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class=\"line\">        <span class=\"keyword\">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> NOP_FALLBACK_FACTORY;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FAILED_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;org.slf4j.LoggerFactory could not be successfully initialized. See also http://www.slf4j.org/codes.html#unsuccessfulInit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ONGOING_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> TEMP_FACTORY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unreachable code&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接着我们分析<code>performInitialization</code>是如何初始化的，首先是执行<code>bind()</code>方法，然后判断如果状态为初始化成功<code>SUCCESSFUL_INITIALIZATION</code>，执行版本检查，主要是检查jdk版本与slf4j的版本，看是否匹配。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">performInitialization</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    bind();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INITIALIZATION_STATE == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        versionSanityCheck();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bind()方法，首先获取实现日志的加载路径，检查路径是否合法，然后初始化StaticLoggerBinder的对象，寻找合适的实现方式使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">staticLoggerBinderPathSet</span> <span class=\"operator\">=</span> findPossibleStaticLoggerBinderPathSet();</span><br><span class=\"line\">        reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class=\"line\"></span><br><span class=\"line\">        StaticLoggerBinder.getSingleton();</span><br><span class=\"line\">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class=\"line\">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class=\"line\">        emitSubstituteLoggerWarning();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> ncde.getMessage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class=\"line\">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Failed to load class \\&quot;org.slf4j.impl.StaticLoggerBinder\\&quot;.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Defaulting to no-operation (NOP) logger implementation&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            failedBinding(ncde);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ncde;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodError nsme) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> nsme.getMessage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((msg != <span class=\"literal\">null</span>) &amp;&amp; (msg.indexOf(<span class=\"string\">&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;</span>) != -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Your binding is version 1.5.5 or earlier.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Upgrade your binding to version 1.6.x.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> nsme;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        failedBinding(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unexpected initialization failure&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看出，bind()方法中最重要的方法就是寻找实现方式<code>findPossibleStaticLoggerBinderPathSet</code>，具体方法实现如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Set <span class=\"title function_\">findPossibleStaticLoggerBinderPathSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Set</span> <span class=\"variable\">staticLoggerBinderPathSet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashSet</span>();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loggerFactoryClassLoader</span> <span class=\"operator\">=</span> LoggerFactory.class.getClassLoader();</span><br><span class=\"line\">        Enumeration paths;</span><br><span class=\"line\">        Enumeration paths;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loggerFactoryClassLoader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (paths.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"type\">URL</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (URL)paths.nextElement();</span><br><span class=\"line\">            staticLoggerBinderPathSet.add(path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        Util.report(<span class=\"string\">&quot;Error getting resources from path&quot;</span>, ioe);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> staticLoggerBinderPathSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意！！前方高能！！</strong></p>\n</blockquote>\n<blockquote>\n<p>Slf4j的绝妙之处就在于此，类加载器加载类，也就是说寻找StaticLoggerBinder.class文件，然后只要实现了这个类的日志组件，都可以作为一种实现，如果有多个实现，那么谁先加载就使用谁，这个地方涉及<code>JVM的类加载机制</code></p>\n</blockquote>\n<p>##桥接</p>\n<ul>\n<li><strong>Slf4j与其他日志组件的桥接（Bridge）</strong></li>\n</ul>\n<ul>\n<li><strong>slf4j-log4j12-1.7.13.jar</strong><ul>\n<li>log4j1.2版本的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-jdk14-1.7.13.jar</strong><ul>\n<li>java.util.logging的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-nop-1.7.13.jar</strong><ul>\n<li>NOP桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-simple-1.7.13.jar</strong><ul>\n<li>一个简单实现的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-jcl-1.7.13.jar</strong><ul>\n<li>Jakarta Commons Logging 的桥接器. 这个桥接器将SLF4j所有日志委派给JCL</li>\n</ul>\n</li>\n<li><strong>logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)</strong><ul>\n<li>slf4j的原生实现，logback直接实现了slf4j的接口，因此使用slf4j与logback的结合使用也意味更小的内存与计算开销</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.slf4j.org/manual.html\">Slf4j Manual</a>中有一张图清晰的展示了接入方式，如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6851748-1f6febd8ef94bc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"桥接\"></p>\n<ul>\n<li><strong>Bridging legacy APIs（桥接遗留的api）</strong></li>\n</ul>\n<blockquote>\n<ul>\n<li><strong>log4j-over-slf4j-version.jar</strong><ul>\n<li>将log4j重定向到slf4j</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>jcl-over-slf4j-version.jar</strong><ul>\n<li>将commos logging里的Simple Logger重定向到slf4j</li>\n</ul>\n</li>\n<li><strong>jul-to-slf4j-version.jar</strong><ul>\n<li>将Java Util Logging重定向到slf4j</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6851748-6c4d2a7f090aeafe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"桥接遗留api\"></p>\n<ul>\n<li><strong>桥接注意事项</strong></li>\n</ul>\n<blockquote>\n<p>在使用slf4j桥接时要注意避免形成死循环，在项目依赖的jar包中不要存在以下情况</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在</strong></li>\n</ul>\n</blockquote>\n<ul>\n<li>从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环</li>\n<li><strong>jul-to-slf4j.jar和slf4j-jdk14.jar同时存在</strong><ul>\n<li>从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环</li>\n</ul>\n</li>\n</ul>\n<p>##总结</p>\n<ul>\n<li><p>为了更好的了解Slf4j，你需要了解：</p>\n<ul>\n<li><strong>JVM类加载机制</strong></li>\n<li><strong>设计模式：门面模式、桥接模式</strong></li>\n</ul>\n</li>\n<li><p>简单总结Slf4j的原理：</p>\n<ul>\n<li>通过工厂类，提供一个的接口，用户可以通过这个门面，直接使用API实现日志的记录。</li>\n<li>而具体实现由Slf4j来寻找加载，寻找的过程，就是通过类加载加载<strong>org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class</strong>的文件，只要实现了这个文件的日志实现系统，都可以作为一种实现方式。</li>\n<li>如果找到很多种方式，那么就寻找一种默认的方式。</li>\n<li>这就是日志接口的工作方式，<strong>简单高效</strong>，关键是<strong>完全解耦</strong>，不需要日志实现部分提供任何的修改配置，只需要符合接口的标准就可以加载进来，<strong>有利于维护和各个类的日志处理方式统一</strong>。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分享了Java中if&#x2F;else复杂逻辑的处理</p>\n<p>本期我们将分享Java中日志的处理（上）</p>\n</blockquote>","more":"<blockquote>\n<p>想必大家都用过日志，虽然日志看起来可有可无，但是等到出问题的时候，日志就派上了大用场，所以说日志打得好不好，规范不规范，直接影响了解决生产环境故障的效率，日志打的不好，有可能影响环境的性能，也有可能影响排查问题的难易程度，有可能排查问题的时间比写代码的时间还有多。</p>\n<p>那么我们就来分析下阿里Java开发手册–日志规约第一条：<br>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger; </span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory; </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Abc.class);</span><br></pre></td></tr></table></figure>\n\n<p>##日志框架<br>Java中的日志框架分如下几种：</p>\n<ul>\n<li><p><code>Log4j</code> Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。</p>\n</li>\n<li><p><code>Log4j 2</code> Apache Log4j 2是apache开发的一款Log4j的升级产品。</p>\n</li>\n<li><p><code>Commons Logging</code> Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging。</p>\n</li>\n<li><p><code>Slf4j</code> 类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</p>\n</li>\n<li><p><code>Logback</code> 一套日志组件的实现(slf4j阵营)。</p>\n</li>\n<li><p><code>Jul</code> (Java Util Logging),自Java1.4以来的官方日志实现。</p>\n</li>\n</ul>\n<p>##使用示例</p>\n<ul>\n<li><strong>Jul</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> Logger.getLogger(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Log4j</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.log4j.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> Logger.getLogger(Abc.class.getNeme());</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Commons Logging</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Log</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LogFactory.getLogger(Abc.class);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;.....&quot;</span> + name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>Slf4j</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(Abc.class);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    logger.error(<span class=\"string\">&quot;.....error &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logger.debug(<span class=\"string\">&quot;.....&#123;&#125;&quot;</span>, name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>Jul</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Log4j</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Logback</strong><ul>\n<li>不支持占位符</li>\n<li>具体日志实现</li>\n</ul>\n</li>\n<li><strong>Commons Logging</strong><ul>\n<li>不支持占位符</li>\n<li>日志门面</li>\n</ul>\n</li>\n<li><strong>Slf4j</strong><ul>\n<li>支持占位符</li>\n<li>日志门面</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Slf4j中有一个很重要的特性：<code>占位符</code>，{}可以拼接任意<code>字符串</code>，相比如其他框架的优点即不需要用<code>+</code>来拼接字符串，也就不会创建新的字符串对象，所以像log4j中需要加<code>isDebugEnabled()</code>的判断就是这个道理，在slf4j中就不需要加判断。</p>\n</blockquote>\n<p>##门面模式<br>门面(Facade)模式，又称外观模式，对外隐藏了系统的复杂性，并向客户端提供了可以访问的接口，门面模式的好处是将客户端和子系统松耦合，方便子系统的扩展和维护。</p>\n<p>正是门面模式这样的特点，使用Slf4j门面，不管日志组件使用的是log4j还是logback等等，对于调用者而言并不关心使用的是什么日志组件，而且对于日志组件的更换或者升级，调用的地方也不要做任何修改。</p>\n<p>##源码分析</p>\n<p>此处应有代（zhang）码（sheng）：</p>\n<blockquote>\n<p>首先使用静态工厂来获取Logger对象，传入的class，最终会转化为name，每个类的日志处理可能不同，所以根据传入类的名字来判断类的实现方式</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getLogger</span><span class=\"params\">(Class clazz)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getLogger(clazz.getName());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Logger <span class=\"title function_\">getLogger</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ILoggerFactory</span> <span class=\"variable\">iLoggerFactory</span> <span class=\"operator\">=</span> getILoggerFactory();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> iLoggerFactory.getLogger(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>真正核心的在getILoggerFactory()中，首先判断初始化的状态<code>INITIALIZATION_STATE</code>，如果没有初始化<code>UNINITIALIZED</code>，那么会更改状态为正在初始化<code>ONGOING_INITIALIZATION</code>，并执行初始化<code>performInitialization()</code>，初始化完成之后，判断初始化的状态，如果初始化成功<code>SUCCESSFUL_INITIALIZATION</code>，那么会通过<code>StaticLoggerBinder</code>获取日志工厂<code>getLoggerFactory()</code>，这里又涉及到了<code>单例模式</code>。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ILoggerFactory <span class=\"title function_\">getILoggerFactory</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;</span><br><span class=\"line\">        INITIALIZATION_STATE = ONGOING_INITIALIZATION;</span><br><span class=\"line\">        performInitialization();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (INITIALIZATION_STATE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SUCCESSFUL_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();</span><br><span class=\"line\">        <span class=\"keyword\">case</span> NOP_FALLBACK_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> NOP_FALLBACK_FACTORY;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FAILED_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;org.slf4j.LoggerFactory could not be successfully initialized. See also http://www.slf4j.org/codes.html#unsuccessfulInit&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ONGOING_INITIALIZATION:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> TEMP_FACTORY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unreachable code&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接着我们分析<code>performInitialization</code>是如何初始化的，首先是执行<code>bind()</code>方法，然后判断如果状态为初始化成功<code>SUCCESSFUL_INITIALIZATION</code>，执行版本检查，主要是检查jdk版本与slf4j的版本，看是否匹配。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">performInitialization</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    bind();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INITIALIZATION_STATE == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        versionSanityCheck();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bind()方法，首先获取实现日志的加载路径，检查路径是否合法，然后初始化StaticLoggerBinder的对象，寻找合适的实现方式使用。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">staticLoggerBinderPathSet</span> <span class=\"operator\">=</span> findPossibleStaticLoggerBinderPathSet();</span><br><span class=\"line\">        reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);</span><br><span class=\"line\"></span><br><span class=\"line\">        StaticLoggerBinder.getSingleton();</span><br><span class=\"line\">        INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;</span><br><span class=\"line\">        reportActualBinding(staticLoggerBinderPathSet);</span><br><span class=\"line\">        emitSubstituteLoggerWarning();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoClassDefFoundError ncde) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> ncde.getMessage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;</span><br><span class=\"line\">            INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Failed to load class \\&quot;org.slf4j.impl.StaticLoggerBinder\\&quot;.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Defaulting to no-operation (NOP) logger implementation&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            failedBinding(ncde);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ncde;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodError nsme) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> nsme.getMessage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((msg != <span class=\"literal\">null</span>) &amp;&amp; (msg.indexOf(<span class=\"string\">&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;</span>) != -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            INITIALIZATION_STATE = FAILED_INITIALIZATION;</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Your binding is version 1.5.5 or earlier.&quot;</span>);</span><br><span class=\"line\">            Util.report(<span class=\"string\">&quot;Upgrade your binding to version 1.6.x.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> nsme;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        failedBinding(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Unexpected initialization failure&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以看出，bind()方法中最重要的方法就是寻找实现方式<code>findPossibleStaticLoggerBinderPathSet</code>，具体方法实现如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Set <span class=\"title function_\">findPossibleStaticLoggerBinderPathSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Set</span> <span class=\"variable\">staticLoggerBinderPathSet</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashSet</span>();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loggerFactoryClassLoader</span> <span class=\"operator\">=</span> LoggerFactory.class.getClassLoader();</span><br><span class=\"line\">        Enumeration paths;</span><br><span class=\"line\">        Enumeration paths;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (loggerFactoryClassLoader == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (paths.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"type\">URL</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> (URL)paths.nextElement();</span><br><span class=\"line\">            staticLoggerBinderPathSet.add(path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        Util.report(<span class=\"string\">&quot;Error getting resources from path&quot;</span>, ioe);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> staticLoggerBinderPathSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意！！前方高能！！</strong></p>\n</blockquote>\n<blockquote>\n<p>Slf4j的绝妙之处就在于此，类加载器加载类，也就是说寻找StaticLoggerBinder.class文件，然后只要实现了这个类的日志组件，都可以作为一种实现，如果有多个实现，那么谁先加载就使用谁，这个地方涉及<code>JVM的类加载机制</code></p>\n</blockquote>\n<p>##桥接</p>\n<ul>\n<li><strong>Slf4j与其他日志组件的桥接（Bridge）</strong></li>\n</ul>\n<ul>\n<li><strong>slf4j-log4j12-1.7.13.jar</strong><ul>\n<li>log4j1.2版本的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-jdk14-1.7.13.jar</strong><ul>\n<li>java.util.logging的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-nop-1.7.13.jar</strong><ul>\n<li>NOP桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-simple-1.7.13.jar</strong><ul>\n<li>一个简单实现的桥接器</li>\n</ul>\n</li>\n<li><strong>slf4j-jcl-1.7.13.jar</strong><ul>\n<li>Jakarta Commons Logging 的桥接器. 这个桥接器将SLF4j所有日志委派给JCL</li>\n</ul>\n</li>\n<li><strong>logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)</strong><ul>\n<li>slf4j的原生实现，logback直接实现了slf4j的接口，因此使用slf4j与logback的结合使用也意味更小的内存与计算开销</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://www.slf4j.org/manual.html\">Slf4j Manual</a>中有一张图清晰的展示了接入方式，如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6851748-1f6febd8ef94bc0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"桥接\"></p>\n<ul>\n<li><strong>Bridging legacy APIs（桥接遗留的api）</strong></li>\n</ul>\n<blockquote>\n<ul>\n<li><strong>log4j-over-slf4j-version.jar</strong><ul>\n<li>将log4j重定向到slf4j</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><strong>jcl-over-slf4j-version.jar</strong><ul>\n<li>将commos logging里的Simple Logger重定向到slf4j</li>\n</ul>\n</li>\n<li><strong>jul-to-slf4j-version.jar</strong><ul>\n<li>将Java Util Logging重定向到slf4j</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6851748-6c4d2a7f090aeafe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"桥接遗留api\"></p>\n<ul>\n<li><strong>桥接注意事项</strong></li>\n</ul>\n<blockquote>\n<p>在使用slf4j桥接时要注意避免形成死循环，在项目依赖的jar包中不要存在以下情况</p>\n</blockquote>\n<blockquote>\n<ul>\n<li><strong>log4j-over-slf4j.jar和slf4j-log4j12.jar同时存在</strong></li>\n</ul>\n</blockquote>\n<ul>\n<li>从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环</li>\n<li><strong>jul-to-slf4j.jar和slf4j-jdk14.jar同时存在</strong><ul>\n<li>从名字上就能看出，前者重定向给后者，后者又委派给前者，会形成死循环</li>\n</ul>\n</li>\n</ul>\n<p>##总结</p>\n<ul>\n<li><p>为了更好的了解Slf4j，你需要了解：</p>\n<ul>\n<li><strong>JVM类加载机制</strong></li>\n<li><strong>设计模式：门面模式、桥接模式</strong></li>\n</ul>\n</li>\n<li><p>简单总结Slf4j的原理：</p>\n<ul>\n<li>通过工厂类，提供一个的接口，用户可以通过这个门面，直接使用API实现日志的记录。</li>\n<li>而具体实现由Slf4j来寻找加载，寻找的过程，就是通过类加载加载<strong>org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class</strong>的文件，只要实现了这个文件的日志实现系统，都可以作为一种实现方式。</li>\n<li>如果找到很多种方式，那么就寻找一种默认的方式。</li>\n<li>这就是日志接口的工作方式，<strong>简单高效</strong>，关键是<strong>完全解耦</strong>，不需要日志实现部分提供任何的修改配置，只需要符合接口的标准就可以加载进来，<strong>有利于维护和各个类的日志处理方式统一</strong>。</li>\n</ul>\n</li>\n</ul>"},{"title":"阿里Java开发手册思考（二）","date":"2017-12-05T23:57:56.000Z","_content":">上期我们分享了关于Java中equals与hashCode的理解\n>\n>本期我们将分享Java中if/else复杂逻辑的处理\n\n<!--more-->\n>在github上曾看到一些issue，国外的程序员比较忌讳写else，看到了很多这样的评论`else is horrible`，那么对于逻辑很复杂的代码段，如果用太多的if/else的话，那么会导致代码的阅读难度变大，同时会增加代码的`圈复杂度`，理论上，如果一个函数的圈复杂度超过8，那么这个函数就还有可优化的地方，那么如何优化这种多分支的复杂逻辑的函数呢？手册中给出了三种方法：`卫语句`、`策略模式`、`状态模式`，通过阅读`《重构：改善既有代码的设计》`发现，解决这个问题其实有很多种，下面我们就一一道来。\n\n\n##第一大类：重新组织函数\n\n###1、Extract Method（提炼函数）\n>这种方法应该是最常用的方法之一，当函数过长或者分支太多的话，就可以考虑将其中的一段代码提炼成一个独立的函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tchangeTime();\n\t} else if (isFree()) {\n\t\tgoToTravel();\n\t} else {\n\t\tstayAtHomeToLearn();\n\t}\n}\n\nprivate void changeTime() {\n\t\tSystem.out.println(\"change time.\");\n}\n\nprivate void goToTravel() {\n\tSystem.out.println(\"go to travel.\");\n}\n\nprivate void stayAtHomeToLearn() {\n\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n}\n```\n用法：\n\n+ 提炼新函数，根据这个函数的意图来命名，以它做什么来命名，而不是以他怎么做来命名\n+ 仔细检查提炼出的代码是否引用了作用域限于源函数的变量，包括局部变量和源函数参数\n+ 适用场景：函数过长或者需要注释才能让人理解用途的代码\n\n###2、Substitute Algorithm（替换算法）\n>把某个算法替换成另一个更清晰的算法，或将函数本体替换为另一个算法。\n\n+ 原始代码：\n\n```java\npublic String foundPerson(String[] people) {\n\tfor (int i = 0; i < people.length; i++) {\n\t\tif (people[i].equals(\"Don\")) {\n\t\t\treturn \"Don\";\n\t\t}\n\t\tif (people[i].equals(\"John\")) {\n\t\t\treturn \"John\";\n\t\t}\n\t\tif (people[i].equals(\"Kent\")) {\n\t\t\treturn \"Kent\";\n\t\t}\n\t}\n\treturn \"\";\n}\n```\n\n+ 改后代码：\n\n```java\npublic String foundPerson(String[] people) {\n\tList<String> candidates = Arrays.asList(new String[] { \"Don\", \"John\", \"Kent\" });\n\tfor (int i = 0; i < people.length; i++) {\n\t\tif (candidates.contains(people[i])) {\n\t\t\treturn people[i];\n\t\t}\n\t}\n\treturn \"\";\n}\n```\n用法：\n\n+ 准备好另一个替换用的算法\n+ 新算法，要与原本的算法结果相同\n+ 适用场景：把某个算法替换为更清晰的算法，或者把函数替换为一个算法\n\n##第二大类：简化条件表达式\n\n###1、Eecompose Conditional（分解条件表达式）\n>如果有复杂的条件（if-then-else）语句，从if、then、else三个段落中分别提炼出独立函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy() || isNotWeekend()) {\n\t   System.out.println(\"change time.\");\n\treturn;\n\t} else {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (notFree()) {\n\t\tchangeTime();\n\t} else {\n\t\tgoToTravel();\n\t}\n}\n\nprivate boolean notFree() {\n\treturn isBusy() || isNotWeekend();\n}\n\nprivate void changeTime() {\n\tSystem.out.println(\"change time.\");\n}\n\nprivate void goToTravel() {\n\tSystem.out.println(\"go to travel.\");\n}\n```\n用法：\n\n+ 将if段落提炼出来，构成一个独立函数\n+ 将then段落和else段落都提炼出来，各自构成一个独立函数\n+ 适用场景：复杂的条件语句。如果发现嵌套的条件逻辑，先观察是否可以使用卫语句，如果不行，再开始分解其中的每个条件\n\n###2、Consolidate Conditioinal Expression（合并条件表达式）\n>如果有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isWeekend()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n\tif (isHoliday()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n\tif (noWork()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n\nprivate boolean isFree() {\n\treturn isWeekend() || isHoliday() || noWork();\n}\n```\n用法：\n\n+ 确定这些条件语句都没有副作用\n+ 使用适当的逻辑操作符，将一系列相关条件表达式合并为一个，并对合并后的表达式提炼函数\n+ 适用场景：一系列条件测试，都得到相同的结果\n\n###3、Consolidate Duplicate Conditional Clauses（合并重复的条件判断）\n>在条件表达式的每个分支上有相同的一段代码，将这段代码搬移到条件表达式之外。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t\tsleep();\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t\tsleep();\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t\tsleep();\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n\tsleep();\n}\n```\n用法：\n\n+ 鉴别出执行方式不随条件变化而变化的的代码\n+ 如果这些共同代码位于条件表达式起始处，就将它移到条件表达式之前，如果在尾端，移到条件表达式之后\n+ 适用场景：在条件表达式的每个分支上有相同的一段代码\n\n###4、Remove Control Flag（移除控制标记）\n在一系列布尔表达式中，某个变量带有“控制标记（Flag）”的作用，以break语句或者return语句取代控制标记。\n\n###5、Replace Nested Confitional with Guard Clauses（以卫语句取代嵌套条件表达式）\n>如果多个分支都属于正常行为，就应该使用if...else...的条件表达式，如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为卫语句。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t\treturn;\n\t}\n\tif (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t\treturn;\n\t}\n\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\treturn;\n}\n```\n用法：\n\n+ 对于每个检查，放进一个卫语句，卫语句要么就从函数中返回，要么就抛出一个异常\n+ 每次将条件检查替换成卫语句后，编译并测试：如果所有的卫语句都导致同样的结果，请使用`合并条件表达式`\n+ 适用场景：使用卫语句返回所有特殊情况\n\n###6、Replace Conditional with Polymorphism（以多态取代条件表达式）\n>条件表达式，根据对象的类型选择不同的行为，将这个条件表达式的每个分支放进一个子内的覆写函数中，然后将原始函数声明为抽象函数，这一项就是手册中说的策略模式以及状态模式。\n正因为有了多态，所以“类型码的switch语句”以及“基于类型名称的if-then-else”语句在面向对象程序中很少出现。\n\n##第三大类：简化函数调用\n\n###1、Separate Query from Modifier（将查询函数和修改函数分离）\n>某个函数既返回对象状态值，又修改了状态，建立两个不同的函数，其中一个负责查询，另一个负责修改。\n\n+ 并发的情况：需要保留第三个函数来同时做这两件事\n\n###2、Parameterize Method（令函数携带参数）\n>若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立单一函数，以参数表达那些不同的值。\n\n+ 原始代码：\n\n```java\npublic void tenPercentRaise() {\n\tsalary *= 1.1;\n}\n\npublic void fivePercentRaise() {\n\tsalary *= 1.05;\n}\n```\n\n+ 改后代码：\n\n```java\npublic void raise(double factor) {\n\tsalary *= (1 + factor);\n}\n```\n\n+ 要点在于：以可将少量数值视为参数为依据，找出带有重复性的代码\n\n###3、Replace Parameter with Explicit Methods（以明确函数取代参数）\n>有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立的函数。\n\n+ 原始代码：\n\n```java\npublic void setValue(String name, int value) {\n\tif (name.equals(\"height\")) {\n\t\theight = value;\n\t}\n\n\tif (name.equals(\"width\")) {\n\t\twidth = value;\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void setHeight(int arg) {\n\theight = arg;\n}\n\npublic void setWidth(int arg) {\n\twidth = arg;\n}\n```\n\n用法：\n\n+ 针对参数的每一种可能值，新建一个明确的函数\n+ 修改条件表达式的每个分支，使其调用合适的新函数\n+ 适用场景：函数完全取决于参数值而采取不同行为","source":"_posts/阿里Java开发手册思考（二）.md","raw":"title: 阿里Java开发手册思考（二）\ndate: 2017-12-06 07:57:56\ncategories: Java\ntags: [Java,阿里Java开发手册]\n---\n>上期我们分享了关于Java中equals与hashCode的理解\n>\n>本期我们将分享Java中if/else复杂逻辑的处理\n\n<!--more-->\n>在github上曾看到一些issue，国外的程序员比较忌讳写else，看到了很多这样的评论`else is horrible`，那么对于逻辑很复杂的代码段，如果用太多的if/else的话，那么会导致代码的阅读难度变大，同时会增加代码的`圈复杂度`，理论上，如果一个函数的圈复杂度超过8，那么这个函数就还有可优化的地方，那么如何优化这种多分支的复杂逻辑的函数呢？手册中给出了三种方法：`卫语句`、`策略模式`、`状态模式`，通过阅读`《重构：改善既有代码的设计》`发现，解决这个问题其实有很多种，下面我们就一一道来。\n\n\n##第一大类：重新组织函数\n\n###1、Extract Method（提炼函数）\n>这种方法应该是最常用的方法之一，当函数过长或者分支太多的话，就可以考虑将其中的一段代码提炼成一个独立的函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tchangeTime();\n\t} else if (isFree()) {\n\t\tgoToTravel();\n\t} else {\n\t\tstayAtHomeToLearn();\n\t}\n}\n\nprivate void changeTime() {\n\t\tSystem.out.println(\"change time.\");\n}\n\nprivate void goToTravel() {\n\tSystem.out.println(\"go to travel.\");\n}\n\nprivate void stayAtHomeToLearn() {\n\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n}\n```\n用法：\n\n+ 提炼新函数，根据这个函数的意图来命名，以它做什么来命名，而不是以他怎么做来命名\n+ 仔细检查提炼出的代码是否引用了作用域限于源函数的变量，包括局部变量和源函数参数\n+ 适用场景：函数过长或者需要注释才能让人理解用途的代码\n\n###2、Substitute Algorithm（替换算法）\n>把某个算法替换成另一个更清晰的算法，或将函数本体替换为另一个算法。\n\n+ 原始代码：\n\n```java\npublic String foundPerson(String[] people) {\n\tfor (int i = 0; i < people.length; i++) {\n\t\tif (people[i].equals(\"Don\")) {\n\t\t\treturn \"Don\";\n\t\t}\n\t\tif (people[i].equals(\"John\")) {\n\t\t\treturn \"John\";\n\t\t}\n\t\tif (people[i].equals(\"Kent\")) {\n\t\t\treturn \"Kent\";\n\t\t}\n\t}\n\treturn \"\";\n}\n```\n\n+ 改后代码：\n\n```java\npublic String foundPerson(String[] people) {\n\tList<String> candidates = Arrays.asList(new String[] { \"Don\", \"John\", \"Kent\" });\n\tfor (int i = 0; i < people.length; i++) {\n\t\tif (candidates.contains(people[i])) {\n\t\t\treturn people[i];\n\t\t}\n\t}\n\treturn \"\";\n}\n```\n用法：\n\n+ 准备好另一个替换用的算法\n+ 新算法，要与原本的算法结果相同\n+ 适用场景：把某个算法替换为更清晰的算法，或者把函数替换为一个算法\n\n##第二大类：简化条件表达式\n\n###1、Eecompose Conditional（分解条件表达式）\n>如果有复杂的条件（if-then-else）语句，从if、then、else三个段落中分别提炼出独立函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy() || isNotWeekend()) {\n\t   System.out.println(\"change time.\");\n\treturn;\n\t} else {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (notFree()) {\n\t\tchangeTime();\n\t} else {\n\t\tgoToTravel();\n\t}\n}\n\nprivate boolean notFree() {\n\treturn isBusy() || isNotWeekend();\n}\n\nprivate void changeTime() {\n\tSystem.out.println(\"change time.\");\n}\n\nprivate void goToTravel() {\n\tSystem.out.println(\"go to travel.\");\n}\n```\n用法：\n\n+ 将if段落提炼出来，构成一个独立函数\n+ 将then段落和else段落都提炼出来，各自构成一个独立函数\n+ 适用场景：复杂的条件语句。如果发现嵌套的条件逻辑，先观察是否可以使用卫语句，如果不行，再开始分解其中的每个条件\n\n###2、Consolidate Conditioinal Expression（合并条件表达式）\n>如果有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isWeekend()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n\tif (isHoliday()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n\tif (noWork()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t}\n}\n\nprivate boolean isFree() {\n\treturn isWeekend() || isHoliday() || noWork();\n}\n```\n用法：\n\n+ 确定这些条件语句都没有副作用\n+ 使用适当的逻辑操作符，将一系列相关条件表达式合并为一个，并对合并后的表达式提炼函数\n+ 适用场景：一系列条件测试，都得到相同的结果\n\n###3、Consolidate Duplicate Conditional Clauses（合并重复的条件判断）\n>在条件表达式的每个分支上有相同的一段代码，将这段代码搬移到条件表达式之外。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t\tsleep();\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t\tsleep();\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t\tsleep();\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n\tsleep();\n}\n```\n用法：\n\n+ 鉴别出执行方式不随条件变化而变化的的代码\n+ 如果这些共同代码位于条件表达式起始处，就将它移到条件表达式之前，如果在尾端，移到条件表达式之后\n+ 适用场景：在条件表达式的每个分支上有相同的一段代码\n\n###4、Remove Control Flag（移除控制标记）\n在一系列布尔表达式中，某个变量带有“控制标记（Flag）”的作用，以break语句或者return语句取代控制标记。\n\n###5、Replace Nested Confitional with Guard Clauses（以卫语句取代嵌套条件表达式）\n>如果多个分支都属于正常行为，就应该使用if...else...的条件表达式，如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为卫语句。\n\n+ 原始代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t} else if (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t} else {\n\t\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void today() {\n\tif (isBusy()) {\n\t\tSystem.out.println(\"change time.\");\n\t\treturn;\n\t}\n\tif (isFree()) {\n\t\tSystem.out.println(\"go to travel.\");\n\t\treturn;\n\t}\n\tSystem.out.println(\"stay at home to learn Alibaba Java Coding Guidelines.\");\n\treturn;\n}\n```\n用法：\n\n+ 对于每个检查，放进一个卫语句，卫语句要么就从函数中返回，要么就抛出一个异常\n+ 每次将条件检查替换成卫语句后，编译并测试：如果所有的卫语句都导致同样的结果，请使用`合并条件表达式`\n+ 适用场景：使用卫语句返回所有特殊情况\n\n###6、Replace Conditional with Polymorphism（以多态取代条件表达式）\n>条件表达式，根据对象的类型选择不同的行为，将这个条件表达式的每个分支放进一个子内的覆写函数中，然后将原始函数声明为抽象函数，这一项就是手册中说的策略模式以及状态模式。\n正因为有了多态，所以“类型码的switch语句”以及“基于类型名称的if-then-else”语句在面向对象程序中很少出现。\n\n##第三大类：简化函数调用\n\n###1、Separate Query from Modifier（将查询函数和修改函数分离）\n>某个函数既返回对象状态值，又修改了状态，建立两个不同的函数，其中一个负责查询，另一个负责修改。\n\n+ 并发的情况：需要保留第三个函数来同时做这两件事\n\n###2、Parameterize Method（令函数携带参数）\n>若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立单一函数，以参数表达那些不同的值。\n\n+ 原始代码：\n\n```java\npublic void tenPercentRaise() {\n\tsalary *= 1.1;\n}\n\npublic void fivePercentRaise() {\n\tsalary *= 1.05;\n}\n```\n\n+ 改后代码：\n\n```java\npublic void raise(double factor) {\n\tsalary *= (1 + factor);\n}\n```\n\n+ 要点在于：以可将少量数值视为参数为依据，找出带有重复性的代码\n\n###3、Replace Parameter with Explicit Methods（以明确函数取代参数）\n>有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立的函数。\n\n+ 原始代码：\n\n```java\npublic void setValue(String name, int value) {\n\tif (name.equals(\"height\")) {\n\t\theight = value;\n\t}\n\n\tif (name.equals(\"width\")) {\n\t\twidth = value;\n\t}\n}\n```\n\n+ 改后代码：\n\n```java\npublic void setHeight(int arg) {\n\theight = arg;\n}\n\npublic void setWidth(int arg) {\n\twidth = arg;\n}\n```\n\n用法：\n\n+ 针对参数的每一种可能值，新建一个明确的函数\n+ 修改条件表达式的每个分支，使其调用合适的新函数\n+ 适用场景：函数完全取决于参数值而采取不同行为","slug":"阿里Java开发手册思考（二）","published":1,"updated":"2025-03-07T13:26:47.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz3o006irz5m13up7r78","content":"<blockquote>\n<p>上期我们分享了关于Java中equals与hashCode的理解</p>\n<p>本期我们将分享Java中if&#x2F;else复杂逻辑的处理</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>在github上曾看到一些issue，国外的程序员比较忌讳写else，看到了很多这样的评论<code>else is horrible</code>，那么对于逻辑很复杂的代码段，如果用太多的if&#x2F;else的话，那么会导致代码的阅读难度变大，同时会增加代码的<code>圈复杂度</code>，理论上，如果一个函数的圈复杂度超过8，那么这个函数就还有可优化的地方，那么如何优化这种多分支的复杂逻辑的函数呢？手册中给出了三种方法：<code>卫语句</code>、<code>策略模式</code>、<code>状态模式</code>，通过阅读<code>《重构：改善既有代码的设计》</code>发现，解决这个问题其实有很多种，下面我们就一一道来。</p>\n</blockquote>\n<p>##第一大类：重新组织函数</p>\n<p>###1、Extract Method（提炼函数）</p>\n<blockquote>\n<p>这种方法应该是最常用的方法之一，当函数过长或者分支太多的话，就可以考虑将其中的一段代码提炼成一个独立的函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tchangeTime();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tgoToTravel();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstayAtHomeToLearn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">changeTime</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">goToTravel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stayAtHomeToLearn</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>提炼新函数，根据这个函数的意图来命名，以它做什么来命名，而不是以他怎么做来命名</li>\n<li>仔细检查提炼出的代码是否引用了作用域限于源函数的变量，包括局部变量和源函数参数</li>\n<li>适用场景：函数过长或者需要注释才能让人理解用途的代码</li>\n</ul>\n<p>###2、Substitute Algorithm（替换算法）</p>\n<blockquote>\n<p>把某个算法替换成另一个更清晰的算法，或将函数本体替换为另一个算法。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">foundPerson</span><span class=\"params\">(String[] people)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;Don&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Don&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;John&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;John&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;Kent&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Kent&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">foundPerson</span><span class=\"params\">(String[] people)</span> &#123;</span><br><span class=\"line\">\tList&lt;String&gt; candidates = Arrays.asList(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;Don&quot;</span>, <span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Kent&quot;</span> &#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (candidates.contains(people[i])) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> people[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>准备好另一个替换用的算法</li>\n<li>新算法，要与原本的算法结果相同</li>\n<li>适用场景：把某个算法替换为更清晰的算法，或者把函数替换为一个算法</li>\n</ul>\n<p>##第二大类：简化条件表达式</p>\n<p>###1、Eecompose Conditional（分解条件表达式）</p>\n<blockquote>\n<p>如果有复杂的条件（if-then-else）语句，从if、then、else三个段落中分别提炼出独立函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy() || isNotWeekend()) &#123;</span><br><span class=\"line\">\t   System.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (notFree()) &#123;</span><br><span class=\"line\">\t\tchangeTime();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tgoToTravel();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">notFree</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> isBusy() || isNotWeekend();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">changeTime</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">goToTravel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>将if段落提炼出来，构成一个独立函数</li>\n<li>将then段落和else段落都提炼出来，各自构成一个独立函数</li>\n<li>适用场景：复杂的条件语句。如果发现嵌套的条件逻辑，先观察是否可以使用卫语句，如果不行，再开始分解其中的每个条件</li>\n</ul>\n<p>###2、Consolidate Conditioinal Expression（合并条件表达式）</p>\n<blockquote>\n<p>如果有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isWeekend()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isHoliday()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (noWork()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isFree</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> isWeekend() || isHoliday() || noWork();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>确定这些条件语句都没有副作用</li>\n<li>使用适当的逻辑操作符，将一系列相关条件表达式合并为一个，并对合并后的表达式提炼函数</li>\n<li>适用场景：一系列条件测试，都得到相同的结果</li>\n</ul>\n<p>###3、Consolidate Duplicate Conditional Clauses（合并重复的条件判断）</p>\n<blockquote>\n<p>在条件表达式的每个分支上有相同的一段代码，将这段代码搬移到条件表达式之外。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsleep();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>鉴别出执行方式不随条件变化而变化的的代码</li>\n<li>如果这些共同代码位于条件表达式起始处，就将它移到条件表达式之前，如果在尾端，移到条件表达式之后</li>\n<li>适用场景：在条件表达式的每个分支上有相同的一段代码</li>\n</ul>\n<p>###4、Remove Control Flag（移除控制标记）<br>在一系列布尔表达式中，某个变量带有“控制标记（Flag）”的作用，以break语句或者return语句取代控制标记。</p>\n<p>###5、Replace Nested Confitional with Guard Clauses（以卫语句取代嵌套条件表达式）</p>\n<blockquote>\n<p>如果多个分支都属于正常行为，就应该使用if…else…的条件表达式，如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为卫语句。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>对于每个检查，放进一个卫语句，卫语句要么就从函数中返回，要么就抛出一个异常</li>\n<li>每次将条件检查替换成卫语句后，编译并测试：如果所有的卫语句都导致同样的结果，请使用<code>合并条件表达式</code></li>\n<li>适用场景：使用卫语句返回所有特殊情况</li>\n</ul>\n<p>###6、Replace Conditional with Polymorphism（以多态取代条件表达式）</p>\n<blockquote>\n<p>条件表达式，根据对象的类型选择不同的行为，将这个条件表达式的每个分支放进一个子内的覆写函数中，然后将原始函数声明为抽象函数，这一项就是手册中说的策略模式以及状态模式。<br>正因为有了多态，所以“类型码的switch语句”以及“基于类型名称的if-then-else”语句在面向对象程序中很少出现。</p>\n</blockquote>\n<p>##第三大类：简化函数调用</p>\n<p>###1、Separate Query from Modifier（将查询函数和修改函数分离）</p>\n<blockquote>\n<p>某个函数既返回对象状态值，又修改了状态，建立两个不同的函数，其中一个负责查询，另一个负责修改。</p>\n</blockquote>\n<ul>\n<li>并发的情况：需要保留第三个函数来同时做这两件事</li>\n</ul>\n<p>###2、Parameterize Method（令函数携带参数）</p>\n<blockquote>\n<p>若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立单一函数，以参数表达那些不同的值。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tenPercentRaise</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tsalary *= <span class=\"number\">1.1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fivePercentRaise</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tsalary *= <span class=\"number\">1.05</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">raise</span><span class=\"params\">(<span class=\"type\">double</span> factor)</span> &#123;</span><br><span class=\"line\">\tsalary *= (<span class=\"number\">1</span> + factor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>要点在于：以可将少量数值视为参数为依据，找出带有重复性的代码</li>\n</ul>\n<p>###3、Replace Parameter with Explicit Methods（以明确函数取代参数）</p>\n<blockquote>\n<p>有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立的函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(String name, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;height&quot;</span>)) &#123;</span><br><span class=\"line\">\t\theight = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;width&quot;</span>)) &#123;</span><br><span class=\"line\">\t\twidth = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">\theight = arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">\twidth = arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<ul>\n<li>针对参数的每一种可能值，新建一个明确的函数</li>\n<li>修改条件表达式的每个分支，使其调用合适的新函数</li>\n<li>适用场景：函数完全取决于参数值而采取不同行为</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分享了关于Java中equals与hashCode的理解</p>\n<p>本期我们将分享Java中if&#x2F;else复杂逻辑的处理</p>\n</blockquote>","more":"<blockquote>\n<p>在github上曾看到一些issue，国外的程序员比较忌讳写else，看到了很多这样的评论<code>else is horrible</code>，那么对于逻辑很复杂的代码段，如果用太多的if&#x2F;else的话，那么会导致代码的阅读难度变大，同时会增加代码的<code>圈复杂度</code>，理论上，如果一个函数的圈复杂度超过8，那么这个函数就还有可优化的地方，那么如何优化这种多分支的复杂逻辑的函数呢？手册中给出了三种方法：<code>卫语句</code>、<code>策略模式</code>、<code>状态模式</code>，通过阅读<code>《重构：改善既有代码的设计》</code>发现，解决这个问题其实有很多种，下面我们就一一道来。</p>\n</blockquote>\n<p>##第一大类：重新组织函数</p>\n<p>###1、Extract Method（提炼函数）</p>\n<blockquote>\n<p>这种方法应该是最常用的方法之一，当函数过长或者分支太多的话，就可以考虑将其中的一段代码提炼成一个独立的函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tchangeTime();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tgoToTravel();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tstayAtHomeToLearn();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">changeTime</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">goToTravel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stayAtHomeToLearn</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>提炼新函数，根据这个函数的意图来命名，以它做什么来命名，而不是以他怎么做来命名</li>\n<li>仔细检查提炼出的代码是否引用了作用域限于源函数的变量，包括局部变量和源函数参数</li>\n<li>适用场景：函数过长或者需要注释才能让人理解用途的代码</li>\n</ul>\n<p>###2、Substitute Algorithm（替换算法）</p>\n<blockquote>\n<p>把某个算法替换成另一个更清晰的算法，或将函数本体替换为另一个算法。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">foundPerson</span><span class=\"params\">(String[] people)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;Don&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Don&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;John&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;John&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (people[i].equals(<span class=\"string\">&quot;Kent&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;Kent&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">foundPerson</span><span class=\"params\">(String[] people)</span> &#123;</span><br><span class=\"line\">\tList&lt;String&gt; candidates = Arrays.asList(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;Don&quot;</span>, <span class=\"string\">&quot;John&quot;</span>, <span class=\"string\">&quot;Kent&quot;</span> &#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; people.length; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (candidates.contains(people[i])) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> people[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>准备好另一个替换用的算法</li>\n<li>新算法，要与原本的算法结果相同</li>\n<li>适用场景：把某个算法替换为更清晰的算法，或者把函数替换为一个算法</li>\n</ul>\n<p>##第二大类：简化条件表达式</p>\n<p>###1、Eecompose Conditional（分解条件表达式）</p>\n<blockquote>\n<p>如果有复杂的条件（if-then-else）语句，从if、then、else三个段落中分别提炼出独立函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy() || isNotWeekend()) &#123;</span><br><span class=\"line\">\t   System.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (notFree()) &#123;</span><br><span class=\"line\">\t\tchangeTime();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tgoToTravel();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">notFree</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> isBusy() || isNotWeekend();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">changeTime</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">goToTravel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>将if段落提炼出来，构成一个独立函数</li>\n<li>将then段落和else段落都提炼出来，各自构成一个独立函数</li>\n<li>适用场景：复杂的条件语句。如果发现嵌套的条件逻辑，先观察是否可以使用卫语句，如果不行，再开始分解其中的每个条件</li>\n</ul>\n<p>###2、Consolidate Conditioinal Expression（合并条件表达式）</p>\n<blockquote>\n<p>如果有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isWeekend()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isHoliday()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (noWork()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isFree</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> isWeekend() || isHoliday() || noWork();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>确定这些条件语句都没有副作用</li>\n<li>使用适当的逻辑操作符，将一系列相关条件表达式合并为一个，并对合并后的表达式提炼函数</li>\n<li>适用场景：一系列条件测试，都得到相同的结果</li>\n</ul>\n<p>###3、Consolidate Duplicate Conditional Clauses（合并重复的条件判断）</p>\n<blockquote>\n<p>在条件表达式的每个分支上有相同的一段代码，将这段代码搬移到条件表达式之外。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t\tsleep();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsleep();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>鉴别出执行方式不随条件变化而变化的的代码</li>\n<li>如果这些共同代码位于条件表达式起始处，就将它移到条件表达式之前，如果在尾端，移到条件表达式之后</li>\n<li>适用场景：在条件表达式的每个分支上有相同的一段代码</li>\n</ul>\n<p>###4、Remove Control Flag（移除控制标记）<br>在一系列布尔表达式中，某个变量带有“控制标记（Flag）”的作用，以break语句或者return语句取代控制标记。</p>\n<p>###5、Replace Nested Confitional with Guard Clauses（以卫语句取代嵌套条件表达式）</p>\n<blockquote>\n<p>如果多个分支都属于正常行为，就应该使用if…else…的条件表达式，如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回，这样的单独检查常常被称为卫语句。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">today</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isBusy()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;change time.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (isFree()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;go to travel.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;stay at home to learn Alibaba Java Coding Guidelines.&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ul>\n<li>对于每个检查，放进一个卫语句，卫语句要么就从函数中返回，要么就抛出一个异常</li>\n<li>每次将条件检查替换成卫语句后，编译并测试：如果所有的卫语句都导致同样的结果，请使用<code>合并条件表达式</code></li>\n<li>适用场景：使用卫语句返回所有特殊情况</li>\n</ul>\n<p>###6、Replace Conditional with Polymorphism（以多态取代条件表达式）</p>\n<blockquote>\n<p>条件表达式，根据对象的类型选择不同的行为，将这个条件表达式的每个分支放进一个子内的覆写函数中，然后将原始函数声明为抽象函数，这一项就是手册中说的策略模式以及状态模式。<br>正因为有了多态，所以“类型码的switch语句”以及“基于类型名称的if-then-else”语句在面向对象程序中很少出现。</p>\n</blockquote>\n<p>##第三大类：简化函数调用</p>\n<p>###1、Separate Query from Modifier（将查询函数和修改函数分离）</p>\n<blockquote>\n<p>某个函数既返回对象状态值，又修改了状态，建立两个不同的函数，其中一个负责查询，另一个负责修改。</p>\n</blockquote>\n<ul>\n<li>并发的情况：需要保留第三个函数来同时做这两件事</li>\n</ul>\n<p>###2、Parameterize Method（令函数携带参数）</p>\n<blockquote>\n<p>若干函数做了类似的工作，但在函数本体中却包含了不同的值，建立单一函数，以参数表达那些不同的值。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tenPercentRaise</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tsalary *= <span class=\"number\">1.1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">fivePercentRaise</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tsalary *= <span class=\"number\">1.05</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">raise</span><span class=\"params\">(<span class=\"type\">double</span> factor)</span> &#123;</span><br><span class=\"line\">\tsalary *= (<span class=\"number\">1</span> + factor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>要点在于：以可将少量数值视为参数为依据，找出带有重复性的代码</li>\n</ul>\n<p>###3、Replace Parameter with Explicit Methods（以明确函数取代参数）</p>\n<blockquote>\n<p>有一个函数，其中完全取决于参数值而采取不同行为，针对该参数的每一个可能值，建立一个独立的函数。</p>\n</blockquote>\n<ul>\n<li>原始代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(String name, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;height&quot;</span>)) &#123;</span><br><span class=\"line\">\t\theight = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (name.equals(<span class=\"string\">&quot;width&quot;</span>)) &#123;</span><br><span class=\"line\">\t\twidth = value;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改后代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHeight</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">\theight = arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setWidth</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">\twidth = arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法：</p>\n<ul>\n<li>针对参数的每一种可能值，新建一个明确的函数</li>\n<li>修改条件表达式的每个分支，使其调用合适的新函数</li>\n<li>适用场景：函数完全取决于参数值而采取不同行为</li>\n</ul>"},{"title":"阿里Java开发手册思考（五）","date":"2017-12-17T13:21:34.000Z","_content":">上期我们分享了Java中日志的处理（下）：Java中日志实际使用中的相关注意点\n>\n>本期我们将分享Java中异常的处理（上）\n\n<!--more-->\n##异常定义\n在《java编程思想》中这样定义异常：阻止当前方法或作用域继续执行的问题。\n##异常分类\n首先我们看下Java中异常的继承关系：\n\n可以看出，`Throwable`有两个子类：`Error`和`Exception`\n\n+ `Error`\n    + VirtualMachineError，典型的有`StackOverFlow`和`OutOfMemory`\n    + AWTError\n+ `Exception`\n    + IOException\n    + ...\n    + RuntimeException\n\nException分为CheckedException和UncheckedException，那么CheckedException和UncheckedException区别是什么呢？\n\n+ `UncheckedException`：派生于Error或者RuntimeException的异常\n+ `CheckedException`：所有其他的异常\n\n##异常处理机制\n异常处理机制分为：抛出异常和捕捉异常\n\n抛出异常：方法上使用`throws`，方法内使用`throw`\n捕捉异常：使用`try-catch`或者`try-catch-finally`\n\n原则，正如手册上所说：\n\n+ 不要直接忽略异常\n+ 不要用try-catch包住太多语句\n+ 不要用异常处理来处理程序的正常控制流\n+ 不要随便将异常迎函数栈向上传递，能处理尽量处理\n\n何时向上传播？\n\n+ 当你认为本异常应该由上层处理时，才向上传播\n\n##注意点\n+ `finally`语句块一定会执行吗？\n\n>**不一定会**，以下两种情况finally语句块不会执行\n>1. 未执行到try语句块\n>2. try语句块中有System.exit(0);  \n\n+ `finally`语句块的执行顺序\n\n首先看没有控制语句的情况：\n\n```java\npublic static void main(String[] args) {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n```\n输出没有疑问：\ntry block\nfinally block\n\n>1、如果`try`中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句之前执行还是之后执行？\n\n```java\nprivate static String test1() {\n\tSystem.out.println(\"test1()\");\n\treturn \"return\";\n}\n\nprivate static String test() {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t\treturn test1();\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n输出：\ntry block\ntest1()\nfinally block\nreturn\n\n所以说，如果`try`中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句**之前**执行\n\n>2、如果`catch`语句中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句之前执行还是之后执行？\n\n```java\nprivate static String test1() {\n\tSystem.out.println(\"test1()\");\n\treturn \"return\";\n}\n\nprivate static String test() {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t\tSystem.out.println(1 / 0);\n\t\treturn test1();\n\t} catch (Exception e) {\n\t\tSystem.out.println(\"catch block\");\n\t\treturn test1();\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n\n输出：\ntry block\ncatch block\ntest1()\nfinally block\nreturn\n\n所以说，如果`catch`语句中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句**之前**执行\n\n+ `finally`里的变量\n\n```java\npublic static int test() {\n\tint i = 0;\n\ttry {\n\t\treturn i;\n\t} finally {\n\t\ti++;\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n\n输出：\n0\n\n咦？很奇怪，为什么是0，而不是1呢？\n\n通过反编译生成的class，我们就能知道原因了\n\n```java\nint i = 0;\ntry {\n\treturn i;\n} finally {\n\tint iTemp = i++;\n}\n```\n\n原来，i++后只是赋值给了一个新的`局部变量`，i本身并没有变，这一点和函数的形参一样，如果传的是`引用类型`的，那么值会变，如果传的不是引用类型，那么值是不会改变的，改变的也只是局部变量。\n\n##常见面试题\n+ 1、error和exception有什么区别？\n\n>error 表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。\nexception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题\n\n+ 2、运行时异常和一般异常有何不同\n\n>Java 提供了两类主要的异常：runtimeException 和 checkedException\n一般异常（checkedException）主要是指 IO 异常、SQL 异常等。对于这种异常，JVM 要求我们必须对其进行 cathc 处理，所以，面对这种异常，不管我们是否愿意，都是要 写一大堆的 catch 块去处理可能出现的异常。\n运行时异常（runtimeException）我们一般不处理，当出现这类异常的时候程序会由虚拟机接管。比如，我们从来没有去处理过 NullPointerException，而且这个异常还是最 常见的异常之一。\n出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有 catch 块进行处理，到了最上层，如果是多线程就有 Thread.run()抛出，如果不是多线程 那么就由 main.run() 抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。\n其实运行时异常的也是继承自 Exception，也可以用 catch 块对其处理，只是我们一般不处理罢了，也就是说，如果不对运行时异常进行 catch 处理，那么结果不是线程退出就是 主程序终止。\n如果不想终止，那么我们就必须捕获所有可能出现的运行时异常。如果程序中出现了异常数据，但是它不影响下面的程序执行，那么我们就该在catch块里面将异常数据舍弃， 然后记录日志。如果，它影响到了下面的程序运行，那么还是程序退出比较好些。\n\n+ 3、Java 中异常处理机制的原理\n\n>Jav a通过面向对象的方式对异常进行处理，Java 把异常按照不同的类型进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它都是 Throwable 或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java 的异常处理是通过5个 关键词来实现的：try、catch、throw、throws、finally。\ntry：用来指定一块预防所有异常的程序\ncatch：紧跟在try后面，用来捕获异常\nthrow：用来明确的抛出一个异常\nthrows：用来标明一个成员函数可能抛出的各种异常\nfinally：确保一段代码无论发生什么异常都会被执行的一段代码。\n\n+ 4、你平时在项目中是怎样对异常进行处理的。\n>1）尽量避免出现 runtimeException。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对 runtimeException也进行 try catch 处理。\n2）进行 try catch 处理的时候要在 catch 代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息。\n\n+ 5、final、finally、finalize的区别\n>（1）、final 用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承\n（2）、finally 是异常处理中的一个关键字，表示 finally{} 里面的代码一定要执行\n（3）、finalize 是 Object 类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。","source":"_posts/阿里Java开发手册思考（五）.md","raw":"title: 阿里Java开发手册思考（五）\ndate: 2017-12-17 21:21:34\ncategories: Java\ntags: [Java,阿里Java开发手册]\n---\n>上期我们分享了Java中日志的处理（下）：Java中日志实际使用中的相关注意点\n>\n>本期我们将分享Java中异常的处理（上）\n\n<!--more-->\n##异常定义\n在《java编程思想》中这样定义异常：阻止当前方法或作用域继续执行的问题。\n##异常分类\n首先我们看下Java中异常的继承关系：\n\n可以看出，`Throwable`有两个子类：`Error`和`Exception`\n\n+ `Error`\n    + VirtualMachineError，典型的有`StackOverFlow`和`OutOfMemory`\n    + AWTError\n+ `Exception`\n    + IOException\n    + ...\n    + RuntimeException\n\nException分为CheckedException和UncheckedException，那么CheckedException和UncheckedException区别是什么呢？\n\n+ `UncheckedException`：派生于Error或者RuntimeException的异常\n+ `CheckedException`：所有其他的异常\n\n##异常处理机制\n异常处理机制分为：抛出异常和捕捉异常\n\n抛出异常：方法上使用`throws`，方法内使用`throw`\n捕捉异常：使用`try-catch`或者`try-catch-finally`\n\n原则，正如手册上所说：\n\n+ 不要直接忽略异常\n+ 不要用try-catch包住太多语句\n+ 不要用异常处理来处理程序的正常控制流\n+ 不要随便将异常迎函数栈向上传递，能处理尽量处理\n\n何时向上传播？\n\n+ 当你认为本异常应该由上层处理时，才向上传播\n\n##注意点\n+ `finally`语句块一定会执行吗？\n\n>**不一定会**，以下两种情况finally语句块不会执行\n>1. 未执行到try语句块\n>2. try语句块中有System.exit(0);  \n\n+ `finally`语句块的执行顺序\n\n首先看没有控制语句的情况：\n\n```java\npublic static void main(String[] args) {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n```\n输出没有疑问：\ntry block\nfinally block\n\n>1、如果`try`中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句之前执行还是之后执行？\n\n```java\nprivate static String test1() {\n\tSystem.out.println(\"test1()\");\n\treturn \"return\";\n}\n\nprivate static String test() {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t\treturn test1();\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n输出：\ntry block\ntest1()\nfinally block\nreturn\n\n所以说，如果`try`中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句**之前**执行\n\n>2、如果`catch`语句中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句之前执行还是之后执行？\n\n```java\nprivate static String test1() {\n\tSystem.out.println(\"test1()\");\n\treturn \"return\";\n}\n\nprivate static String test() {\n\ttry {\n\t\tSystem.out.println(\"try block\");\n\t\tSystem.out.println(1 / 0);\n\t\treturn test1();\n\t} catch (Exception e) {\n\t\tSystem.out.println(\"catch block\");\n\t\treturn test1();\n\t} finally {\n\t\tSystem.out.println(\"finally block\");\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n\n输出：\ntry block\ncatch block\ntest1()\nfinally block\nreturn\n\n所以说，如果`catch`语句中有控制语句（`return`、`break`、`continue`），那`finally`语句块是在控制转义语句**之前**执行\n\n+ `finally`里的变量\n\n```java\npublic static int test() {\n\tint i = 0;\n\ttry {\n\t\treturn i;\n\t} finally {\n\t\ti++;\n\t}\n}\n\npublic static void main(String[] args) {\n\tSystem.out.println(test());\n}\n```\n\n输出：\n0\n\n咦？很奇怪，为什么是0，而不是1呢？\n\n通过反编译生成的class，我们就能知道原因了\n\n```java\nint i = 0;\ntry {\n\treturn i;\n} finally {\n\tint iTemp = i++;\n}\n```\n\n原来，i++后只是赋值给了一个新的`局部变量`，i本身并没有变，这一点和函数的形参一样，如果传的是`引用类型`的，那么值会变，如果传的不是引用类型，那么值是不会改变的，改变的也只是局部变量。\n\n##常见面试题\n+ 1、error和exception有什么区别？\n\n>error 表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。\nexception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题\n\n+ 2、运行时异常和一般异常有何不同\n\n>Java 提供了两类主要的异常：runtimeException 和 checkedException\n一般异常（checkedException）主要是指 IO 异常、SQL 异常等。对于这种异常，JVM 要求我们必须对其进行 cathc 处理，所以，面对这种异常，不管我们是否愿意，都是要 写一大堆的 catch 块去处理可能出现的异常。\n运行时异常（runtimeException）我们一般不处理，当出现这类异常的时候程序会由虚拟机接管。比如，我们从来没有去处理过 NullPointerException，而且这个异常还是最 常见的异常之一。\n出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有 catch 块进行处理，到了最上层，如果是多线程就有 Thread.run()抛出，如果不是多线程 那么就由 main.run() 抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。\n其实运行时异常的也是继承自 Exception，也可以用 catch 块对其处理，只是我们一般不处理罢了，也就是说，如果不对运行时异常进行 catch 处理，那么结果不是线程退出就是 主程序终止。\n如果不想终止，那么我们就必须捕获所有可能出现的运行时异常。如果程序中出现了异常数据，但是它不影响下面的程序执行，那么我们就该在catch块里面将异常数据舍弃， 然后记录日志。如果，它影响到了下面的程序运行，那么还是程序退出比较好些。\n\n+ 3、Java 中异常处理机制的原理\n\n>Jav a通过面向对象的方式对异常进行处理，Java 把异常按照不同的类型进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它都是 Throwable 或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java 的异常处理是通过5个 关键词来实现的：try、catch、throw、throws、finally。\ntry：用来指定一块预防所有异常的程序\ncatch：紧跟在try后面，用来捕获异常\nthrow：用来明确的抛出一个异常\nthrows：用来标明一个成员函数可能抛出的各种异常\nfinally：确保一段代码无论发生什么异常都会被执行的一段代码。\n\n+ 4、你平时在项目中是怎样对异常进行处理的。\n>1）尽量避免出现 runtimeException。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对 runtimeException也进行 try catch 处理。\n2）进行 try catch 处理的时候要在 catch 代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息。\n\n+ 5、final、finally、finalize的区别\n>（1）、final 用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承\n（2）、finally 是异常处理中的一个关键字，表示 finally{} 里面的代码一定要执行\n（3）、finalize 是 Object 类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。","slug":"阿里Java开发手册思考（五）","published":1,"updated":"2025-03-07T13:26:47.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz3r006jrz5mgepp3cfk","content":"<blockquote>\n<p>上期我们分享了Java中日志的处理（下）：Java中日志实际使用中的相关注意点</p>\n<p>本期我们将分享Java中异常的处理（上）</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##异常定义<br>在《java编程思想》中这样定义异常：阻止当前方法或作用域继续执行的问题。<br>##异常分类<br>首先我们看下Java中异常的继承关系：</p>\n<p>可以看出，<code>Throwable</code>有两个子类：<code>Error</code>和<code>Exception</code></p>\n<ul>\n<li><code>Error</code><ul>\n<li>VirtualMachineError，典型的有<code>StackOverFlow</code>和<code>OutOfMemory</code></li>\n<li>AWTError</li>\n</ul>\n</li>\n<li><code>Exception</code><ul>\n<li>IOException</li>\n<li>…</li>\n<li>RuntimeException</li>\n</ul>\n</li>\n</ul>\n<p>Exception分为CheckedException和UncheckedException，那么CheckedException和UncheckedException区别是什么呢？</p>\n<ul>\n<li><code>UncheckedException</code>：派生于Error或者RuntimeException的异常</li>\n<li><code>CheckedException</code>：所有其他的异常</li>\n</ul>\n<p>##异常处理机制<br>异常处理机制分为：抛出异常和捕捉异常</p>\n<p>抛出异常：方法上使用<code>throws</code>，方法内使用<code>throw</code><br>捕捉异常：使用<code>try-catch</code>或者<code>try-catch-finally</code></p>\n<p>原则，正如手册上所说：</p>\n<ul>\n<li>不要直接忽略异常</li>\n<li>不要用try-catch包住太多语句</li>\n<li>不要用异常处理来处理程序的正常控制流</li>\n<li>不要随便将异常迎函数栈向上传递，能处理尽量处理</li>\n</ul>\n<p>何时向上传播？</p>\n<ul>\n<li>当你认为本异常应该由上层处理时，才向上传播</li>\n</ul>\n<p>##注意点</p>\n<ul>\n<li><code>finally</code>语句块一定会执行吗？</li>\n</ul>\n<blockquote>\n<p><strong>不一定会</strong>，以下两种情况finally语句块不会执行</p>\n<ol>\n<li>未执行到try语句块</li>\n<li>try语句块中有System.exit(0);</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>finally</code>语句块的执行顺序</li>\n</ul>\n<p>首先看没有控制语句的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出没有疑问：<br>try block<br>finally block</p>\n<blockquote>\n<p>1、如果<code>try</code>中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句之前执行还是之后执行？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;test1()&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;return&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>try block<br>test1()<br>finally block<br>return</p>\n<p>所以说，如果<code>try</code>中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句<strong>之前</strong>执行</p>\n<blockquote>\n<p>2、如果<code>catch</code>语句中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句之前执行还是之后执行？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;test1()&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;return&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"number\">1</span> / <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;catch block&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>try block<br>catch block<br>test1()<br>finally block<br>return</p>\n<p>所以说，如果<code>catch</code>语句中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句<strong>之前</strong>执行</p>\n<ul>\n<li><code>finally</code>里的变量</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>0</p>\n<p>咦？很奇怪，为什么是0，而不是1呢？</p>\n<p>通过反编译生成的class，我们就能知道原因了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">iTemp</span> <span class=\"operator\">=</span> i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来，i++后只是赋值给了一个新的<code>局部变量</code>，i本身并没有变，这一点和函数的形参一样，如果传的是<code>引用类型</code>的，那么值会变，如果传的不是引用类型，那么值是不会改变的，改变的也只是局部变量。</p>\n<p>##常见面试题</p>\n<ul>\n<li>1、error和exception有什么区别？</li>\n</ul>\n<blockquote>\n<p>error 表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。<br>exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题</p>\n</blockquote>\n<ul>\n<li>2、运行时异常和一般异常有何不同</li>\n</ul>\n<blockquote>\n<p>Java 提供了两类主要的异常：runtimeException 和 checkedException<br>一般异常（checkedException）主要是指 IO 异常、SQL 异常等。对于这种异常，JVM 要求我们必须对其进行 cathc 处理，所以，面对这种异常，不管我们是否愿意，都是要 写一大堆的 catch 块去处理可能出现的异常。<br>运行时异常（runtimeException）我们一般不处理，当出现这类异常的时候程序会由虚拟机接管。比如，我们从来没有去处理过 NullPointerException，而且这个异常还是最 常见的异常之一。<br>出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有 catch 块进行处理，到了最上层，如果是多线程就有 Thread.run()抛出，如果不是多线程 那么就由 main.run() 抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。<br>其实运行时异常的也是继承自 Exception，也可以用 catch 块对其处理，只是我们一般不处理罢了，也就是说，如果不对运行时异常进行 catch 处理，那么结果不是线程退出就是 主程序终止。<br>如果不想终止，那么我们就必须捕获所有可能出现的运行时异常。如果程序中出现了异常数据，但是它不影响下面的程序执行，那么我们就该在catch块里面将异常数据舍弃， 然后记录日志。如果，它影响到了下面的程序运行，那么还是程序退出比较好些。</p>\n</blockquote>\n<ul>\n<li>3、Java 中异常处理机制的原理</li>\n</ul>\n<blockquote>\n<p>Jav a通过面向对象的方式对异常进行处理，Java 把异常按照不同的类型进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它都是 Throwable 或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java 的异常处理是通过5个 关键词来实现的：try、catch、throw、throws、finally。<br>try：用来指定一块预防所有异常的程序<br>catch：紧跟在try后面，用来捕获异常<br>throw：用来明确的抛出一个异常<br>throws：用来标明一个成员函数可能抛出的各种异常<br>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</p>\n</blockquote>\n<ul>\n<li><p>4、你平时在项目中是怎样对异常进行处理的。</p>\n<blockquote>\n<p>1）尽量避免出现 runtimeException。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对 runtimeException也进行 try catch 处理。<br>2）进行 try catch 处理的时候要在 catch 代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息。</p>\n</blockquote>\n</li>\n<li><p>5、final、finally、finalize的区别</p>\n<blockquote>\n<p>（1）、final 用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承<br>（2）、finally 是异常处理中的一个关键字，表示 finally{} 里面的代码一定要执行<br>（3）、finalize 是 Object 类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分享了Java中日志的处理（下）：Java中日志实际使用中的相关注意点</p>\n<p>本期我们将分享Java中异常的处理（上）</p>\n</blockquote>","more":"<p>##异常定义<br>在《java编程思想》中这样定义异常：阻止当前方法或作用域继续执行的问题。<br>##异常分类<br>首先我们看下Java中异常的继承关系：</p>\n<p>可以看出，<code>Throwable</code>有两个子类：<code>Error</code>和<code>Exception</code></p>\n<ul>\n<li><code>Error</code><ul>\n<li>VirtualMachineError，典型的有<code>StackOverFlow</code>和<code>OutOfMemory</code></li>\n<li>AWTError</li>\n</ul>\n</li>\n<li><code>Exception</code><ul>\n<li>IOException</li>\n<li>…</li>\n<li>RuntimeException</li>\n</ul>\n</li>\n</ul>\n<p>Exception分为CheckedException和UncheckedException，那么CheckedException和UncheckedException区别是什么呢？</p>\n<ul>\n<li><code>UncheckedException</code>：派生于Error或者RuntimeException的异常</li>\n<li><code>CheckedException</code>：所有其他的异常</li>\n</ul>\n<p>##异常处理机制<br>异常处理机制分为：抛出异常和捕捉异常</p>\n<p>抛出异常：方法上使用<code>throws</code>，方法内使用<code>throw</code><br>捕捉异常：使用<code>try-catch</code>或者<code>try-catch-finally</code></p>\n<p>原则，正如手册上所说：</p>\n<ul>\n<li>不要直接忽略异常</li>\n<li>不要用try-catch包住太多语句</li>\n<li>不要用异常处理来处理程序的正常控制流</li>\n<li>不要随便将异常迎函数栈向上传递，能处理尽量处理</li>\n</ul>\n<p>何时向上传播？</p>\n<ul>\n<li>当你认为本异常应该由上层处理时，才向上传播</li>\n</ul>\n<p>##注意点</p>\n<ul>\n<li><code>finally</code>语句块一定会执行吗？</li>\n</ul>\n<blockquote>\n<p><strong>不一定会</strong>，以下两种情况finally语句块不会执行</p>\n<ol>\n<li>未执行到try语句块</li>\n<li>try语句块中有System.exit(0);</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>finally</code>语句块的执行顺序</li>\n</ul>\n<p>首先看没有控制语句的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出没有疑问：<br>try block<br>finally block</p>\n<blockquote>\n<p>1、如果<code>try</code>中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句之前执行还是之后执行？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;test1()&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;return&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br>try block<br>test1()<br>finally block<br>return</p>\n<p>所以说，如果<code>try</code>中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句<strong>之前</strong>执行</p>\n<blockquote>\n<p>2、如果<code>catch</code>语句中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句之前执行还是之后执行？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">&quot;test1()&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;return&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;try block&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"number\">1</span> / <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;catch block&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> test1();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;finally block&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>try block<br>catch block<br>test1()<br>finally block<br>return</p>\n<p>所以说，如果<code>catch</code>语句中有控制语句（<code>return</code>、<code>break</code>、<code>continue</code>），那<code>finally</code>语句块是在控制转义语句<strong>之前</strong>执行</p>\n<ul>\n<li><code>finally</code>里的变量</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\tSystem.out.println(test());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：<br>0</p>\n<p>咦？很奇怪，为什么是0，而不是1呢？</p>\n<p>通过反编译生成的class，我们就能知道原因了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">iTemp</span> <span class=\"operator\">=</span> i++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来，i++后只是赋值给了一个新的<code>局部变量</code>，i本身并没有变，这一点和函数的形参一样，如果传的是<code>引用类型</code>的，那么值会变，如果传的不是引用类型，那么值是不会改变的，改变的也只是局部变量。</p>\n<p>##常见面试题</p>\n<ul>\n<li>1、error和exception有什么区别？</li>\n</ul>\n<blockquote>\n<p>error 表示系统级的错误，是java运行环境内部错误或者硬件问题，不能指望程序来处理这样的问题，除了退出运行外别无选择，它是Java虚拟机抛出的。<br>exception 表示程序需要捕捉、需要处理的异常，是由与程序设计的不完善而出现的问题，程序必须处理的问题</p>\n</blockquote>\n<ul>\n<li>2、运行时异常和一般异常有何不同</li>\n</ul>\n<blockquote>\n<p>Java 提供了两类主要的异常：runtimeException 和 checkedException<br>一般异常（checkedException）主要是指 IO 异常、SQL 异常等。对于这种异常，JVM 要求我们必须对其进行 cathc 处理，所以，面对这种异常，不管我们是否愿意，都是要 写一大堆的 catch 块去处理可能出现的异常。<br>运行时异常（runtimeException）我们一般不处理，当出现这类异常的时候程序会由虚拟机接管。比如，我们从来没有去处理过 NullPointerException，而且这个异常还是最 常见的异常之一。<br>出现运行时异常的时候，程序会将异常一直向上抛，一直抛到遇到处理代码，如果没有 catch 块进行处理，到了最上层，如果是多线程就有 Thread.run()抛出，如果不是多线程 那么就由 main.run() 抛出。抛出之后，如果是线程，那么该线程也就终止了，如果是主程序，那么该程序也就终止了。<br>其实运行时异常的也是继承自 Exception，也可以用 catch 块对其处理，只是我们一般不处理罢了，也就是说，如果不对运行时异常进行 catch 处理，那么结果不是线程退出就是 主程序终止。<br>如果不想终止，那么我们就必须捕获所有可能出现的运行时异常。如果程序中出现了异常数据，但是它不影响下面的程序执行，那么我们就该在catch块里面将异常数据舍弃， 然后记录日志。如果，它影响到了下面的程序运行，那么还是程序退出比较好些。</p>\n</blockquote>\n<ul>\n<li>3、Java 中异常处理机制的原理</li>\n</ul>\n<blockquote>\n<p>Jav a通过面向对象的方式对异常进行处理，Java 把异常按照不同的类型进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它都是 Throwable 或其子类的实例。当一个方法出现异常后就会抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并对异常进行处理。Java 的异常处理是通过5个 关键词来实现的：try、catch、throw、throws、finally。<br>try：用来指定一块预防所有异常的程序<br>catch：紧跟在try后面，用来捕获异常<br>throw：用来明确的抛出一个异常<br>throws：用来标明一个成员函数可能抛出的各种异常<br>finally：确保一段代码无论发生什么异常都会被执行的一段代码。</p>\n</blockquote>\n<ul>\n<li><p>4、你平时在项目中是怎样对异常进行处理的。</p>\n<blockquote>\n<p>1）尽量避免出现 runtimeException。例如对于可能出现空指针的代码，带使用对象之前一定要判断一下该对象是否为空，必要的时候对 runtimeException也进行 try catch 处理。<br>2）进行 try catch 处理的时候要在 catch 代码块中对异常信息进行记录，通过调用异常类的相关方法获取到异常的相关信息。</p>\n</blockquote>\n</li>\n<li><p>5、final、finally、finalize的区别</p>\n<blockquote>\n<p>（1）、final 用于声明变量、方法和类的，分别表示变量值不可变，方法不可覆盖，类不可以继承<br>（2）、finally 是异常处理中的一个关键字，表示 finally{} 里面的代码一定要执行<br>（3）、finalize 是 Object 类的一个方法，在垃圾回收的时候会调用被回收对象的此方法。</p>\n</blockquote>\n</li>\n</ul>"},{"title":"阿里Java开发手册思考（四）","date":"2017-12-10T16:32:56.000Z","_content":">上期我们分享了Java中日志的处理（上）：Java中日志的相关知识、Slf4j的原理及源码分析\n>\n>本期我们将分享Java中日志的处理（下）\n\n<!--more-->\n##首先看下阿里Java开发手册中日志规约的剩余几条并给出分析：\n+ 2.【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n>+ 分析：\n    + 如果使用的是`Log4j`，且采用的`RollingFileAppender`方式, 通过设置`maxBackupIndex`属性来指定要保留的日志文件数的最大值可以间接实现删除N天前的日志文件\n    + 如果使用的是`Log4j`,且采用的`DailyRollingFileAppender`方式，由于该方式不支持`maxBackupIndex`，需要重新实现`DailyRollingFileAppender`，用以支持`maxBackupIndex`的设置\n    + 如果使用的是`Logback`,可以通过设置`maxHistory`实现删除N天前的日志\n\n+ 3.【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等;logName:日志 述。这种命名的好处:通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n正例:mppserver应用中单独监控时区转换异常，如:\nmppserver_monitor_timeZoneConvert.log\n说明:推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n+ 4.【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n说明:logger.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol是对象， 会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 \n\n>正例:(条件)\n\n```java\nif (logger.isDebugEnabled()) {\n    logger.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol);\n}\n```\n>正例:(占位符)\n\n```java\nlogger.debug(\"Processing trade with id: {} and symbol : {} \", id, symbol);\n```\n>+ 分析：\n    + 正如上篇分析的，推荐所有使用`Slf4j`，打印日志统一使用`占位符`，且不需判读isxxxEnabled()\n    \n+ 5.【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 \n正例:\n\n```xml\n<logger name=\"com.taobao.dubbo.config\" additivity=\"false\">\n```\n+ 6.【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。\n正例:\n\n```java\nlogger.error(各类参数或者对象 toString + \"_\" + e.getMessage(), e);\n```\n+ 7.【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明:大量地输出无效日志，不利于系统性能升，也不利于快速定位错误点。记录日志时请 思考:这些日志真的有人看吗?看到这条日志你能做什么?能不能给问题排查带来好处?\n+ 8.【参考】可以使用warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必 要，请不要在此场景打出 error级别。\n\n##补充\n+ 1、 涉及到多线程时，日志中最好将线程id打印出来，以区分不同的线程\n\n```java\npublic final class LogIdThreadLocal {\n    private static ThreadLocal<String> logIdThreadLocal = new ThreadLocal<String>();\n    ...\n}\n\npublic class MyPatternLayout extends PatternLayout {\n    private static final String SPLIT_STRING = \"|\";\n\n    @Override\n    public String format(LoggingEvent event) {\n        String log = super.format(event);\n\n        String threadLocalId = LogIdThreadLocal.getLogId();\n\n        if (StringUtils.isEmpty(threadLocalId)) {\n            threadLocalId = LogIdThreadLocal.create();\n        }\n\n        return log + threadLocalId + SPLIT_STRING + event.getMessage() + Layout.LINE_SEP;\n    }\n}\n```\n```properties\nlog4j.appender.output.layout=com.test.log.MyPatternLayout\nlog4j.appender.output.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss:SSS}|%t|%-5p|%C{1}.%M:%L| \n```\n\n+ 2、 提供动态修改日志级别的接口或者使用Log4j Web Tracker\n\n>对于生产环境，默认的日志级别可能是error/warning/info，对于debug的日志就没有打出来，如果要让debug日志能打印出来，那么常见的方法就是修改log4j.xml或者log4j.properties文件，修改了之后需要重启tomcat，我们知道，生产环境是不可能随随便便重启的，那么有没有其他方法呢？答案是：有。\nLog4j为我们提供了这样的API,通过调用Log4j的API，提供rest接口，使得客户端可以动态修改某个日志的级别：\n\n```java\nprivate String changeLoggerLevel(String loggerName, String level) {  \n    Logger logger = LogManager.exists(loggerName);  \n    String result = null;  \n    if (logger != null) {  \n        logger.setLevel(Level.toLevel(level));  \n        result = logger.getName() + \"|\" + logger.getLevel();  \n    } else {  \n        result = \"logger not exist.\";  \n    }  \n    return result;  \n}  \n```\n\n>此外，推荐一个开源的第三方组件：[Log4j Web Track](https://github.com/mrsarm/log4jwebtracker)（链接为Github地址），如下图：\n\n![Log4j Web Tracker](https://camo.githubusercontent.com/cfe2a15ea9620ccd2d8993a4a65ac0e2139a18f7/68747470733a2f2f7261772e6769746875622e636f6d2f6d727361726d2f6c6f67346a776562747261636b65722f6d61737465722f617274776f726b2f6c6f67346a776562747261636b65725f636f6e6669672e706e67)\n>相关配置：\n\n```xml\n<servlet>\n    <servlet-name>TrackerServlet</servlet-name>\n    <servlet-class>log4jwebtracker.servlet.TrackerServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>TrackerServlet</servlet-name>\n    <url-pattern>/tracker/*</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>Log4jInitServlet</servlet-name>\n    <servlet-class>log4jwebtracker.servlet.init.Log4jInitServlet</servlet-class>\n    <init-param>\n        <param-name>log4jConfigLocation</param-name>\n        <param-value>WEB-INF/classes/log4j.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n```\n>通过阅读源码，其也是调用了Log4j的API，进行了展示：\n\n```java\npublic abstract class LoggingUtils {\n\n\tstatic synchronized public List getFileAppenders() {\n\t\tList list = new ArrayList();\n\t\tEnumeration e = LogManager.getRootLogger().getAllAppenders();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tAppender a = (Appender) e.nextElement();\n\t\t\tif(a instanceof FileAppender) {\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tstatic synchronized public FileAppender getFileAppender(String appenderName) {\n\t\tEnumeration e = LogManager.getRootLogger().getAllAppenders();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tAppender a = (Appender) e.nextElement();\n\t\t\tif(a instanceof FileAppender && a.getName().equals(appenderName)) {\n\t\t\t\treturn (FileAppender) a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic public boolean contains(List loggers, String loggerName) {\n\t\tint i=0;\n\t\twhile(i<loggers.size()) {\n\t\t\tif(((Logger)loggers.get(i)).getName().equals(loggerName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic public List getLoggers() {\n\t\tEnumeration e = LogManager.getCurrentLoggers();\n\t\tList loggersList = new LinkedList();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tloggersList.add(e.nextElement());\n\t\t}\n\t\tCollections.sort(loggersList, new Comparator() {\n\t\t\tpublic int compare(Object arg0, Object arg1) {\n\t\t\t\tLogger log0 = (Logger) arg0;\n\t\t\t\tLogger log1 = (Logger) arg1;\n\t\t\t\treturn log0.getName().compareTo(log1.getName());\n\t\t\t}\n\t\t});\n\t\tloggersList.add(0, LogManager.getRootLogger());\n\t\treturn loggersList;\n\t}\n}\n```\n\n>**如果有兴趣的话，我们可以实现一个Web Tracker的门面，类似于Slf4j，那么对于Log4j1/2、LogBack、Juc、Commons Logging的日志都能实现可视化以及动态修改日志级别的功能**\n\n\n\n","source":"_posts/阿里Java开发手册思考（四）.md","raw":"title: 阿里Java开发手册思考（四）\ndate: 2017-12-11 00:32:56\ncategories: Java\ntags: [Java,阿里Java开发手册]\n---\n>上期我们分享了Java中日志的处理（上）：Java中日志的相关知识、Slf4j的原理及源码分析\n>\n>本期我们将分享Java中日志的处理（下）\n\n<!--more-->\n##首先看下阿里Java开发手册中日志规约的剩余几条并给出分析：\n+ 2.【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。\n\n>+ 分析：\n    + 如果使用的是`Log4j`，且采用的`RollingFileAppender`方式, 通过设置`maxBackupIndex`属性来指定要保留的日志文件数的最大值可以间接实现删除N天前的日志文件\n    + 如果使用的是`Log4j`,且采用的`DailyRollingFileAppender`方式，由于该方式不支持`maxBackupIndex`，需要重新实现`DailyRollingFileAppender`，用以支持`maxBackupIndex`的设置\n    + 如果使用的是`Logback`,可以通过设置`maxHistory`实现删除N天前的日志\n\n+ 3.【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit 等;logName:日志 述。这种命名的好处:通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。\n正例:mppserver应用中单独监控时区转换异常，如:\nmppserver_monitor_timeZoneConvert.log\n说明:推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。\n\n+ 4.【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。\n说明:logger.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol是对象， 会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 \n\n>正例:(条件)\n\n```java\nif (logger.isDebugEnabled()) {\n    logger.debug(\"Processing trade with id: \" + id + \" and symbol: \" + symbol);\n}\n```\n>正例:(占位符)\n\n```java\nlogger.debug(\"Processing trade with id: {} and symbol : {} \", id, symbol);\n```\n>+ 分析：\n    + 正如上篇分析的，推荐所有使用`Slf4j`，打印日志统一使用`占位符`，且不需判读isxxxEnabled()\n    \n+ 5.【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。 \n正例:\n\n```xml\n<logger name=\"com.taobao.dubbo.config\" additivity=\"false\">\n```\n+ 6.【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。\n正例:\n\n```java\nlogger.error(各类参数或者对象 toString + \"_\" + e.getMessage(), e);\n```\n+ 7.【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明:大量地输出无效日志，不利于系统性能升，也不利于快速定位错误点。记录日志时请 思考:这些日志真的有人看吗?看到这条日志你能做什么?能不能给问题排查带来好处?\n+ 8.【参考】可以使用warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必 要，请不要在此场景打出 error级别。\n\n##补充\n+ 1、 涉及到多线程时，日志中最好将线程id打印出来，以区分不同的线程\n\n```java\npublic final class LogIdThreadLocal {\n    private static ThreadLocal<String> logIdThreadLocal = new ThreadLocal<String>();\n    ...\n}\n\npublic class MyPatternLayout extends PatternLayout {\n    private static final String SPLIT_STRING = \"|\";\n\n    @Override\n    public String format(LoggingEvent event) {\n        String log = super.format(event);\n\n        String threadLocalId = LogIdThreadLocal.getLogId();\n\n        if (StringUtils.isEmpty(threadLocalId)) {\n            threadLocalId = LogIdThreadLocal.create();\n        }\n\n        return log + threadLocalId + SPLIT_STRING + event.getMessage() + Layout.LINE_SEP;\n    }\n}\n```\n```properties\nlog4j.appender.output.layout=com.test.log.MyPatternLayout\nlog4j.appender.output.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss:SSS}|%t|%-5p|%C{1}.%M:%L| \n```\n\n+ 2、 提供动态修改日志级别的接口或者使用Log4j Web Tracker\n\n>对于生产环境，默认的日志级别可能是error/warning/info，对于debug的日志就没有打出来，如果要让debug日志能打印出来，那么常见的方法就是修改log4j.xml或者log4j.properties文件，修改了之后需要重启tomcat，我们知道，生产环境是不可能随随便便重启的，那么有没有其他方法呢？答案是：有。\nLog4j为我们提供了这样的API,通过调用Log4j的API，提供rest接口，使得客户端可以动态修改某个日志的级别：\n\n```java\nprivate String changeLoggerLevel(String loggerName, String level) {  \n    Logger logger = LogManager.exists(loggerName);  \n    String result = null;  \n    if (logger != null) {  \n        logger.setLevel(Level.toLevel(level));  \n        result = logger.getName() + \"|\" + logger.getLevel();  \n    } else {  \n        result = \"logger not exist.\";  \n    }  \n    return result;  \n}  \n```\n\n>此外，推荐一个开源的第三方组件：[Log4j Web Track](https://github.com/mrsarm/log4jwebtracker)（链接为Github地址），如下图：\n\n![Log4j Web Tracker](https://camo.githubusercontent.com/cfe2a15ea9620ccd2d8993a4a65ac0e2139a18f7/68747470733a2f2f7261772e6769746875622e636f6d2f6d727361726d2f6c6f67346a776562747261636b65722f6d61737465722f617274776f726b2f6c6f67346a776562747261636b65725f636f6e6669672e706e67)\n>相关配置：\n\n```xml\n<servlet>\n    <servlet-name>TrackerServlet</servlet-name>\n    <servlet-class>log4jwebtracker.servlet.TrackerServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>TrackerServlet</servlet-name>\n    <url-pattern>/tracker/*</url-pattern>\n</servlet-mapping>\n\n<servlet>\n    <servlet-name>Log4jInitServlet</servlet-name>\n    <servlet-class>log4jwebtracker.servlet.init.Log4jInitServlet</servlet-class>\n    <init-param>\n        <param-name>log4jConfigLocation</param-name>\n        <param-value>WEB-INF/classes/log4j.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n```\n>通过阅读源码，其也是调用了Log4j的API，进行了展示：\n\n```java\npublic abstract class LoggingUtils {\n\n\tstatic synchronized public List getFileAppenders() {\n\t\tList list = new ArrayList();\n\t\tEnumeration e = LogManager.getRootLogger().getAllAppenders();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tAppender a = (Appender) e.nextElement();\n\t\t\tif(a instanceof FileAppender) {\n\t\t\t\tlist.add(a);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tstatic synchronized public FileAppender getFileAppender(String appenderName) {\n\t\tEnumeration e = LogManager.getRootLogger().getAllAppenders();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tAppender a = (Appender) e.nextElement();\n\t\t\tif(a instanceof FileAppender && a.getName().equals(appenderName)) {\n\t\t\t\treturn (FileAppender) a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic public boolean contains(List loggers, String loggerName) {\n\t\tint i=0;\n\t\twhile(i<loggers.size()) {\n\t\t\tif(((Logger)loggers.get(i)).getName().equals(loggerName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic public List getLoggers() {\n\t\tEnumeration e = LogManager.getCurrentLoggers();\n\t\tList loggersList = new LinkedList();\n\t\twhile(e.hasMoreElements()) {\n\t\t\tloggersList.add(e.nextElement());\n\t\t}\n\t\tCollections.sort(loggersList, new Comparator() {\n\t\t\tpublic int compare(Object arg0, Object arg1) {\n\t\t\t\tLogger log0 = (Logger) arg0;\n\t\t\t\tLogger log1 = (Logger) arg1;\n\t\t\t\treturn log0.getName().compareTo(log1.getName());\n\t\t\t}\n\t\t});\n\t\tloggersList.add(0, LogManager.getRootLogger());\n\t\treturn loggersList;\n\t}\n}\n```\n\n>**如果有兴趣的话，我们可以实现一个Web Tracker的门面，类似于Slf4j，那么对于Log4j1/2、LogBack、Juc、Commons Logging的日志都能实现可视化以及动态修改日志级别的功能**\n\n\n\n","slug":"阿里Java开发手册思考（四）","published":1,"updated":"2025-03-07T13:26:47.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm7yvcz3r006lrz5m3z3ofb0k","content":"<blockquote>\n<p>上期我们分享了Java中日志的处理（上）：Java中日志的相关知识、Slf4j的原理及源码分析</p>\n<p>本期我们将分享Java中日志的处理（下）</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>##首先看下阿里Java开发手册中日志规约的剩余几条并给出分析：</p>\n<ul>\n<li>2.【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</li>\n</ul>\n<blockquote>\n<ul>\n<li>分析：<ul>\n<li>如果使用的是<code>Log4j</code>，且采用的<code>RollingFileAppender</code>方式, 通过设置<code>maxBackupIndex</code>属性来指定要保留的日志文件数的最大值可以间接实现删除N天前的日志文件</li>\n<li>如果使用的是<code>Log4j</code>,且采用的<code>DailyRollingFileAppender</code>方式，由于该方式不支持<code>maxBackupIndex</code>，需要重新实现<code>DailyRollingFileAppender</code>，用以支持<code>maxBackupIndex</code>的设置</li>\n<li>如果使用的是<code>Logback</code>,可以通过设置<code>maxHistory</code>实现删除N天前的日志</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>3.【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有stats&#x2F;desc&#x2F;monitor&#x2F;visit 等;logName:日志 述。这种命名的好处:通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br>正例:mppserver应用中单独监控时区转换异常，如:<br>mppserver_monitor_timeZoneConvert.log<br>说明:推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。</p>\n</li>\n<li><p>4.【强制】对trace&#x2F;debug&#x2F;info级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。<br>说明:logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol是对象， 会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</p>\n</li>\n</ul>\n<blockquote>\n<p>正例:(条件)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;Processing trade with id: &quot;</span> + id + <span class=\"string\">&quot; and symbol: &quot;</span> + symbol);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正例:(占位符)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.debug(<span class=\"string\">&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;</span>, id, symbol);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>分析：<ul>\n<li>正如上篇分析的，推荐所有使用<code>Slf4j</code>，打印日志统一使用<code>占位符</code>，且不需判读isxxxEnabled()</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>5.【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。<br>正例:</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.taobao.dubbo.config&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>6.【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。<br>正例:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.error(各类参数或者对象 toString + <span class=\"string\">&quot;_&quot;</span> + e.getMessage(), e);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>7.【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明:大量地输出无效日志，不利于系统性能升，也不利于快速定位错误点。记录日志时请 思考:这些日志真的有人看吗?看到这条日志你能做什么?能不能给问题排查带来好处?</li>\n<li>8.【参考】可以使用warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必 要，请不要在此场景打出 error级别。</li>\n</ul>\n<p>##补充</p>\n<ul>\n<li>1、 涉及到多线程时，日志中最好将线程id打印出来，以区分不同的线程</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LogIdThreadLocal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;String&gt; logIdThreadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;String&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyPatternLayout</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PatternLayout</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SPLIT_STRING</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;|&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">format</span><span class=\"params\">(LoggingEvent event)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.format(event);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">threadLocalId</span> <span class=\"operator\">=</span> LogIdThreadLocal.getLogId();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(threadLocalId)) &#123;</span><br><span class=\"line\">            threadLocalId = LogIdThreadLocal.create();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> log + threadLocalId + SPLIT_STRING + event.getMessage() + Layout.LINE_SEP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">log4j.appender.output.layout</span>=<span class=\"string\">com.test.log.MyPatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.output.layout.ConversionPattern</span>=<span class=\"string\">%-d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;|%t|%-5p|%C&#123;1&#125;.%M:%L| </span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2、 提供动态修改日志级别的接口或者使用Log4j Web Tracker</li>\n</ul>\n<blockquote>\n<p>对于生产环境，默认的日志级别可能是error&#x2F;warning&#x2F;info，对于debug的日志就没有打出来，如果要让debug日志能打印出来，那么常见的方法就是修改log4j.xml或者log4j.properties文件，修改了之后需要重启tomcat，我们知道，生产环境是不可能随随便便重启的，那么有没有其他方法呢？答案是：有。<br>Log4j为我们提供了这样的API,通过调用Log4j的API，提供rest接口，使得客户端可以动态修改某个日志的级别：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">changeLoggerLevel</span><span class=\"params\">(String loggerName, String level)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LogManager.exists(loggerName);  </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">        logger.setLevel(Level.toLevel(level));  </span><br><span class=\"line\">        result = logger.getName() + <span class=\"string\">&quot;|&quot;</span> + logger.getLevel();  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        result = <span class=\"string\">&quot;logger not exist.&quot;</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此外，推荐一个开源的第三方组件：<a href=\"https://github.com/mrsarm/log4jwebtracker\">Log4j Web Track</a>（链接为Github地址），如下图：</p>\n</blockquote>\n<p><img src=\"https://camo.githubusercontent.com/cfe2a15ea9620ccd2d8993a4a65ac0e2139a18f7/68747470733a2f2f7261772e6769746875622e636f6d2f6d727361726d2f6c6f67346a776562747261636b65722f6d61737465722f617274776f726b2f6c6f67346a776562747261636b65725f636f6e6669672e706e67\" alt=\"Log4j Web Tracker\"></p>\n<blockquote>\n<p>相关配置：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>log4jwebtracker.servlet.TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/tracker/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Log4jInitServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>log4jwebtracker.servlet.init.Log4jInitServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>log4jConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>WEB-INF/classes/log4j.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过阅读源码，其也是调用了Log4j的API，进行了展示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> List <span class=\"title function_\">getFileAppenders</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getRootLogger().getAllAppenders();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Appender</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> (Appender) e.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> FileAppender) &#123;</span><br><span class=\"line\">\t\t\t\tlist.add(a);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> FileAppender <span class=\"title function_\">getFileAppender</span><span class=\"params\">(String appenderName)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getRootLogger().getAllAppenders();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Appender</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> (Appender) e.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> FileAppender &amp;&amp; a.getName().equals(appenderName)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> (FileAppender) a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(List loggers, String loggerName)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;loggers.size()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(((Logger)loggers.get(i)).getName().equals(loggerName)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">public</span> List <span class=\"title function_\">getLoggers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getCurrentLoggers();</span><br><span class=\"line\">\t\t<span class=\"type\">List</span> <span class=\"variable\">loggersList</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\tloggersList.add(e.nextElement());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tCollections.sort(loggersList, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object arg0, Object arg1)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Logger</span> <span class=\"variable\">log0</span> <span class=\"operator\">=</span> (Logger) arg0;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Logger</span> <span class=\"variable\">log1</span> <span class=\"operator\">=</span> (Logger) arg1;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> log0.getName().compareTo(log1.getName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tloggersList.add(<span class=\"number\">0</span>, LogManager.getRootLogger());</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loggersList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>如果有兴趣的话，我们可以实现一个Web Tracker的门面，类似于Slf4j，那么对于Log4j1&#x2F;2、LogBack、Juc、Commons Logging的日志都能实现可视化以及动态修改日志级别的功能</strong></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上期我们分享了Java中日志的处理（上）：Java中日志的相关知识、Slf4j的原理及源码分析</p>\n<p>本期我们将分享Java中日志的处理（下）</p>\n</blockquote>","more":"<p>##首先看下阿里Java开发手册中日志规约的剩余几条并给出分析：</p>\n<ul>\n<li>2.【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</li>\n</ul>\n<blockquote>\n<ul>\n<li>分析：<ul>\n<li>如果使用的是<code>Log4j</code>，且采用的<code>RollingFileAppender</code>方式, 通过设置<code>maxBackupIndex</code>属性来指定要保留的日志文件数的最大值可以间接实现删除N天前的日志文件</li>\n<li>如果使用的是<code>Log4j</code>,且采用的<code>DailyRollingFileAppender</code>方式，由于该方式不支持<code>maxBackupIndex</code>，需要重新实现<code>DailyRollingFileAppender</code>，用以支持<code>maxBackupIndex</code>的设置</li>\n<li>如果使用的是<code>Logback</code>,可以通过设置<code>maxHistory</code>实现删除N天前的日志</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>3.【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有stats&#x2F;desc&#x2F;monitor&#x2F;visit 等;logName:日志 述。这种命名的好处:通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br>正例:mppserver应用中单独监控时区转换异常，如:<br>mppserver_monitor_timeZoneConvert.log<br>说明:推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。</p>\n</li>\n<li><p>4.【强制】对trace&#x2F;debug&#x2F;info级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。<br>说明:logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol是对象， 会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</p>\n</li>\n</ul>\n<blockquote>\n<p>正例:(条件)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">    logger.debug(<span class=\"string\">&quot;Processing trade with id: &quot;</span> + id + <span class=\"string\">&quot; and symbol: &quot;</span> + symbol);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正例:(占位符)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.debug(<span class=\"string\">&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;</span>, id, symbol);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>分析：<ul>\n<li>正如上篇分析的，推荐所有使用<code>Slf4j</code>，打印日志统一使用<code>占位符</code>，且不需判读isxxxEnabled()</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>5.【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。<br>正例:</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.taobao.dubbo.config&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>6.【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。<br>正例:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.error(各类参数或者对象 toString + <span class=\"string\">&quot;_&quot;</span> + e.getMessage(), e);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>7.【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志;有选择地输出 info日志;如果使 用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。 说明:大量地输出无效日志，不利于系统性能升，也不利于快速定位错误点。记录日志时请 思考:这些日志真的有人看吗?看到这条日志你能做什么?能不能给问题排查带来好处?</li>\n<li>8.【参考】可以使用warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适 从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必 要，请不要在此场景打出 error级别。</li>\n</ul>\n<p>##补充</p>\n<ul>\n<li>1、 涉及到多线程时，日志中最好将线程id打印出来，以区分不同的线程</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LogIdThreadLocal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;String&gt; logIdThreadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;String&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyPatternLayout</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PatternLayout</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">SPLIT_STRING</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;|&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">format</span><span class=\"params\">(LoggingEvent event)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.format(event);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">threadLocalId</span> <span class=\"operator\">=</span> LogIdThreadLocal.getLogId();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(threadLocalId)) &#123;</span><br><span class=\"line\">            threadLocalId = LogIdThreadLocal.create();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> log + threadLocalId + SPLIT_STRING + event.getMessage() + Layout.LINE_SEP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">log4j.appender.output.layout</span>=<span class=\"string\">com.test.log.MyPatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.output.layout.ConversionPattern</span>=<span class=\"string\">%-d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;|%t|%-5p|%C&#123;1&#125;.%M:%L| </span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>2、 提供动态修改日志级别的接口或者使用Log4j Web Tracker</li>\n</ul>\n<blockquote>\n<p>对于生产环境，默认的日志级别可能是error&#x2F;warning&#x2F;info，对于debug的日志就没有打出来，如果要让debug日志能打印出来，那么常见的方法就是修改log4j.xml或者log4j.properties文件，修改了之后需要重启tomcat，我们知道，生产环境是不可能随随便便重启的，那么有没有其他方法呢？答案是：有。<br>Log4j为我们提供了这样的API,通过调用Log4j的API，提供rest接口，使得客户端可以动态修改某个日志的级别：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> String <span class=\"title function_\">changeLoggerLevel</span><span class=\"params\">(String loggerName, String level)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LogManager.exists(loggerName);  </span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">        logger.setLevel(Level.toLevel(level));  </span><br><span class=\"line\">        result = logger.getName() + <span class=\"string\">&quot;|&quot;</span> + logger.getLevel();  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        result = <span class=\"string\">&quot;logger not exist.&quot;</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此外，推荐一个开源的第三方组件：<a href=\"https://github.com/mrsarm/log4jwebtracker\">Log4j Web Track</a>（链接为Github地址），如下图：</p>\n</blockquote>\n<p><img src=\"https://camo.githubusercontent.com/cfe2a15ea9620ccd2d8993a4a65ac0e2139a18f7/68747470733a2f2f7261772e6769746875622e636f6d2f6d727361726d2f6c6f67346a776562747261636b65722f6d61737465722f617274776f726b2f6c6f67346a776562747261636b65725f636f6e6669672e706e67\" alt=\"Log4j Web Tracker\"></p>\n<blockquote>\n<p>相关配置：</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>log4jwebtracker.servlet.TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TrackerServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/tracker/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>Log4jInitServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>log4jwebtracker.servlet.init.Log4jInitServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>log4jConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>WEB-INF/classes/log4j.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过阅读源码，其也是调用了Log4j的API，进行了展示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> List <span class=\"title function_\">getFileAppenders</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getRootLogger().getAllAppenders();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Appender</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> (Appender) e.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> FileAppender) &#123;</span><br><span class=\"line\">\t\t\t\tlist.add(a);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> list;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> FileAppender <span class=\"title function_\">getFileAppender</span><span class=\"params\">(String appenderName)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getRootLogger().getAllAppenders();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">Appender</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> (Appender) e.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> FileAppender &amp;&amp; a.getName().equals(appenderName)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> (FileAppender) a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">contains</span><span class=\"params\">(List loggers, String loggerName)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(i&lt;loggers.size()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(((Logger)loggers.get(i)).getName().equals(loggerName)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">public</span> List <span class=\"title function_\">getLoggers</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Enumeration</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> LogManager.getCurrentLoggers();</span><br><span class=\"line\">\t\t<span class=\"type\">List</span> <span class=\"variable\">loggersList</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(e.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\tloggersList.add(e.nextElement());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tCollections.sort(loggersList, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object arg0, Object arg1)</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Logger</span> <span class=\"variable\">log0</span> <span class=\"operator\">=</span> (Logger) arg0;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Logger</span> <span class=\"variable\">log1</span> <span class=\"operator\">=</span> (Logger) arg1;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> log0.getName().compareTo(log1.getName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tloggersList.add(<span class=\"number\">0</span>, LogManager.getRootLogger());</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loggersList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>如果有兴趣的话，我们可以实现一个Web Tracker的门面，类似于Slf4j，那么对于Log4j1&#x2F;2、LogBack、Juc、Commons Logging的日志都能实现可视化以及动态修改日志级别的功能</strong></p>\n</blockquote>"}],"PostAsset":[{"_id":"source/_posts/jdk-collection/jdk-collection.png","slug":"jdk-collection.png","post":"cm7yvcz2r002orz5m5fwdg190","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cm7yvcz1x0001rz5mh8epbe6e","category_id":"cm7yvcz230004rz5md6xfa5cd","_id":"cm7yvcz29000grz5m4d1v97ly"},{"post_id":"cm7yvcz210003rz5mbkvbgevh","category_id":"cm7yvcz230004rz5md6xfa5cd","_id":"cm7yvcz2b000nrz5m6ofjbi5w"},{"post_id":"cm7yvcz28000drz5mez43cfjq","category_id":"cm7yvcz29000irz5mb0n82zix","_id":"cm7yvcz2e000urz5mfdjkbdux"},{"post_id":"cm7yvcz2b000rrz5m0thqd5gl","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2g000zrz5mcenpbu0q"},{"post_id":"cm7yvcz29000frz5m1s5f0db9","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2g0012rz5mh9f50cd4"},{"post_id":"cm7yvcz2c000trz5m5rqlbrdr","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2h0015rz5maxm8h09v"},{"post_id":"cm7yvcz2e000wrz5m9qrkf66g","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2h0019rz5mg2653dzx"},{"post_id":"cm7yvcz2b000prz5m452xchu9","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2i001crz5m4b3zaojr"},{"post_id":"cm7yvcz2g000yrz5m95akbbk0","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2i001frz5m6gzehoaj"},{"post_id":"cm7yvcz2g0011rz5mcwbg7l3u","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2j001irz5mgjlkcp5a"},{"post_id":"cm7yvcz2g0014rz5m3cdq4iul","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2j001mrz5m3z2pandr"},{"post_id":"cm7yvcz2h0018rz5m3yv77t4f","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2j001prz5m9oc9ghlz"},{"post_id":"cm7yvcz2h001brz5mgpub81ww","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2k001srz5m4zvn2zi3"},{"post_id":"cm7yvcz2i001erz5mbj3l8hdr","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2k001vrz5mgwix0ae2"},{"post_id":"cm7yvcz2i001hrz5m181w7vy9","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2m001xrz5mf54f2u9y"},{"post_id":"cm7yvcz2j001lrz5m0ftfh2m5","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2m0021rz5m4mx83dt8"},{"post_id":"cm7yvcz2j001orz5m45cc5cc8","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2n0024rz5mdi2hcxp6"},{"post_id":"cm7yvcz2k001rrz5mcdfo8pfu","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2p0028rz5m2dk75zz9"},{"post_id":"cm7yvcz2k001urz5meweqdkzu","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2q002brz5m9o2o1s68"},{"post_id":"cm7yvcz2l001wrz5m7uim4l3v","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2q002frz5mezs9dnli"},{"post_id":"cm7yvcz2m0020rz5m5zimbtz4","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2r002irz5m9bp3en2d"},{"post_id":"cm7yvcz2n0023rz5mc2sn09vm","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2r002mrz5mabog6zla"},{"post_id":"cm7yvcz2n0027rz5m23sq4216","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2t002prz5mfxqm7hvg"},{"post_id":"cm7yvcz2p002arz5mcr5g4usg","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2u002trz5mgisr9321"},{"post_id":"cm7yvcz2q002erz5mccdg0b4s","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2u002xrz5mddz7fou3"},{"post_id":"cm7yvcz2q002hrz5md7l79wp7","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2v0031rz5mab627cax"},{"post_id":"cm7yvcz2r002lrz5m2ekuhayq","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2w0035rz5m7xyc2owu"},{"post_id":"cm7yvcz2u002srz5m6jbf301g","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz2w0039rz5m7blp4ke3"},{"post_id":"cm7yvcz2r002orz5m5fwdg190","category_id":"cm7yvcz2u002urz5m1u5jcdzc","_id":"cm7yvcz2x003crz5m9p2n7w1h"},{"post_id":"cm7yvcz2w0038rz5m0h0f0i48","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz2z003jrz5ma1w37j7u"},{"post_id":"cm7yvcz2u002wrz5mb99z5vbi","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz30003orz5m90b24k1c"},{"post_id":"cm7yvcz2w003brz5m5fhhe7rw","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz31003rrz5magia84e8"},{"post_id":"cm7yvcz2x003grz5me7ylh4eu","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz31003urz5mednb8ydh"},{"post_id":"cm7yvcz2v0030rz5mela2h86n","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz32003xrz5m7xqh9w16"},{"post_id":"cm7yvcz2y003irz5mg9fl9gtk","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz320041rz5m04grh1zt"},{"post_id":"cm7yvcz2z003nrz5m4acdbyoj","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz330044rz5m1bocamsc"},{"post_id":"cm7yvcz2v0033rz5maiyccl52","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz330048rz5mhcv50vdy"},{"post_id":"cm7yvcz30003qrz5m53u81000","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz33004brz5mbwp0g77q"},{"post_id":"cm7yvcz31003trz5m9g1j1ej7","category_id":"cm7yvcz2v0034rz5m37602y35","_id":"cm7yvcz34004frz5m5qjfa7za"},{"post_id":"cm7yvcz33004arz5md2eq4qdw","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz34004jrz5m0frp853v"},{"post_id":"cm7yvcz34004erz5m36zg6qfs","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz34004lrz5m9h872y6o"},{"post_id":"cm7yvcz3o006irz5m13up7r78","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz3r006nrz5m1wtvberf"},{"post_id":"cm7yvcz3r006jrz5mgepp3cfk","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz3r006prz5m3l9md3wy"},{"post_id":"cm7yvcz3r006lrz5m3z3ofb0k","category_id":"cm7yvcz2b000qrz5m2vkc82me","_id":"cm7yvcz3s006rrz5mg0p39ziq"}],"PostTag":[{"post_id":"cm7yvcz260008rz5m16dv64ho","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz28000crz5mc1srh1c5"},{"post_id":"cm7yvcz1x0001rz5mh8epbe6e","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz29000erz5mdgzu2xv4"},{"post_id":"cm7yvcz270009rz5m6ztfdrcp","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2a000jrz5m5cjcgrwa"},{"post_id":"cm7yvcz210003rz5mbkvbgevh","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2a000lrz5m63s4fkjq"},{"post_id":"cm7yvcz250007rz5m1wd5bnqj","tag_id":"cm7yvcz29000hrz5m1el02w7a","_id":"cm7yvcz2g0010rz5mfhfufftd"},{"post_id":"cm7yvcz250007rz5m1wd5bnqj","tag_id":"cm7yvcz2b000orz5m3yasexuk","_id":"cm7yvcz2g0013rz5m9x1qe8qc"},{"post_id":"cm7yvcz250007rz5m1wd5bnqj","tag_id":"cm7yvcz2c000srz5m5ftqazqr","_id":"cm7yvcz2h0017rz5mak1le7vq"},{"post_id":"cm7yvcz28000drz5mez43cfjq","tag_id":"cm7yvcz2f000xrz5m41sy95is","_id":"cm7yvcz2h001arz5mg3dz25b6"},{"post_id":"cm7yvcz29000frz5m1s5f0db9","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2i001grz5mclvievav"},{"post_id":"cm7yvcz29000frz5m1s5f0db9","tag_id":"cm7yvcz2h0016rz5mcllb3hp2","_id":"cm7yvcz2j001jrz5m65v0aol3"},{"post_id":"cm7yvcz2a000krz5m7pei4l1l","tag_id":"cm7yvcz2i001drz5m7tn0arb4","_id":"cm7yvcz2j001nrz5mffrygo54"},{"post_id":"cm7yvcz2a000mrz5mhowyh1ji","tag_id":"cm7yvcz2j001krz5m888ue7u9","_id":"cm7yvcz2k001trz5mehtj3p3f"},{"post_id":"cm7yvcz2b000prz5m452xchu9","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2m001zrz5mgyx7bd99"},{"post_id":"cm7yvcz2b000prz5m452xchu9","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2n0022rz5mfzjw66c2"},{"post_id":"cm7yvcz2b000rrz5m0thqd5gl","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2n0026rz5m15jc46yc"},{"post_id":"cm7yvcz2b000rrz5m0thqd5gl","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2p0029rz5mh51t75ji"},{"post_id":"cm7yvcz2c000trz5m5rqlbrdr","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2q002drz5mdjmaa9iy"},{"post_id":"cm7yvcz2c000trz5m5rqlbrdr","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2q002grz5m3var4tah"},{"post_id":"cm7yvcz2e000wrz5m9qrkf66g","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2r002krz5me479fjns"},{"post_id":"cm7yvcz2e000wrz5m9qrkf66g","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2r002nrz5m4hmm1089"},{"post_id":"cm7yvcz2g000yrz5m95akbbk0","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2t002rrz5m4afw6fcb"},{"post_id":"cm7yvcz2g000yrz5m95akbbk0","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2u002vrz5mg06fhoap"},{"post_id":"cm7yvcz2g0011rz5mcwbg7l3u","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2v002zrz5m26588csg"},{"post_id":"cm7yvcz2g0011rz5mcwbg7l3u","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2v0032rz5mcknm2awy"},{"post_id":"cm7yvcz2g0014rz5m3cdq4iul","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2w0037rz5mdtl2br2u"},{"post_id":"cm7yvcz2g0014rz5m3cdq4iul","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2w003arz5mcoqs5o66"},{"post_id":"cm7yvcz2h0018rz5m3yv77t4f","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2x003frz5m5g006bhy"},{"post_id":"cm7yvcz2h0018rz5m3yv77t4f","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz2y003hrz5m1jfb0109"},{"post_id":"cm7yvcz2h001brz5mgpub81ww","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz2z003mrz5maj5id9uz"},{"post_id":"cm7yvcz2h001brz5mgpub81ww","tag_id":"cm7yvcz2k001qrz5m8y53ajsa","_id":"cm7yvcz30003prz5mbjvp5xw4"},{"post_id":"cm7yvcz2i001erz5mbj3l8hdr","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz31003vrz5mdgafb7ak"},{"post_id":"cm7yvcz2i001erz5mbj3l8hdr","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz32003yrz5md0ss963c"},{"post_id":"cm7yvcz2i001hrz5m181w7vy9","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz320042rz5m5w529enc"},{"post_id":"cm7yvcz2i001hrz5m181w7vy9","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz330045rz5mhcwhgwut"},{"post_id":"cm7yvcz31003wrz5mgtd9bo8a","tag_id":"cm7yvcz2c000srz5m5ftqazqr","_id":"cm7yvcz330049rz5mhbglgdyu"},{"post_id":"cm7yvcz31003wrz5mgtd9bo8a","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz33004crz5m29azhboq"},{"post_id":"cm7yvcz320040rz5m5gyba3f9","tag_id":"cm7yvcz2c000srz5m5ftqazqr","_id":"cm7yvcz34004grz5md9wc272e"},{"post_id":"cm7yvcz320040rz5m5gyba3f9","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz34004hrz5mcztygaf0"},{"post_id":"cm7yvcz2j001lrz5m0ftfh2m5","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz34004krz5m23oxa3ij"},{"post_id":"cm7yvcz2j001lrz5m0ftfh2m5","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz34004mrz5m7lrtc9hh"},{"post_id":"cm7yvcz320043rz5mer779wev","tag_id":"cm7yvcz2c000srz5m5ftqazqr","_id":"cm7yvcz35004orz5m8om69jou"},{"post_id":"cm7yvcz320043rz5mer779wev","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz35004prz5m9mcc8bq0"},{"post_id":"cm7yvcz2j001orz5m45cc5cc8","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz35004rrz5m37itf0ha"},{"post_id":"cm7yvcz2j001orz5m45cc5cc8","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz35004srz5m1ars3o38"},{"post_id":"cm7yvcz2k001rrz5mcdfo8pfu","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz35004urz5md94q5kk4"},{"post_id":"cm7yvcz2k001rrz5mcdfo8pfu","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz35004vrz5mezd9d3gh"},{"post_id":"cm7yvcz2k001urz5meweqdkzu","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz35004xrz5mbnt6cyyb"},{"post_id":"cm7yvcz2k001urz5meweqdkzu","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz35004yrz5meo8f04bc"},{"post_id":"cm7yvcz2l001wrz5m7uim4l3v","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz360050rz5m0m6052d7"},{"post_id":"cm7yvcz2l001wrz5m7uim4l3v","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz360051rz5m7ydzff15"},{"post_id":"cm7yvcz2m0020rz5m5zimbtz4","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz360053rz5mfehw6v9g"},{"post_id":"cm7yvcz2m0020rz5m5zimbtz4","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz360054rz5m1svu58bo"},{"post_id":"cm7yvcz2n0023rz5mc2sn09vm","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz360056rz5m9bx16wf4"},{"post_id":"cm7yvcz2n0023rz5mc2sn09vm","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz360057rz5mcb92c989"},{"post_id":"cm7yvcz2n0027rz5m23sq4216","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz370059rz5m2s81ff69"},{"post_id":"cm7yvcz2n0027rz5m23sq4216","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz38005arz5m9ledh9lm"},{"post_id":"cm7yvcz2p002arz5mcr5g4usg","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz38005crz5m570ff1sw"},{"post_id":"cm7yvcz2p002arz5mcr5g4usg","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz39005drz5mb1jfepty"},{"post_id":"cm7yvcz2q002erz5mccdg0b4s","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz39005frz5m8zq596vd"},{"post_id":"cm7yvcz2q002erz5mccdg0b4s","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz39005grz5mew726wp0"},{"post_id":"cm7yvcz2q002hrz5md7l79wp7","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz39005irz5meb0ndxwy"},{"post_id":"cm7yvcz2q002hrz5md7l79wp7","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz3a005jrz5md1pdgxs5"},{"post_id":"cm7yvcz2r002lrz5m2ekuhayq","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3b005lrz5mgga8323j"},{"post_id":"cm7yvcz2r002lrz5m2ekuhayq","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz3b005mrz5m59hnfgm6"},{"post_id":"cm7yvcz2r002orz5m5fwdg190","tag_id":"cm7yvcz38005brz5mcez0e91x","_id":"cm7yvcz3b005orz5m1b5dgbl9"},{"post_id":"cm7yvcz2u002srz5m6jbf301g","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3b005prz5m9m7ib280"},{"post_id":"cm7yvcz2u002srz5m6jbf301g","tag_id":"cm7yvcz2z003krz5mec50bpzp","_id":"cm7yvcz3b005rrz5m9pbf5zng"},{"post_id":"cm7yvcz2u002wrz5mb99z5vbi","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3b005srz5m31tr0nod"},{"post_id":"cm7yvcz2v0030rz5mela2h86n","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3b005urz5mcv9a3yws"},{"post_id":"cm7yvcz2v0033rz5maiyccl52","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3b005vrz5mb23w5ms4"},{"post_id":"cm7yvcz2w0038rz5m0h0f0i48","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3c005xrz5m6gj70g0p"},{"post_id":"cm7yvcz2w003brz5m5fhhe7rw","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3c005yrz5mcyew0vpt"},{"post_id":"cm7yvcz2x003grz5me7ylh4eu","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3c0060rz5m8ro8br09"},{"post_id":"cm7yvcz2y003irz5mg9fl9gtk","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3c0062rz5m62h74p1h"},{"post_id":"cm7yvcz2z003nrz5m4acdbyoj","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3d0064rz5mfr8r7zuo"},{"post_id":"cm7yvcz30003qrz5m53u81000","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3d0066rz5mf77d41ah"},{"post_id":"cm7yvcz31003trz5m9g1j1ej7","tag_id":"cm7yvcz39005hrz5mesx81b8g","_id":"cm7yvcz3e0068rz5m3y92fr9a"},{"post_id":"cm7yvcz330047rz5ma5xado15","tag_id":"cm7yvcz2c000srz5m5ftqazqr","_id":"cm7yvcz3e006arz5mcww27j1f"},{"post_id":"cm7yvcz330047rz5ma5xado15","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3e006brz5m3v833045"},{"post_id":"cm7yvcz330047rz5ma5xado15","tag_id":"cm7yvcz3d0067rz5m5yl72yba","_id":"cm7yvcz3f006drz5mfkj7dvr2"},{"post_id":"cm7yvcz33004arz5md2eq4qdw","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3f006erz5m5pmt9lgh"},{"post_id":"cm7yvcz33004arz5md2eq4qdw","tag_id":"cm7yvcz3e0069rz5mge9bef0i","_id":"cm7yvcz3g006frz5mcraoagqm"},{"post_id":"cm7yvcz34004erz5m36zg6qfs","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3g006grz5meq1618vi"},{"post_id":"cm7yvcz34004erz5m36zg6qfs","tag_id":"cm7yvcz3e0069rz5mge9bef0i","_id":"cm7yvcz3g006hrz5mdp0bbm91"},{"post_id":"cm7yvcz3o006irz5m13up7r78","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3r006krz5m38oqd77h"},{"post_id":"cm7yvcz3o006irz5m13up7r78","tag_id":"cm7yvcz3e0069rz5mge9bef0i","_id":"cm7yvcz3r006mrz5m55xuhkup"},{"post_id":"cm7yvcz3r006jrz5mgepp3cfk","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3r006orz5mdd503631"},{"post_id":"cm7yvcz3r006jrz5mgepp3cfk","tag_id":"cm7yvcz3e0069rz5mge9bef0i","_id":"cm7yvcz3s006qrz5m8rg6acog"},{"post_id":"cm7yvcz3r006lrz5m3z3ofb0k","tag_id":"cm7yvcz240005rz5m0ug4f7vh","_id":"cm7yvcz3s006srz5m1f2desrr"},{"post_id":"cm7yvcz3r006lrz5m3z3ofb0k","tag_id":"cm7yvcz3e0069rz5mge9bef0i","_id":"cm7yvcz3s006trz5m3ont6x0d"}],"Tag":[{"name":"Java","_id":"cm7yvcz240005rz5m0ug4f7vh"},{"name":"Flask","_id":"cm7yvcz29000hrz5m1el02w7a"},{"name":"Python","_id":"cm7yvcz2b000orz5m3yasexuk"},{"name":"微信公众平台开发","_id":"cm7yvcz2c000srz5m5ftqazqr"},{"name":"Mac","_id":"cm7yvcz2f000xrz5m41sy95is"},{"name":"单元测试","_id":"cm7yvcz2h0016rz5mcllb3hp2"},{"name":"心路札记","_id":"cm7yvcz2i001drz5m7tn0arb4"},{"name":"docker","_id":"cm7yvcz2j001krz5m888ue7u9"},{"name":"Java8新特性","_id":"cm7yvcz2k001qrz5m8y53ajsa"},{"name":"Java9新特性","_id":"cm7yvcz2z003krz5mec50bpzp"},{"name":"JDK集合","_id":"cm7yvcz38005brz5mcez0e91x"},{"name":"Git","_id":"cm7yvcz39005hrz5mesx81b8g"},{"name":"SpringMVC","_id":"cm7yvcz3d0067rz5m5yl72yba"},{"name":"阿里Java开发手册","_id":"cm7yvcz3e0069rz5mge9bef0i"}]}}